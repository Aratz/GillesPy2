
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>numpy package &#8212; GillesPy2 1 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GillesPy2 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="numpy-package">
<h1>numpy package<a class="headerlink" href="#numpy-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-basic-ode-solver-module">
<h2>numpy.basic_ode_solver module<a class="headerlink" href="#numpy-basic-ode-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-basic-root-solver-module">
<h2>numpy.basic_root_solver module<a class="headerlink" href="#numpy-basic-root-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-basic-tau-hybrid-solver-module">
<h2>numpy.basic_tau_hybrid_solver module<a class="headerlink" href="#numpy-basic-tau-hybrid-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-basic-tau-leaping-solver-module">
<h2>numpy.basic_tau_leaping_solver module<a class="headerlink" href="#numpy-basic-tau-leaping-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-ssa-solver-module">
<h2>numpy.ssa_solver module<a class="headerlink" href="#numpy-ssa-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="numpy-tau-leaping-solver-module">
<h2>numpy.tau_leaping_solver module<a class="headerlink" href="#numpy-tau-leaping-solver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-numpy">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-numpy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="numpy">
<h3>NumPy<a class="headerlink" href="#numpy" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Provides</dt>
<dd><ol class="first last arabic simple">
<li>An array object of arbitrary homogeneous items</li>
<li>Fast mathematical operations over arrays</li>
<li>Linear Algebra, Fourier Transforms, Random Number Generation</li>
</ol>
</dd>
</dl>
<div class="section" id="how-to-use-the-documentation">
<h4>How to use the documentation<a class="headerlink" href="#how-to-use-the-documentation" title="Permalink to this headline">¶</a></h4>
<p>Documentation is available in two forms: docstrings provided
with the code, and a loose standing reference guide, available from
<a class="reference external" href="http://www.scipy.org">the NumPy homepage</a>.</p>
<p>We recommend exploring the docstrings using
<a class="reference external" href="http://ipython.scipy.org">IPython</a>, an advanced Python shell with
TAB-completion and introspection capabilities.  See below for further
instructions.</p>
<p>The docstring examples assume that <cite>numpy</cite> has been imported as <cite>np</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Code snippets are indicated by three greater-than signs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Use the built-in <code class="docutils literal"><span class="pre">help</span></code> function to view a function’s docstring:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<p>For some objects, <code class="docutils literal"><span class="pre">np.info(obj)</span></code> may provide additional help.  This is
particularly true if you see the line “Help on ufunc object:” at the top
of the help() page.  Ufuncs are implemented in C, not Python, for speed.
The native Python help() does not know how to view their help, but our
np.info() function does.</p>
<p>To search for documents containing a keyword, do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s1">&#39;keyword&#39;</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<p>General-purpose documents like a glossary and help on the basic concepts
of numpy are available under the <code class="docutils literal"><span class="pre">doc</span></code> sub-module:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">doc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
</div>
<div class="section" id="available-subpackages">
<h4>Available subpackages<a class="headerlink" href="#available-subpackages" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>doc</dt>
<dd>Topical documentation on broadcasting, indexing, etc.</dd>
<dt>lib</dt>
<dd>Basic functions used by several sub-packages.</dd>
<dt>random</dt>
<dd>Core Random Tools</dd>
<dt>linalg</dt>
<dd>Core Linear Algebra Tools</dd>
<dt>fft</dt>
<dd>Core FFT routines</dd>
<dt>polynomial</dt>
<dd>Polynomial tools</dd>
<dt>testing</dt>
<dd>NumPy testing tools</dd>
<dt>f2py</dt>
<dd>Fortran to Python Interface Generator.</dd>
<dt>distutils</dt>
<dd>Enhancements to distutils with support for
Fortran compilers support and more.</dd>
</dl>
</div>
<div class="section" id="utilities">
<h4>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>test</dt>
<dd>Run numpy unittests</dd>
<dt>show_config</dt>
<dd>Show numpy build configuration</dd>
<dt>dual</dt>
<dd>Overwrite certain functions with high-performance Scipy tools</dd>
<dt>matlib</dt>
<dd>Make everything matrices.</dd>
<dt>__version__</dt>
<dd>NumPy version string</dd>
</dl>
</div>
<div class="section" id="viewing-documentation-using-ipython">
<h4>Viewing documentation using IPython<a class="headerlink" href="#viewing-documentation-using-ipython" title="Permalink to this headline">¶</a></h4>
<p>Start IPython with the NumPy profile (<code class="docutils literal"><span class="pre">ipython</span> <span class="pre">-p</span> <span class="pre">numpy</span></code>), which will
import <cite>numpy</cite> under the alias <cite>np</cite>.  Then, use the <code class="docutils literal"><span class="pre">cpaste</span></code> command to
paste examples into the shell.  To see which functions are available in
<cite>numpy</cite>, type <code class="docutils literal"><span class="pre">np.&lt;TAB&gt;</span></code> (where <code class="docutils literal"><span class="pre">&lt;TAB&gt;</span></code> refers to the TAB key), or use
<code class="docutils literal"><span class="pre">np.*cos*?&lt;ENTER&gt;</span></code> (where <code class="docutils literal"><span class="pre">&lt;ENTER&gt;</span></code> refers to the ENTER key) to narrow
down the list.  To view the docstring for a function, use
<code class="docutils literal"><span class="pre">np.cos?&lt;ENTER&gt;</span></code> (to view the docstring) and <code class="docutils literal"><span class="pre">np.cos??&lt;ENTER&gt;</span></code> (to view
the source code).</p>
</div>
<div class="section" id="copies-vs-in-place-operation">
<h4>Copies vs. in-place operation<a class="headerlink" href="#copies-vs-in-place-operation" title="Permalink to this headline">¶</a></h4>
<p>Most of the functions in <cite>numpy</cite> return a copy of the array argument
(e.g., <cite>np.sort</cite>).  In-place versions of these functions are often
available as array methods, i.e. <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.array([1,2,3]);</span> <span class="pre">x.sort()</span></code>.
Exceptions to this rule are documented.</p>
<dl class="exception">
<dt id="numpy.ModuleDeprecationWarning">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">ModuleDeprecationWarning</code><a class="headerlink" href="#numpy.ModuleDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">DeprecationWarning</span></code></p>
<p>Module deprecation warning.</p>
<p>The nose tester turns ordinary Deprecation warnings into test failures.
That makes it hard to deprecate whole modules, because they get
imported by default. So this is a special Deprecation warning that the
nose tester will let pass without making tests fail.</p>
</dd></dl>

<dl class="exception">
<dt id="numpy.VisibleDeprecationWarning">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">VisibleDeprecationWarning</code><a class="headerlink" href="#numpy.VisibleDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">UserWarning</span></code></p>
<p>Visible deprecation warning.</p>
<p>By default, python will not show deprecation warnings, so this class
can be used when a very visible warning is helpful, for example because
the usage is most likely a user bug.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.pkgload">
<code class="descclassname">numpy.</code><code class="descname">pkgload</code><span class="sig-paren">(</span><em>*packages</em>, <em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.pkgload" title="Permalink to this definition">¶</a></dt>
<dd><p>Load one or more packages into parent package top-level namespace.</p>
<p>This function is intended to shorten the need to import many
subpackages, say of scipy, constantly with statements such as</p>
<blockquote>
<div>import scipy.linalg, scipy.fftpack, scipy.etc…</div></blockquote>
<p>Instead, you can say:</p>
<blockquote>
<div>import scipy
scipy.pkgload(‘linalg’,’fftpack’,…)</div></blockquote>
<p>or</p>
<blockquote>
<div>scipy.pkgload()</div></blockquote>
<p>to load all of them in one call.</p>
<p>If a name which doesn’t exist in scipy’s namespace is
given, a warning is shown.</p>
<blockquote>
<div><dl class="docutils">
<dt><a href="#id1"><span class="problematic" id="id2">*</span></a>packages <span class="classifier-delimiter">:</span> <span class="classifier">arg-tuple</span></dt>
<dd>the names (one or more strings) of all the modules one
wishes to load into the top-level namespace.</dd>
<dt>verbose= <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>verbosity level [default: -1].
verbose=-1 will suspend also warnings.</dd>
<dt>force= <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>when True, force reloading loaded packages [default: False].</dd>
<dt>postpone= <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>when True, don’t load packages [default: False]</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="numpy.PackageLoader">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">PackageLoader</code><span class="sig-paren">(</span><em>verbose=False</em>, <em>infunc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.PackageLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="numpy.PackageLoader.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>mess</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.PackageLoader.error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.PackageLoader.get_pkgdocs">
<code class="descname">get_pkgdocs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.PackageLoader.get_pkgdocs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return documentation summary of subpackages.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.PackageLoader.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>mess</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.PackageLoader.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.PackageLoader.warn">
<code class="descname">warn</code><span class="sig-paren">(</span><em>mess</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.PackageLoader.warn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.show_config">
<code class="descclassname">numpy.</code><code class="descname">show_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.show_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="numpy.memmap">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">memmap</code><a class="headerlink" href="#numpy.memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a></p>
<p>Create a memory-map to an array stored in a <em>binary</em> file on disk.</p>
<p>Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory.  NumPy’s
memmap’s are array-like objects.  This differs from Python’s <code class="docutils literal"><span class="pre">mmap</span></code>
module, which uses file-like objects.</p>
<p>This subclass of ndarray has some unpleasant interactions with
some operations, because it doesn’t quite fit properly as a subclass.
An alternative to using this subclass is to create the <code class="docutils literal"><span class="pre">mmap</span></code>
object yourself, then create an ndarray with ndarray.__new__ directly,
passing the object created in its ‘buffer=’ parameter.</p>
<p>This class may at some point be turned into a factory function
which returns a view into an mmap buffer.</p>
<p>Delete the memmap instance to close the memmap file.</p>
<dl class="docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str, file-like object, or pathlib.Path instance</span></dt>
<dd>The file name or file object to be used as the array data buffer.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The data-type used to interpret the file contents.
Default is <cite>uint8</cite>.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘r+’, ‘r’, ‘w+’, ‘c’}, optional</span></dt>
<dd><p class="first">The file is opened in this mode:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>‘r’</td>
<td>Open existing file for reading only.</td>
</tr>
<tr class="row-even"><td>‘r+’</td>
<td>Open existing file for reading and writing.</td>
</tr>
<tr class="row-odd"><td>‘w+’</td>
<td>Create or overwrite existing file for reading and writing.</td>
</tr>
<tr class="row-even"><td>‘c’</td>
<td>Copy-on-write: assignments affect data in memory, but
changes are not saved to disk.  The file on disk is
read-only.</td>
</tr>
</tbody>
</table>
<p class="last">Default is ‘r+’.</p>
</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>In the file, array data starts at this offset. Since <cite>offset</cite> is
measured in bytes, it should normally be a multiple of the byte-size
of <cite>dtype</cite>. When <code class="docutils literal"><span class="pre">mode</span> <span class="pre">!=</span> <span class="pre">'r'</span></code>, even positive offsets beyond end of
file are valid; The file will be extended to accommodate the
additional data. By default, <code class="docutils literal"><span class="pre">memmap</span></code> will start at the beginning of
the file, even if <code class="docutils literal"><span class="pre">filename</span></code> is a file pointer <code class="docutils literal"><span class="pre">fp</span></code> and
<code class="docutils literal"><span class="pre">fp.tell()</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd>The desired shape of the array. If <code class="docutils literal"><span class="pre">mode</span> <span class="pre">==</span> <span class="pre">'r'</span></code> and the number
of remaining bytes after <cite>offset</cite> is not a multiple of the byte-size
of <cite>dtype</cite>, you must specify <cite>shape</cite>. By default, the returned array
will be 1-D with the number of elements determined by file size
and data-type.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Specify the order of the ndarray memory layout:
<span class="xref std std-term">row-major</span>, C-style or <span class="xref std std-term">column-major</span>,
Fortran-style.  This only has an effect if the shape is
greater than 1-D.  The default order is ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str or pathlib.Path instance</span></dt>
<dd>Path to the mapped file.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Offset position in the file.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>File mode.</dd>
</dl>
<dl class="docutils">
<dt>flush</dt>
<dd>Flush any changes in memory to file on disk.
When you delete a memmap object, flush is called first to write
changes to disk before removing the object.</dd>
</dl>
<p>lib.format.open_memmap : Create or load a memory-mapped <code class="docutils literal"><span class="pre">.npy</span></code> file.</p>
<p>The memmap object can be used anywhere an ndarray is accepted.
Given a memmap <code class="docutils literal"><span class="pre">fp</span></code>, <code class="docutils literal"><span class="pre">isinstance(fp,</span> <span class="pre">numpy.ndarray)</span></code> returns
<code class="docutils literal"><span class="pre">True</span></code>.</p>
<p>Memory-mapped files cannot be larger than 2GB on 32-bit systems.</p>
<p>When a memmap causes a file to be created or extended beyond its
current size in the filesystem, the contents of the new part are
unspecified. On systems with POSIX filesystem semantics, the extended
part will be filled with zero bytes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>This example uses a temporary file so that doctest doesn’t write
files to your directory. You would use a ‘normal’ filename.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="k">import</span> <span class="n">mkdtemp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mkdtemp</span><span class="p">(),</span> <span class="s1">&#39;newfile.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a memmap with dtype and shape that matches our data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">memmap([[ 0.,  0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.,  0.]], dtype=float32)</span>
</pre></div>
</div>
<p>Write data to memmap array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span><span class="o">.</span><span class="n">filename</span> <span class="o">==</span> <span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Deletion flushes memory changes to disk before removing the object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">fp</span>
</pre></div>
</div>
<p>Load the memmap and verify data was stored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">newfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newfp</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>Read-only memmap:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Copy-on-write memmap:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It’s possible to assign to copy-on-write array, but values are only
written into the memory copy of the array, and not written to disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpc</span>
<span class="go">memmap([[  0.,   0.,   0.,   0.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>File on disk is unchanged:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpr</span>
<span class="go">memmap([[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.],</span>
<span class="go">        [  8.,   9.,  10.,  11.]], dtype=float32)</span>
</pre></div>
</div>
<p>Offset into a memmap:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fpo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fpo</span>
<span class="go">memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.memmap.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.memmap.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Write any changes in the array to the file on disk.</p>
<p>For further information, see <cite>memmap</cite>.</p>
<p>None</p>
<p>memmap</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.ndarray">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">ndarray</code><a class="headerlink" href="#numpy.ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="docutils">
<dt>ndarray(shape, dtype=float, buffer=None, offset=0,</dt>
<dd>strides=None, order=None)</dd>
</dl>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<p>Arrays should be constructed using <cite>array</cite>, <cite>zeros</cite> or <cite>empty</cite> (refer
to the See Also section below).  The parameters given here refer to
a low-level method (<cite>ndarray(…)</cite>) for instantiating an array.</p>
<p>For more information, refer to the <cite>numpy</cite> module and examine the
methods and attributes of an array.</p>
<p>(for the __new__ method; see Notes below)</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>Shape of created array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Any object that can be interpreted as a numpy data type.</dd>
<dt>buffer <span class="classifier-delimiter">:</span> <span class="classifier">object exposing buffer interface, optional</span></dt>
<dd>Used to fill the array with data.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Offset of array data in buffer.</dd>
<dt>strides <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, optional</span></dt>
<dd>Strides of data in memory.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Row-major (C-style) or column-major (Fortran-style) order.</dd>
</dl>
<dl class="docutils">
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Transpose of the array.</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">buffer</span></dt>
<dd>The array’s elements, in memory.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype object</span></dt>
<dd>Describes the format of the elements in the array.</dd>
<dt>flags <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Dictionary containing information related to memory use, e.g.,
‘C_CONTIGUOUS’, ‘OWNDATA’, ‘WRITEABLE’, etc.</dd>
<dt>flat <span class="classifier-delimiter">:</span> <span class="classifier">numpy.flatiter object</span></dt>
<dd>Flattened version of the array as an iterator.  The iterator
allows assignments, e.g., <code class="docutils literal"><span class="pre">x.flat</span> <span class="pre">=</span> <span class="pre">3</span></code> (See <cite>ndarray.flat</cite> for
assignment examples; TODO).</dd>
<dt>imag <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Imaginary part of the array.</dd>
<dt>real <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Real part of the array.</dd>
<dt>size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of elements in the array.</dd>
<dt>itemsize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The memory use of each array element in bytes.</dd>
<dt>nbytes <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The total number of bytes required to store the array data,
i.e., <code class="docutils literal"><span class="pre">itemsize</span> <span class="pre">*</span> <span class="pre">size</span></code>.</dd>
<dt>ndim <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The array’s number of dimensions.</dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>Shape of the array.</dd>
<dt>strides <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The step-size required to move from one element to the next in
memory. For example, a contiguous <code class="docutils literal"><span class="pre">(3,</span> <span class="pre">4)</span></code> array of type
<code class="docutils literal"><span class="pre">int16</span></code> in C-order has strides <code class="docutils literal"><span class="pre">(8,</span> <span class="pre">2)</span></code>.  This implies that
to move from element to element in memory requires jumps of 2 bytes.
To move from row-to-row, one needs to jump 8 bytes at a time
(<code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4</span></code>).</dd>
<dt>ctypes <span class="classifier-delimiter">:</span> <span class="classifier">ctypes object</span></dt>
<dd>Class containing properties of the array needed for interaction
with ctypes.</dd>
<dt>base <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>If the array is a view into another array, that array is its <cite>base</cite>
(unless that array is also a view).  The <cite>base</cite> array is where the
array data is actually stored.</dd>
</dl>
<p>array : Construct an array.
zeros : Create an array, each element of which is zero.
empty : Create an array, but leave its allocated memory unchanged (i.e.,</p>
<blockquote>
<div>it contains “garbage”).</div></blockquote>
<p>dtype : Create a data-type.</p>
<p>There are two modes of creating an array using <code class="docutils literal"><span class="pre">__new__</span></code>:</p>
<ol class="arabic simple">
<li>If <cite>buffer</cite> is None, then only <cite>shape</cite>, <cite>dtype</cite>, and <cite>order</cite>
are used.</li>
<li>If <cite>buffer</cite> is an object exposing the buffer interface, then
all keywords are interpreted.</li>
</ol>
<p>No <code class="docutils literal"><span class="pre">__init__</span></code> method is needed because the array is fully initialized
after the <code class="docutils literal"><span class="pre">__new__</span></code> method.</p>
<p>These examples illustrate the low-level <cite>ndarray</cite> constructor.  Refer
to the <cite>See Also</cite> section above for easier ways of constructing an
ndarray.</p>
<p>First mode, <cite>buffer</cite> is None:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[ -1.13698227e+002,   4.25087011e-303],</span>
<span class="go">       [  2.88528414e-306,   3.27025015e-309]])         #random</span>
</pre></div>
</div>
<p>Second mode:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>           <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># offset = 1*itemsize, i.e. skip first element</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.ndarray.T">
<code class="descname">T</code><a class="headerlink" href="#numpy.ndarray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.transpose(), except that self is returned if
self.ndim &lt; 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[ 1.,  3.],</span>
<span class="go">       [ 2.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.all">
<code class="descname">all</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if all elements evaluate to True.</p>
<p>Refer to <cite>numpy.all</cite> for full documentation.</p>
<p>numpy.all : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.any">
<code class="descname">any</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<p>numpy.any : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices of the maximum values along the given axis.</p>
<p>Refer to <cite>numpy.argmax</cite> for full documentation.</p>
<p>numpy.argmax : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p>
<p>Refer to <cite>numpy.argmin</cite> for detailed documentation.</p>
<p>numpy.argmin : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.argpartition">
<code class="descname">argpartition</code><span class="sig-paren">(</span><em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would partition this array.</p>
<p>Refer to <cite>numpy.argpartition</cite> for full documentation.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<p>numpy.argpartition : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort this array.</p>
<p>Refer to <cite>numpy.argsort</cite> for full documentation.</p>
<p>numpy.argsort : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em>, <em>order='K'</em>, <em>casting='unsafe'</em>, <em>subok=True</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the array, cast to a specified type.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype</span></dt>
<dd>Typecode or data-type to which the array is cast.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout order of the result.
‘C’ means C order, ‘F’ means Fortran order, ‘A’
means ‘F’ order if all the arrays are Fortran contiguous,
‘C’ order otherwise, and ‘K’ means as close to the
order the array elements appear in memory as possible.
Default is ‘K’.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur. Defaults to ‘unsafe’
for backwards compatibility.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then sub-classes will be passed-through (default), otherwise
the returned array will be forced to be a base-class array.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>By default, astype always returns a newly allocated array. If this
is set to false, and the <cite>dtype</cite>, <cite>order</cite>, and <cite>subok</cite>
requirements are satisfied, the input array is returned instead
of a copy.</dd>
</dl>
<dl class="docutils">
<dt>arr_t <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Unless <cite>copy</cite> is False and the other conditions for returning the input
array are satisfied (see description for <cite>copy</cite> input parameter), <cite>arr_t</cite>
is a new array of the same shape as the input array, with dtype, order
given by <cite>dtype</cite>, <cite>order</cite>.</dd>
</dl>
<p>Starting in NumPy 1.9, astype method now returns an error if the string
dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
value of integer/float array that is being casted. Previously the casting
was allowed even if the result was truncated.</p>
<dl class="docutils">
<dt>ComplexWarning</dt>
<dd>When casting from complex to float or int. To avoid this,
one should use <code class="docutils literal"><span class="pre">a.real.astype(t)</span></code>.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1. ,  2. ,  2.5])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.base">
<code class="descname">base</code><a class="headerlink" href="#numpy.ndarray.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Base object if memory is from some other object.</p>
<p>The base of an array that owns its memory is None:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Slicing creates a view, whose memory is shared with x:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.byteswap">
<code class="descname">byteswap</code><span class="sig-paren">(</span><em>inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.byteswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the bytes of the array elements</p>
<p>Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.</p>
<dl class="docutils">
<dt>inplace <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If <code class="docutils literal"><span class="pre">True</span></code>, swap bytes in-place, default is <code class="docutils literal"><span class="pre">False</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The byteswapped array. If <cite>inplace</cite> is <code class="docutils literal"><span class="pre">True</span></code>, this is
a view to self.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">8755</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="go">[&#39;0x1&#39;, &#39;0x100&#39;, &#39;0x2233&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  256,     1, 13090], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="go">[&#39;0x100&#39;, &#39;0x1&#39;, &#39;0x3322&#39;]</span>
</pre></div>
</div>
<p>Arrays of strings are not swapped</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ceg&#39;</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span>
<span class="go">array([&#39;ceg&#39;, &#39;fac&#39;],</span>
<span class="go">      dtype=&#39;|S3&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.choose">
<code class="descname">choose</code><span class="sig-paren">(</span><em>choices</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <cite>numpy.choose</cite> for full documentation.</p>
<p>numpy.choose : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><em>min=None</em>, <em>max=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array whose values are limited to <code class="docutils literal"><span class="pre">[min,</span> <span class="pre">max]</span></code>.
One of max or min must be given.</p>
<p>Refer to <cite>numpy.clip</cite> for full documentation.</p>
<p>numpy.clip : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.compress">
<code class="descname">compress</code><span class="sig-paren">(</span><em>condition</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return selected slices of this array along given axis.</p>
<p>Refer to <cite>numpy.compress</cite> for full documentation.</p>
<p>numpy.compress : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex-conjugate all elements.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate, element-wise.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout of the copy. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible. (Note that this function and <a class="reference internal" href="#numpy.copy" title="numpy.copy"><code class="xref py py-func docutils literal"><span class="pre">numpy.copy()</span></code></a> are very
similar, but have different default values for their order=
arguments.)</dd>
</dl>
<p>numpy.copy
numpy.copyto</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.ctypes">
<code class="descname">ctypes</code><a class="headerlink" href="#numpy.ndarray.ctypes" title="Permalink to this definition">¶</a></dt>
<dd><p>An object to simplify the interaction of the array with the ctypes
module.</p>
<p>This attribute creates an object that makes it easier to use arrays
when calling shared libraries with the ctypes module. The returned
object has, among others, data, shape, and strides attributes (see
Notes below) which themselves return ctypes objects that can be used
as arguments to a shared library.</p>
<p>None</p>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">Python object</span></dt>
<dd>Possessing attributes data, shape, strides, etc.</dd>
</dl>
<p>numpy.ctypeslib</p>
<p>Below are the public attributes of this object which were documented
in “Guide to NumPy” (we have omitted undocumented public attributes,
as well as documented private attributes):</p>
<ul class="simple">
<li>data: A pointer to the memory area of the array as a Python integer.
This memory area may contain data that is not aligned, or not in correct
byte-order. The memory area may not even be writeable. The array
flags and data-type of this array should be respected when passing this
attribute to arbitrary C-code to avoid trouble that can include Python
crashing. User Beware! The value of this attribute is exactly the same
as self._array_interface_[‘data’][0].</li>
<li>shape (c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the C-integer corresponding to dtype(‘p’) on this
platform. This base-type could be c_int, c_long, or c_longlong
depending on the platform. The c_intp type is defined accordingly in
numpy.ctypeslib. The ctypes array contains the shape of the underlying
array.</li>
<li>strides (c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the same as for the shape attribute. This ctypes array
contains the strides information from the underlying array. This strides
information is important for showing how many bytes must be jumped to
get to the next element in the array.</li>
<li>data_as(obj): Return the data pointer cast to a particular c-types object.
For example, calling self._as_parameter_ is equivalent to
self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
pointer to a ctypes array of floating-point data:
self.data_as(ctypes.POINTER(ctypes.c_double)).</li>
<li>shape_as(obj): Return the shape tuple as an array of some other c-types
type. For example: self.shape_as(ctypes.c_short).</li>
<li>strides_as(obj): Return the strides tuple as an array of some other
c-types type. For example: self.strides_as(ctypes.c_longlong).</li>
</ul>
<p>Be careful using the ctypes attribute - especially on temporary
arrays or arrays constructed on the fly. For example, calling
<code class="docutils literal"><span class="pre">(a+b).ctypes.data_as(ctypes.c_void_p)</span></code> returns a pointer to memory
that is invalid because the array created as (a+b) is deallocated
before the next Python statement. You can avoid this problem using
either <code class="docutils literal"><span class="pre">c=a+b</span></code> or <code class="docutils literal"><span class="pre">ct=(a+b).ctypes</span></code>. In the latter case, ct will
hold a reference to the array until ct is deleted or re-assigned.</p>
<p>If the ctypes module is not available, then the ctypes attribute
of array objects still returns something useful, but ctypes objects
are not returned and errors may be raised instead. In particular,
the object will still have the as parameter attribute which will
return an integer equal to the data attribute.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">30439712</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x01F01300&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_longlong(4294967296L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">shape_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">)</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">strides</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">strides_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">)</span>
<span class="go">&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumprod</cite> for full documentation.</p>
<p>numpy.cumprod : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along the given axis.</p>
<p>Refer to <cite>numpy.cumsum</cite> for full documentation.</p>
<p>numpy.cumsum : equivalent function</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.data">
<code class="descname">data</code><a class="headerlink" href="#numpy.ndarray.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.diagonal">
<code class="descname">diagonal</code><span class="sig-paren">(</span><em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.</p>
<p>Refer to <a class="reference internal" href="#numpy.diagonal" title="numpy.diagonal"><code class="xref py py-func docutils literal"><span class="pre">numpy.diagonal()</span></code></a> for full documentation.</p>
<p>numpy.diagonal : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays.</p>
<p>Refer to <cite>numpy.dot</cite> for full documentation.</p>
<p>numpy.dot : equivalent function</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 2.,  2.],</span>
<span class="go">       [ 2.,  2.]])</span>
</pre></div>
</div>
<p>This array method can be conveniently chained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 8.,  8.],</span>
<span class="go">       [ 8.,  8.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#numpy.ndarray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data-type of the array’s elements.</p>
<p>None</p>
<p>d : numpy dtype object</p>
<p>numpy.dtype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.dtype&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A string naming the dump file.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.</p>
<p>None</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the array with a scalar value.</p>
<dl class="docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>All elements of <cite>a</cite> will be assigned this value.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.flags">
<code class="descname">flags</code><a class="headerlink" href="#numpy.ndarray.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Information about the memory layout of the array.</p>
<dl class="docutils">
<dt>C_CONTIGUOUS (C)</dt>
<dd>The data is in a single, C-style contiguous segment.</dd>
<dt>F_CONTIGUOUS (F)</dt>
<dd>The data is in a single, Fortran-style contiguous segment.</dd>
<dt>OWNDATA (O)</dt>
<dd>The array owns the memory it uses or borrows it from another object.</dd>
<dt>WRITEABLE (W)</dt>
<dd>The data area can be written to.  Setting this to False locks
the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
from its base array at creation time, but a view of a writeable
array may be subsequently locked while the base array remains writeable.
(The opposite is not true, in that a view of a locked array may not
be made writeable.  However, currently, locking a base object does not
lock any views that already reference it, so under that circumstance it
is possible to alter the contents of a locked array via a previously
created writeable view onto it.)  Attempting to change a non-writeable
array raises a RuntimeError exception.</dd>
<dt>ALIGNED (A)</dt>
<dd>The data and all elements are aligned appropriately for the hardware.</dd>
<dt>WRITEBACKIFCOPY (X)</dt>
<dd>This array is a copy of some other array. The C-API function
PyArray_ResolveWritebackIfCopy must be called before deallocating
to the base array will be updated with the contents of this array.</dd>
<dt>UPDATEIFCOPY (U)</dt>
<dd>(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.
When this array is
deallocated, the base array will be updated with the contents of
this array.</dd>
<dt>FNC</dt>
<dd>F_CONTIGUOUS and not C_CONTIGUOUS.</dd>
<dt>FORC</dt>
<dd>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</dd>
<dt>BEHAVED (B)</dt>
<dd>ALIGNED and WRITEABLE.</dd>
<dt>CARRAY (CA)</dt>
<dd>BEHAVED and C_CONTIGUOUS.</dd>
<dt>FARRAY (FA)</dt>
<dd>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</dd>
</dl>
<p>The <cite>flags</cite> object can be accessed dictionary-like (as in <code class="docutils literal"><span class="pre">a.flags['WRITEABLE']</span></code>),
or by using lowercased attribute names (as in <code class="docutils literal"><span class="pre">a.flags.writeable</span></code>). Short flag
names are only supported in dictionary access.</p>
<p>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be
changed by the user, via direct assignment to the attribute or dictionary
entry, or by calling <cite>ndarray.setflags</cite>.</p>
<p>The array flags cannot be set arbitrarily:</p>
<ul class="simple">
<li>UPDATEIFCOPY can only be set <code class="docutils literal"><span class="pre">False</span></code>.</li>
<li>WRITEBACKIFCOPY can only be set <code class="docutils literal"><span class="pre">False</span></code>.</li>
<li>ALIGNED can only be set <code class="docutils literal"><span class="pre">True</span></code> if the data is truly aligned.</li>
<li>WRITEABLE can only be set <code class="docutils literal"><span class="pre">True</span></code> if the array owns its own memory
or the ultimate owner of the memory exposes a writeable buffer
interface or is a string.</li>
</ul>
<p>Arrays can be both C-style and Fortran-style contiguous simultaneously.
This is clear for 1-dimensional arrays, but can also be true for higher
dimensional arrays.</p>
<p>Even for contiguous arrays a stride for a given dimension
<code class="docutils literal"><span class="pre">arr.strides[dim]</span></code> may be <em>arbitrary</em> if <code class="docutils literal"><span class="pre">arr.shape[dim]</span> <span class="pre">==</span> <span class="pre">1</span></code>
or the array has no elements.
It does <em>not</em> generally hold that <code class="docutils literal"><span class="pre">self.strides[-1]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code>
for C-style contiguous arrays or <code class="docutils literal"><span class="pre">self.strides[0]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code> for
Fortran-style contiguous arrays is true.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.flat">
<code class="descname">flat</code><a class="headerlink" href="#numpy.ndarray.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>A 1-D iterator over the array.</p>
<p>This is a <cite>numpy.flatiter</cite> instance, which acts similarly to, but is not
a subclass of, Python’s built-in iterator object.</p>
<p>flatten : Return a copy of the array collapsed into one dimension.</p>
<p>flatiter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.flatiter&#39;&gt;</span>
</pre></div>
</div>
<p>An assignment example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">x</span>
<span class="go">array([[3, 3, 3],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">x</span>
<span class="go">array([[3, 1, 3],</span>
<span class="go">       [3, 1, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array collapsed into one dimension.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>‘C’ means to flatten in row-major (C-style) order.
‘F’ means to flatten in column-major (Fortran-
style) order. ‘A’ means to flatten in column-major
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory,
row-major order otherwise. ‘K’ means to flatten
<cite>a</cite> in the order the elements occur in memory.
The default is ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of the input array, flattened to one dimension.</dd>
</dl>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 3, 2, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.getfield">
<code class="descname">getfield</code><span class="sig-paren">(</span><em>dtype</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a field of the given array as a certain type.</p>
<p>A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype</span></dt>
<dd>The data type of the view. The dtype size of the view can not be larger
than that of the array itself.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of bytes to skip before beginning the element view.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">4.</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.+1.j,  0.+0.j],</span>
<span class="go">       [ 0.+0.j,  2.+4.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  2.]])</span>
</pre></div>
</div>
<p>By choosing an offset of 8 bytes we can select the complex part of the
array for our view:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">   [ 0.,  4.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.imag">
<code class="descname">imag</code><a class="headerlink" href="#numpy.ndarray.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span>
<span class="go">array([ 0.        ,  0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.item">
<code class="descname">item</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.item" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an element of an array to a standard Python scalar and return it.</p>
<p>*args : Arguments (variable number and type)</p>
<blockquote>
<div><ul class="simple">
<li>none: in this case, the method only works for arrays
with one element (<cite>a.size == 1</cite>), which element is
copied into a standard Python scalar object and returned.</li>
<li>int_type: this argument is interpreted as a flat index into
the array, specifying which element to copy and return.</li>
<li>tuple of int_types: functions as does a single int_type argument,
except that the argument is interpreted as an nd-index into the
array.</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">Standard Python scalar object</span></dt>
<dd>A copy of the specified element of the array as a suitable
Python scalar</dd>
</dl>
<p>When the data type of <cite>a</cite> is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.</p>
<p><cite>item</cite> is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python’s optimized math.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 8, 3],</span>
<span class="go">       [8, 5, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.itemset">
<code class="descname">itemset</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.itemset" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p>
<p>There must be at least 1 argument, and define the last argument
as <em>item</em>.  Then, <code class="docutils literal"><span class="pre">a.itemset(*args)</span></code> is equivalent to but faster
than <code class="docutils literal"><span class="pre">a[args]</span> <span class="pre">=</span> <span class="pre">item</span></code>.  The item should be a scalar value and <cite>args</cite>
must select a single item in the array <cite>a</cite>.</p>
<dl class="docutils">
<dt>\*args <span class="classifier-delimiter">:</span> <span class="classifier">Arguments</span></dt>
<dd>If one argument: a scalar, only used in case <cite>a</cite> is of size 1.
If two arguments: the last argument is the value to be set
and must be a scalar, the first argument specifies a single array
element location. It is either an int or a tuple.</dd>
</dl>
<p>Compared to indexing syntax, <cite>itemset</cite> provides some speed increase
for placing a scalar into a particular location in an <cite>ndarray</cite>,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using <cite>itemset</cite> (and <cite>item</cite>) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 8, 3],</span>
<span class="go">       [8, 5, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 0, 3],</span>
<span class="go">       [8, 5, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#numpy.ndarray.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of one array element in bytes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum along a given axis.</p>
<p>Refer to <cite>numpy.amax</cite> for full documentation.</p>
<p>numpy.amax : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the array elements along given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<p>numpy.mean : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum along a given axis.</p>
<p>Refer to <cite>numpy.amin</cite> for full documentation.</p>
<p>numpy.amin : equivalent function</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#numpy.ndarray.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Total bytes consumed by the elements of the array.</p>
<p>Does not include memory consumed by non-element attributes of the
array object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">480</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">480</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#numpy.ndarray.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of array dimensions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.newbyteorder">
<code class="descname">newbyteorder</code><span class="sig-paren">(</span><em>new_order='S'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array with the same data viewed with a different byte order.</p>
<p>Equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbytorder</span><span class="p">(</span><span class="n">new_order</span><span class="p">))</span>
</pre></div>
</div>
<p>Changes are also made in all fields and sub-arrays of the array data
type.</p>
<dl class="docutils">
<dt>new_order <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first">Byte order to force; a value from the byte order specifications
below. <cite>new_order</cite> codes can be any of:</p>
<ul class="simple">
<li>‘S’ - swap dtype from current to opposite endian</li>
<li>{‘&lt;’, ‘L’} - little endian</li>
<li>{‘&gt;’, ‘B’} - big endian</li>
<li>{‘=’, ‘N’} - native order</li>
<li>{‘|’, ‘I’} - ignore (no change to byte order)</li>
</ul>
<p class="last">The default value (‘S’) results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <cite>new_order</cite> for the alternatives above.  For example,
any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</p>
</dd>
</dl>
<dl class="docutils">
<dt>new_arr <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>New array object with the dtype reflecting given change to the
byte order.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>Refer to <cite>numpy.nonzero</cite> for full documentation.</p>
<p>numpy.nonzero : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.partition">
<code class="descname">partition</code><span class="sig-paren">(</span><em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The kth element value will be in its
final sorted position and all smaller elements will be moved before it
and all equal or greater elements behind it.
The order of all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth of them into their sorted position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to sort. Default is -1, which means sort along the
last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc. A single field can
be specified as a string, and not all fields need to be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<p>numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.</p>
<p>See <code class="docutils literal"><span class="pre">np.partition</span></code> for notes on the different algorithms.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.prod">
<code class="descname">prod</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<p>numpy.prod : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.ptp">
<code class="descname">ptp</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak to peak (maximum - minimum) value along a given axis.</p>
<p>Refer to <cite>numpy.ptp</cite> for full documentation.</p>
<p>numpy.ptp : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>indices</em>, <em>values</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <code class="docutils literal"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p>
<p>Refer to <cite>numpy.put</cite> for full documentation.</p>
<p>numpy.put : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.ravel">
<code class="descname">ravel</code><span class="sig-paren">(</span><span class="optional">[</span><em>order</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened array.</p>
<p>Refer to <cite>numpy.ravel</cite> for full documentation.</p>
<p>numpy.ravel : equivalent function</p>
<p>ndarray.flat : a flat iterator on the array.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.real">
<code class="descname">real</code><a class="headerlink" href="#numpy.ndarray.real" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([ 1.        ,  0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>numpy.real : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>repeats</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<p>Refer to <cite>numpy.repeat</cite> for full documentation.</p>
<p>numpy.repeat : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>shape</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array containing the same data with a new shape.</p>
<p>Refer to <cite>numpy.reshape</cite> for full documentation.</p>
<p>numpy.reshape : equivalent function</p>
<p>Unlike the free function <cite>numpy.reshape</cite>, this method on <cite>ndarray</cite> allows
the elements of the shape parameter to be passed in as separate arguments.
For example, <code class="docutils literal"><span class="pre">a.reshape(10,</span> <span class="pre">11)</span></code> is equivalent to
<code class="docutils literal"><span class="pre">a.reshape((10,</span> <span class="pre">11))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>new_shape</em>, <em>refcheck=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change shape and size of array in-place.</p>
<dl class="docutils">
<dt>new_shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, or <cite>n</cite> ints</span></dt>
<dd>Shape of resized array.</dd>
<dt>refcheck <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If False, reference count will not be checked. Default is True.</dd>
</dl>
<p>None</p>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>a</cite> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</dd>
<dt>SystemError</dt>
<dd>If the <cite>order</cite> keyword argument is specified. This behaviour is a
bug in NumPy.</dd>
</dl>
<p>resize : Return a new array with the specified shape.</p>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<cite>refcheck</cite> to False.</p>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [2]])</span>
</pre></div>
</div>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># new_shape parameter doesn&#39;t have to be a tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 0]])</span>
</pre></div>
</div>
<p>Referencing an array prevents resizing…</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot resize an array that has been referenced ...</span>
</pre></div>
</div>
<p>Unless <cite>refcheck</cite> is False:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.round">
<code class="descname">round</code><span class="sig-paren">(</span><em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p>
<p>Refer to <cite>numpy.around</cite> for full documentation.</p>
<p>numpy.around : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.searchsorted">
<code class="descname">searchsorted</code><span class="sig-paren">(</span><em>v</em>, <em>side='left'</em>, <em>sorter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements of v should be inserted in a to maintain order.</p>
<p>For full documentation, see <cite>numpy.searchsorted</cite></p>
<p>numpy.searchsorted : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.setfield">
<code class="descname">setfield</code><span class="sig-paren">(</span><em>val</em>, <em>dtype</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value into a specified place in a field defined by a data-type.</p>
<p>Place <cite>val</cite> into <cite>a</cite>’s field defined by <cite>dtype</cite> and beginning <cite>offset</cite>
bytes into the field.</p>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>Value to be placed in field.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype object</span></dt>
<dd>Data-type of the field in which to place <cite>val</cite>.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of bytes into the field at which to place <cite>val</cite>.</dd>
</dl>
<p>None</p>
<p>getfield</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">array([[3, 3, 3],</span>
<span class="go">       [3, 3, 3],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],</span>
<span class="go">       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],</span>
<span class="go">       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.setflags">
<code class="descname">setflags</code><span class="sig-paren">(</span><em>write=None</em>, <em>align=None</em>, <em>uic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.</p>
<p>These Boolean-valued flags affect how numpy interprets the memory
area used by <cite>a</cite> (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)</p>
<dl class="docutils">
<dt>write <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> can be written to.</dd>
<dt>align <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> is aligned properly for its type.</dd>
<dt>uic <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> is a copy of another “base” array.</dd>
</dl>
<p>Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</p>
<p>WRITEABLE (W) the data area can be written to;</p>
<p>ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);</p>
<p>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</p>
<p>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.</p>
<p>All flags can be accessed using the single (upper case) letter as well
as the full name.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 0, 0],</span>
<span class="go">       [8, 5, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : False</span>
<span class="go">  ALIGNED : False</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">uic</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">cannot set WRITEBACKIFCOPY flag to True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.shape">
<code class="descname">shape</code><a class="headerlink" href="#numpy.ndarray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of array dimensions.</p>
<p>The shape property is usually used to get the current shape of an array,
but may also be used to reshape the array in-place by assigning a tuple of
array dimensions to it.  As with <cite>numpy.reshape</cite>, one of the new shape
dimensions can be -1, in which case its value is inferred from the size of
the array and the remaining dimensions. Reshaping an array in-place will
fail if a copy is required.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">total size of new array must be unchanged</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">incompatible shape for a non-contiguous array</span>
</pre></div>
</div>
<p>numpy.reshape : similar function
ndarray.reshape : similar method</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.size">
<code class="descname">size</code><a class="headerlink" href="#numpy.ndarray.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in the array.</p>
<p>Equal to <code class="docutils literal"><span class="pre">np.prod(a.shape)</span></code>, i.e., the product of the array’s
dimensions.</p>
<p><cite>a.size</cite> returns a standard arbitrary precision Python integer. This 
may not be the case with other methods of obtaining the same value
(like the suggested <code class="docutils literal"><span class="pre">np.prod(a.shape)</span></code>, which returns an instance
of <code class="docutils literal"><span class="pre">np.int_</span></code>), and may be relevant if the value is used further in
calculations that may overflow a fixed size integer type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort an array, in-place.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to sort. Default is -1, which means sort along the
last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm. Default is ‘quicksort’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<p>numpy.sort : Return a sorted copy of an array.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in sorted array.
partition: Partial sort.</p>
<p>See <code class="docutils literal"><span class="pre">sort</span></code> for notes on the different sorting algorithms.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [1, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;S1&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([(&#39;c&#39;, 1), (&#39;a&#39;, 2)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;|S1&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p>
<p>Refer to <cite>numpy.squeeze</cite> for full documentation.</p>
<p>numpy.squeeze : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the standard deviation of the array elements along given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<p>numpy.std : equivalent function</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ndarray.strides">
<code class="descname">strides</code><a class="headerlink" href="#numpy.ndarray.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
<p>The byte offset of element <code class="docutils literal"><span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...,</span> <span class="pre">i[n])</span></code> in an array <cite>a</cite>
is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
</pre></div>
</div>
<p>A more detailed explanation of strides can be found in the
“ndarray.rst” file in the NumPy reference guide.</p>
<p>Imagine an array of 32-bit integers (each 4 bytes):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>This array is stored in memory as 40 bytes, one after the other
(known as a contiguous block of memory).  The strides of an array tell
us how many bytes we have to skip in memory to move to the next position
along a certain axis.  For example, we have to skip 4 bytes (1 value) to
move to the next column, but 20 bytes (5 values) to get to the same
position in the next row.  As such, the strides for the array <cite>x</cite> will be
<code class="docutils literal"><span class="pre">(20,</span> <span class="pre">4)</span></code>.</p>
<p>numpy.lib.stride_tricks.as_strided</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(48, 16, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">strides</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">/</span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">17</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(32, 4, 224, 1344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">813</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">813</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the array elements over the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<p>numpy.sum : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<p>numpy.swapaxes : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>indices</em>, <em>axis=None</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p>
<p>Refer to <cite>numpy.take</cite> for full documentation.</p>
<p>numpy.take : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tobytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either ‘C’ or ‘Fortran’,
or ‘Any’ order (the default is ‘C’-order). ‘Any’ order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means ‘Fortran’ order.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, None}, optional</span></dt>
<dd>Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">bytes</span></dt>
<dd>Python bytes exhibiting a copy of <cite>a</cite>’s raw data.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.tofile">
<code class="descname">tofile</code><span class="sig-paren">(</span><em>fid</em>, <em>sep=&quot;&quot;</em>, <em>format=&quot;%s&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Write array to a file as text or binary (default).</p>
<p>Data is always written in ‘C’ order, independent of the order of <cite>a</cite>.
The data produced by this method can be recovered using the function
fromfile().</p>
<dl class="docutils">
<dt>fid <span class="classifier-delimiter">:</span> <span class="classifier">file or str</span></dt>
<dd>An open file object, or a string containing a filename.</dd>
<dt>sep <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Separator between array items for text output.
If “” (empty), a binary file is written, equivalent to
<code class="docutils literal"><span class="pre">file.write(a.tobytes())</span></code>.</dd>
<dt>format <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Format string for text file output.
Each entry in the array is formatted to text by first converting
it to the closest Python type, and then using “format” % item.</dd>
</dl>
<p>This is a convenience function for quick storage of array data.
Information on endianness and precision is lost, so this method is not a
good choice for files intended to archive data or transport data between
machines with different endianness. Some of these problems can be overcome
by outputting the data as text files, at the expense of speed and file
size.</p>
<p>When fid is a file object, array contents are directly written to the
file, bypassing the file object’s <code class="docutils literal"><span class="pre">write</span></code> method. As a result, tofile
cannot be used with files objects supporting compression (e.g., GzipFile)
or file-like objects that do not support <code class="docutils literal"><span class="pre">fileno()</span></code> (e.g., BytesIO).</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array as a (possibly nested) list.</p>
<p>Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible Python type.</p>
<p>none</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>The possibly nested list of array elements.</dd>
</dl>
<p>The array may be recreated, <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">np.array(a.tolist())</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[array([1, 2]), array([3, 4])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[1, 2], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.tostring">
<code class="descname">tostring</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Python bytes containing the raw data bytes in the array.</p>
<p>Constructs Python bytes showing a copy of the raw contents of
data memory. The bytes object can be produced in either ‘C’ or ‘Fortran’,
or ‘Any’ order (the default is ‘C’-order). ‘Any’ order means C-order
unless the F_CONTIGUOUS flag in the array is set, in which case it
means ‘Fortran’ order.</p>
<p>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, None}, optional</span></dt>
<dd>Order of the data for multidimensional arrays:
C, Fortran, or the same as for the original array.</dd>
</dl>
<dl class="docutils">
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">bytes</span></dt>
<dd>Python bytes exhibiting a copy of <cite>a</cite>’s raw data.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>Refer to <cite>numpy.trace</cite> for full documentation.</p>
<p>numpy.trace : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>*axes</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array, this has no effect. (To change between column and
row vectors, first cast the 1-D array into a matrix object.)
For a 2-D array, this is the usual matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code class="docutils literal"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></code>, then
<code class="docutils literal"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></code>.</p>
<p>axes : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>’s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>’s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a “convenience” alternative to the tuple form)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>View of <cite>a</cite>, with axes suitably permuted.</dd>
</dl>
<p>ndarray.T : Array property returning the array transposed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variance of the array elements, along given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<p>numpy.var : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndarray.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>dtype=None</em>, <em>type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndarray.view" title="Permalink to this definition">¶</a></dt>
<dd><p>New view of array with the same data.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type or ndarray sub-class, optional</span></dt>
<dd>Data-type descriptor of the returned view, e.g., float32 or int16. The
default, None, results in the view having the same data-type as <cite>a</cite>.
This argument can also be specified as an ndarray sub-class, which
then specifies the type of the returned object (this is equivalent to
setting the <code class="docutils literal"><span class="pre">type</span></code> parameter).</dd>
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">Python type, optional</span></dt>
<dd>Type of the returned view, e.g., ndarray or matrix.  Again, the
default None results in type preservation.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">a.view()</span></code> is used two different ways:</p>
<p><code class="docutils literal"><span class="pre">a.view(some_dtype)</span></code> or <code class="docutils literal"><span class="pre">a.view(dtype=some_dtype)</span></code> constructs a view
of the array’s memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.</p>
<p><code class="docutils literal"><span class="pre">a.view(ndarray_subclass)</span></code> or <code class="docutils literal"><span class="pre">a.view(type=ndarray_subclass)</span></code> just
returns an instance of <cite>ndarray_subclass</cite> that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.</p>
<p>For <code class="docutils literal"><span class="pre">a.view(some_dtype)</span></code>, if <code class="docutils literal"><span class="pre">some_dtype</span></code> has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of <code class="docutils literal"><span class="pre">a</span></code> (shown
by <code class="docutils literal"><span class="pre">print(a)</span></code>). It also depends on exactly how <code class="docutils literal"><span class="pre">a</span></code> is stored in
memory. Therefore if <code class="docutils literal"><span class="pre">a</span></code> is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
</pre></div>
</div>
<p>Viewing array data using a different type and dtype:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">matrix([[513]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt;</span>
</pre></div>
</div>
<p>Creating a view on a structured array so it can be used in calculations</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
</pre></div>
</div>
<p>Making changes to the view changes the underlying array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[(1, 20) (3, 4)]</span>
</pre></div>
</div>
<p>Using a view to convert an array to a recarray:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">a</span>
<span class="go">array([1], dtype=int8)</span>
</pre></div>
</div>
<p>Views share data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(9, 10)</span>
</pre></div>
</div>
<p>Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [4, 5]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">new type not compatible with array.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="go">array([[(1, 2)],</span>
<span class="go">       [(4, 5)]], dtype=[(&#39;width&#39;, &#39;&lt;i2&#39;), (&#39;length&#39;, &#39;&lt;i2&#39;)])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.flatiter">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">flatiter</code><a class="headerlink" href="#numpy.flatiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Flat iterator object to iterate over arrays.</p>
<p>A <cite>flatiter</cite> iterator is returned by <code class="docutils literal"><span class="pre">x.flat</span></code> for any array <cite>x</cite>.
It allows iterating over the array as if it were a 1-D array,
either in a for-loop or by calling its <cite>next</cite> method.</p>
<p>Iteration is done in row-major, C-style order (the last
index varying the fastest). The iterator can also be indexed using
basic slicing or advanced indexing.</p>
<p>ndarray.flat : Return a flat iterator over an array.
ndarray.flatten : Returns a flattened copy of an array.</p>
<p>A <cite>flatiter</cite> iterator can not be constructed directly from Python code
by calling the <cite>flatiter</cite> constructor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.flatiter&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">fl</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.flatiter.base">
<code class="descname">base</code><a class="headerlink" href="#numpy.flatiter.base" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the array that is iterated over.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.flatiter.coords">
<code class="descname">coords</code><a class="headerlink" href="#numpy.flatiter.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional tuple of current coordinates.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">coords</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">coords</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.flatiter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flatiter.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the iterator as a 1-D array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="go">array([0, 1, 2, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.flatiter.index">
<code class="descname">index</code><a class="headerlink" href="#numpy.flatiter.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Current flat index into the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span><span class="o">.</span><span class="n">index</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.nditer">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">nditer</code><a class="headerlink" href="#numpy.nditer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Efficient multi-dimensional iterator object to iterate over arrays.
To get started using this object, see the
<span class="xref std std-ref">introductory guide to array iteration</span>.</p>
<dl class="docutils">
<dt>op <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sequence of array_like</span></dt>
<dd>The array(s) to iterate over.</dd>
<dt>flags <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str, optional</span></dt>
<dd><p class="first">Flags to control the behavior of the iterator.</p>
<blockquote class="last">
<div><ul class="simple">
<li>“buffered” enables buffering when required.</li>
<li>“c_index” causes a C-order index to be tracked.</li>
<li>“f_index” causes a Fortran-order index to be tracked.</li>
<li>“multi_index” causes a multi-index, or a tuple of indices
with one per iteration dimension, to be tracked.</li>
<li>“common_dtype” causes all the operands to be converted to
a common data type, with copying or buffering as necessary.</li>
<li>“copy_if_overlap” causes the iterator to determine if read
operands have overlap with write operands, and make temporary
copies as necessary to avoid overlap. False positives (needless
copying) are possible in some cases.</li>
<li>“delay_bufalloc” delays allocation of the buffers until
a reset() call is made. Allows “allocate” operands to
be initialized before their values are copied into the buffers.</li>
<li>“external_loop” causes the <cite>values</cite> given to be
one-dimensional arrays with multiple values instead of
zero-dimensional arrays.</li>
<li>“grow_inner” allows the <cite>value</cite> array sizes to be made
larger than the buffer size when both “buffered” and
“external_loop” is used.</li>
<li>“ranged” allows the iterator to be restricted to a sub-range
of the iterindex values.</li>
<li>“refs_ok” enables iteration of reference types, such as
object arrays.</li>
<li>“reduce_ok” enables iteration of “readwrite” operands
which are broadcasted, also known as reduction operands.</li>
<li>“zerosize_ok” allows <cite>itersize</cite> to be zero.</li>
</ul>
</div></blockquote>
</dd>
<dt>op_flags <span class="classifier-delimiter">:</span> <span class="classifier">list of list of str, optional</span></dt>
<dd><p class="first">This is a list of flags for each operand. At minimum, one of
“readonly”, “readwrite”, or “writeonly” must be specified.</p>
<blockquote class="last">
<div><ul class="simple">
<li>“readonly” indicates the operand will only be read from.</li>
<li>“readwrite” indicates the operand will be read from and written to.</li>
<li>“writeonly” indicates the operand will only be written to.</li>
<li>“no_broadcast” prevents the operand from being broadcasted.</li>
<li>“contig” forces the operand data to be contiguous.</li>
<li>“aligned” forces the operand data to be aligned.</li>
<li>“nbo” forces the operand data to be in native byte order.</li>
<li>“copy” allows a temporary read-only copy if required.</li>
<li>“updateifcopy” allows a temporary read-write copy if required.</li>
<li>“allocate” causes the array to be allocated if it is None
in the <cite>op</cite> parameter.</li>
<li>“no_subtype” prevents an “allocate” operand from using a subtype.</li>
<li>“arraymask” indicates that this operand is the mask to use
for selecting elements when writing to operands with the
‘writemasked’ flag set. The iterator does not enforce this,
but when writing from a buffer back to the array, it only
copies those elements indicated by this mask.</li>
<li>‘writemasked’ indicates that only elements where the chosen
‘arraymask’ operand is True will be written to.</li>
<li>“overlap_assume_elementwise” can be used to mark operands that are
accessed only in the iterator order, to allow less conservative
copying when “copy_if_overlap” is present.</li>
</ul>
</div></blockquote>
</dd>
<dt>op_dtypes <span class="classifier-delimiter">:</span> <span class="classifier">dtype or tuple of dtype(s), optional</span></dt>
<dd>The required data type(s) of the operands. If copying or buffering
is enabled, the data will be converted to/from their original types.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the iteration order. ‘C’ means C order, ‘F’ means
Fortran order, ‘A’ means ‘F’ order if all the arrays are Fortran
contiguous, ‘C’ order otherwise, and ‘K’ means as close to the
order the array elements appear in memory as possible. This also
affects the element memory order of “allocate” operands, as they
are allocated to be compatible with iteration order.
Default is ‘K’.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur when making a copy
or buffering.  Setting this to ‘unsafe’ is not recommended,
as it can adversely affect accumulations.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
</dd>
<dt>op_axes <span class="classifier-delimiter">:</span> <span class="classifier">list of list of ints, optional</span></dt>
<dd>If provided, is a list of ints or None for each operands.
The list of axes for an operand is a mapping from the dimensions
of the iterator to the dimensions of the operand. A value of
-1 can be placed for entries, causing that dimension to be
treated as “newaxis”.</dd>
<dt>itershape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, optional</span></dt>
<dd>The desired shape of the iterator. This allows “allocate” operands
with a dimension mapped by op_axes not corresponding to a dimension
of a different operand to get a value not equal to 1 for that
dimension.</dd>
<dt>buffersize <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>When buffering is enabled, controls the size of the temporary
buffers. Set to 0 for the default value.</dd>
</dl>
<dl class="docutils">
<dt>dtypes <span class="classifier-delimiter">:</span> <span class="classifier">tuple of dtype(s)</span></dt>
<dd>The data types of the values provided in <cite>value</cite>. This may be
different from the operand data types if buffering is enabled.
Valid only before the iterator is closed.</dd>
<dt>finished <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether the iteration over the operands is finished or not.</dd>
<dt>has_delayed_bufalloc <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the iterator was created with the “delay_bufalloc” flag,
and no reset() function was called on it yet.</dd>
<dt>has_index <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the iterator was created with either the “c_index” or
the “f_index” flag, and the property <cite>index</cite> can be used to
retrieve it.</dd>
<dt>has_multi_index <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the iterator was created with the “multi_index” flag,
and the property <cite>multi_index</cite> can be used to retrieve it.</dd>
<dt>index</dt>
<dd>When the “c_index” or “f_index” flag was used, this property
provides access to the index. Raises a ValueError if accessed
and <cite>has_index</cite> is False.</dd>
<dt>iterationneedsapi <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether iteration requires access to the Python API, for example
if one of the operands is an object array.</dd>
<dt>iterindex <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>An index which matches the order of iteration.</dd>
<dt>itersize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Size of the iterator.</dd>
<dt>itviews</dt>
<dd>Structured view(s) of <cite>operands</cite> in memory, matching the reordered
and optimized iterator access pattern. Valid only before the iterator
is closed.</dd>
<dt>multi_index</dt>
<dd>When the “multi_index” flag was used, this property
provides access to the index. Raises a ValueError if accessed
accessed and <cite>has_multi_index</cite> is False.</dd>
<dt>ndim <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The iterator’s dimension.</dd>
<dt>nop <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of iterator operands.</dd>
<dt>operands <span class="classifier-delimiter">:</span> <span class="classifier">tuple of operand(s)</span></dt>
<dd>The array(s) to be iterated over. Valid only before the iterator is
closed.</dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>Shape tuple, the shape of the iterator.</dd>
<dt>value</dt>
<dd>Value of <cite>operands</cite> at current iteration. Normally, this is a
tuple of array scalars, but if the flag “external_loop” is used,
it is a tuple of one dimensional arrays.</dd>
</dl>
<p><cite>nditer</cite> supersedes <cite>flatiter</cite>.  The iterator implementation behind
<cite>nditer</cite> is also exposed by the NumPy C API.</p>
<p>The Python exposure supplies two iteration interfaces, one which follows
the Python iterator protocol, and another which mirrors the C-style
do-while pattern.  The native Python approach is better in most cases, but
if you need the iterator’s coordinates or index, use the C-style pattern.</p>
<p>Here is how we might write an <code class="docutils literal"><span class="pre">iter_add</span></code> function, using the
Python iterator protocol:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">iter_add_py</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>
    <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">addop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is the same function, but following the C-style pattern:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">iter_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>
    <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
            <span class="n">addop</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">it</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is an example outer product function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">outer_it</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mulop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;external_loop&#39;</span><span class="p">],</span>
            <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span> <span class="s1">&#39;allocate&#39;</span><span class="p">]],</span>
            <span class="n">op_axes</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                     <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)),</span>
                     <span class="kc">None</span><span class="p">])</span>
    <span class="k">with</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="n">mulop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">outer_it</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
</pre></div>
</div>
<p>Here is an example function which operates like a “lambda” ufunc:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">luf</span><span class="p">(</span><span class="n">lamdaexpr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="s2">&quot;luf(lambdaexpr, op1, ..., opn, out=None, order=&#39;K&#39;, casting=&#39;safe&#39;, buffersize=0)&quot;</span>
    <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">args</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;buffered&#39;</span><span class="p">,</span><span class="s1">&#39;external_loop&#39;</span><span class="p">],</span>
            <span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">,</span><span class="s1">&#39;no_broadcast&#39;</span><span class="p">]]</span> <span class="o">+</span>
                            <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">,</span><span class="s1">&#39;nbo&#39;</span><span class="p">,</span><span class="s1">&#39;aligned&#39;</span><span class="p">]]</span><span class="o">*</span><span class="n">nargs</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">),</span>
            <span class="n">casting</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;casting&#39;</span><span class="p">,</span><span class="s1">&#39;safe&#39;</span><span class="p">),</span>
            <span class="n">buffersize</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;buffersize&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
        <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamdaexpr</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">luf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span>  <span class="mf">0.5</span><span class="p">,</span>   <span class="mf">1.5</span><span class="p">,</span>   <span class="mf">4.5</span><span class="p">,</span>   <span class="mf">9.5</span><span class="p">,</span>  <span class="mf">16.5</span><span class="p">])</span>
</pre></div>
</div>
<p>If operand flags <cite>“writeonly”</cite> or <cite>“readwrite”</cite> are used the operands may
be views into the original data with the <cite>WRITEBACKIFCOPY</cite> flag. In this case
nditer must be used as a context manager or the nditer.close
method must be called before using the result. The temporary
data will be written back to the original data when the <cite>__exit__</cite>
function is called but not before:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i4&#39;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nditer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[],</span>
<span class="gp">... </span>       <span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span> <span class="s1">&#39;updateifcopy&#39;</span><span class="p">]],</span>
<span class="gp">... </span>       <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">op_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">)])</span> <span class="k">as</span> <span class="n">i</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>   <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">... </span>   <span class="c1"># a still unchanged here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">x</span>
<span class="go">array([-1, -2, -3]), array([-1, -2, -3])</span>
</pre></div>
</div>
<p>It is important to note that once the iterator is exited, dangling
references (like <cite>x</cite> in the example) may or may not share data with
the original data <cite>a</cite>. If writeback semantics were active, i.e. if
<cite>x.base.flags.writebackifcopy</cite> is <cite>True</cite>, then exiting the iterator
will sever the connection between <cite>x</cite> and <cite>a</cite>, writing to <cite>x</cite> will
no longer write to <cite>a</cite>. If writeback semantics are not active, then
<cite>x.data</cite> will still point at some part of <cite>a.data</cite>, and writing to
one will affect the other.</p>
<dl class="method">
<dt id="numpy.nditer.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve all writeback semantics in writeable operands.</p>
<p><span class="xref std std-ref">nditer-context-manager</span></p>
</dd></dl>

<dl class="method">
<dt id="numpy.nditer.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a copy of the iterator in its current state.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">(array(0), array(1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it2</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it2</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">(array(1), array(2))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.nditer.debug_print">
<code class="descname">debug_print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.debug_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the current state of the <cite>nditer</cite> instance and debug info to stdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.dtypes">
<code class="descname">dtypes</code><a class="headerlink" href="#numpy.nditer.dtypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.nditer.enable_external_loop">
<code class="descname">enable_external_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.enable_external_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>When the “external_loop” was not used during construction, but
is desired, this modifies the iterator to behave as if the flag
was specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.finished">
<code class="descname">finished</code><a class="headerlink" href="#numpy.nditer.finished" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.has_delayed_bufalloc">
<code class="descname">has_delayed_bufalloc</code><a class="headerlink" href="#numpy.nditer.has_delayed_bufalloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.has_index">
<code class="descname">has_index</code><a class="headerlink" href="#numpy.nditer.has_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.has_multi_index">
<code class="descname">has_multi_index</code><a class="headerlink" href="#numpy.nditer.has_multi_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.index">
<code class="descname">index</code><a class="headerlink" href="#numpy.nditer.index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.iterationneedsapi">
<code class="descname">iterationneedsapi</code><a class="headerlink" href="#numpy.nditer.iterationneedsapi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.iterindex">
<code class="descname">iterindex</code><a class="headerlink" href="#numpy.nditer.iterindex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.nditer.iternext">
<code class="descname">iternext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.iternext" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether iterations are left, and perform a single internal iteration
without returning the result.  Used in the C-style pattern do-while
pattern.  For an example, see <cite>nditer</cite>.</p>
<dl class="docutils">
<dt>iternext <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether or not there are iterations left.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.iterrange">
<code class="descname">iterrange</code><a class="headerlink" href="#numpy.nditer.iterrange" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.itersize">
<code class="descname">itersize</code><a class="headerlink" href="#numpy.nditer.itersize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.itviews">
<code class="descname">itviews</code><a class="headerlink" href="#numpy.nditer.itviews" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.multi_index">
<code class="descname">multi_index</code><a class="headerlink" href="#numpy.nditer.multi_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#numpy.nditer.ndim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.nop">
<code class="descname">nop</code><a class="headerlink" href="#numpy.nditer.nop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.operands">
<code class="descname">operands</code><a class="headerlink" href="#numpy.nditer.operands" title="Permalink to this definition">¶</a></dt>
<dd><p>operands[<cite>Slice</cite>]</p>
<p>The array(s) to be iterated over. Valid only before the iterator is closed.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.nditer.remove_axis">
<code class="descname">remove_axis</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.remove_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes axis <cite>i</cite> from the iterator. Requires that the flag “multi_index”
be enabled.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.nditer.remove_multi_index">
<code class="descname">remove_multi_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.remove_multi_index" title="Permalink to this definition">¶</a></dt>
<dd><p>When the “multi_index” flag was specified, this removes it, allowing
the internal iteration structure to be optimized further.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.nditer.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nditer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the iterator to its initial state.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.shape">
<code class="descname">shape</code><a class="headerlink" href="#numpy.nditer.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.nditer.value">
<code class="descname">value</code><a class="headerlink" href="#numpy.nditer.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.nested_iters">
<code class="descclassname">numpy.</code><code class="descname">nested_iters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nested_iters" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nditers for use in nested loops</p>
<p>Create a tuple of <cite>nditer</cite> objects which iterate in nested loops over
different axes of the op argument. The first iterator is used in the
outermost loop, the last in the innermost loop. Advancing one will change
the subsequent iterators to point at its new element.</p>
<dl class="docutils">
<dt>op <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or sequence of array_like</span></dt>
<dd>The array(s) to iterate over.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">list of list of int</span></dt>
<dd>Each item is used as an “op_axes” argument to an nditer</dd>
<dt>flags, op_flags, op_dtypes, order, casting, buffersize (optional)</dt>
<dd>See <cite>nditer</cite> parameters of the same name</dd>
</dl>
<dl class="docutils">
<dt>iters <span class="classifier-delimiter">:</span> <span class="classifier">tuple of nditer</span></dt>
<dd>An nditer for each item in <cite>axes</cite>, outermost first</dd>
</dl>
<p>nditer</p>
<p>Basic usage. Note how y is the “flattened” version of
[a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
the first iter’s axes as [1]</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nested_iters</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;multi_index&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
<span class="gp">... </span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">multi_index</span><span class="p">)</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
<span class="gp">... </span>         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>(0,)</dt>
<dd>(0, 0) 0
(0, 1) 1
(1, 0) 6
(1, 1) 7</dd>
<dt>(1,)</dt>
<dd>(0, 0) 2
(0, 1) 3
(1, 0) 8
(1, 1) 9</dd>
<dt>(2,)</dt>
<dd>(0, 0) 4
(0, 1) 5
(1, 0) 10
(1, 1) 11</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="numpy.ufunc">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">ufunc</code><a class="headerlink" href="#numpy.ufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Functions that operate element by element on whole arrays.</p>
<p>To see the documentation for a specific ufunc, use <cite>info</cite>.  For
example, <code class="docutils literal"><span class="pre">np.info(np.sin)</span></code>.  Because ufuncs are written in C
(for speed) and linked into Python with NumPy’s ufunc facility,
Python’s help() function finds this page whenever help() is called
on a ufunc.</p>
<p>A detailed explanation of ufuncs can be found in the docs for <span class="xref std std-ref">ufuncs</span>.</p>
<p>op(<a href="#id3"><span class="problematic" id="id4">*</span></a>x[, out], where=True, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs)
Apply <cite>op</cite> to the arguments <cite>*x</cite> elementwise, broadcasting the arguments.</p>
<p>The broadcasting rules are:</p>
<ul class="simple">
<li>Dimensions of length 1 may be prepended to either array.</li>
<li>Arrays may be repeated along dimensions of length 1.</li>
</ul>
<dl class="docutils">
<dt><a href="#id7"><span class="problematic" id="id8">*</span></a>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt>
<dd>Alternate array object(s) in which to put the result; if provided, it
must have a shape that the inputs broadcast to. A tuple of arrays
(possible only as a keyword argument) must have length equal to the
number of outputs; use <cite>None</cite> for uninitialized outputs to be
allocated by the ufunc.</dd>
<dt>where <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Values of True indicate to calculate the ufunc at that position, values
of False indicate to leave the value in the output alone.  Note that if
an uninitialized return array is created via the default <code class="docutils literal"><span class="pre">out=None</span></code>,
then the elements where the values are False will remain uninitialized.</dd>
<dt><a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs</dt>
<dd>For other keyword-only arguments, see the <span class="xref std std-ref">ufunc docs</span>.</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or tuple of ndarray</span></dt>
<dd><cite>r</cite> will have the shape that the arrays in <cite>x</cite> broadcast to; if <cite>out</cite> is
provided, it will be returned. If not, <cite>r</cite> will be allocated and
may contain uninitialized values. If the function has more than one
output, then the result will be a tuple of arrays.</dd>
</dl>
<dl class="method">
<dt id="numpy.ufunc.accumulate">
<code class="descname">accumulate</code><span class="sig-paren">(</span><em>array</em>, <em>axis=0</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.accumulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulate the result of applying the operator to all elements.</p>
<p>For a one-dimensional array, accumulate produces results equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">identity</span>        <span class="c1"># op = the ufunc being applied to A&#39;s  elements</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
<span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>For example, add.accumulate() is equivalent to np.cumsum().</p>
<p>For a multi-dimensional array, accumulate is applied along only one
axis (axis zero by default; see Examples below) so repeated use is
necessary if one wants to accumulate over multiple axes.</p>
<dl class="docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array to act on.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to apply the accumulation; default is zero.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type code, optional</span></dt>
<dd>The data-type used to represent the intermediate results. Defaults
to the data-type of the output array if such is provided, or the
the data-type of the input array if no output array is provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt>
<dd><p class="first">A location into which the result is stored. If not provided or <cite>None</cite>,
a freshly-allocated array is returned. For consistency with
<span class="xref std std-ref">ufunc.__call__</span>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The accumulated values. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to
<cite>out</cite>.</dd>
</dl>
<p>1-D array examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">array([ 2,  5, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">accumulate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">array([ 2,  6, 30])</span>
</pre></div>
</div>
<p>2-D array examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  1.]])</span>
</pre></div>
</div>
<p>Accumulate along axis 0 (rows), down columns:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="c1"># no axis specified = axis zero</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 1.,  1.]])</span>
</pre></div>
</div>
<p>Accumulate along axis 1 (columns), through rows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ufunc.at">
<code class="descname">at</code><span class="sig-paren">(</span><em>a</em>, <em>indices</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs unbuffered in place operation on operand ‘a’ for elements
specified by ‘indices’. For addition ufunc, this method is equivalent to
<code class="docutils literal"><span class="pre">a[indices]</span> <span class="pre">+=</span> <span class="pre">b</span></code>, except that results are accumulated for elements that
are indexed more than once. For example, <code class="docutils literal"><span class="pre">a[[0,0]]</span> <span class="pre">+=</span> <span class="pre">1</span></code> will only
increment the first element once because of buffering, whereas
<code class="docutils literal"><span class="pre">add.at(a,</span> <span class="pre">[0,0],</span> <span class="pre">1)</span></code> will increment the first element twice.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array to perform in place operation on.</dd>
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array_like or tuple</span></dt>
<dd>Array like index object or slice object for indexing into first
operand. If first operand has multiple dimensions, indices can be a
tuple of array like index objects or slice objects.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Second operand for ufuncs requiring two operands. Operand must be
broadcastable over first operand after indexing or slicing.</dd>
</dl>
<p>Set items 0 and 1 to their negative values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([-1, -2, 3, 4])</span>
</pre></div>
</div>
<p>Increment items 0 and 1, and increment item 2 twice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([2, 3, 5, 4])</span>
</pre></div>
</div>
<p>Add items 0 and 1 in first array to second array,
and store results in first array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([2, 4, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.identity">
<code class="descname">identity</code><a class="headerlink" href="#numpy.ufunc.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>The identity value.</p>
<p>Data attribute containing the identity element for the ufunc, if it has one.
If it does not, the attribute value is None.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">identity</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">identity</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">identity</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.nargs">
<code class="descname">nargs</code><a class="headerlink" href="#numpy.ufunc.nargs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of arguments.</p>
<p>Data attribute containing the number of arguments the ufunc takes, including
optional ones.</p>
<p>Typically this value will be one more than what you might expect because all
ufuncs take  the optional “out” argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nargs</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.nin">
<code class="descname">nin</code><a class="headerlink" href="#numpy.ufunc.nin" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of inputs.</p>
<p>Data attribute containing the number of arguments the ufunc treats as input.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nin</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nin</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.nout">
<code class="descname">nout</code><a class="headerlink" href="#numpy.ufunc.nout" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of outputs.</p>
<p>Data attribute containing the number of arguments the ufunc treats as output.</p>
<p>Since all ufuncs can take output arguments, this will always be (at least) 1.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">nout</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.ntypes">
<code class="descname">ntypes</code><a class="headerlink" href="#numpy.ufunc.ntypes" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of types.</p>
<p>The number of numerical NumPy types - of which there are 18 total - on which
the ufunc can operate.</p>
<p>numpy.ufunc.types</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="o">.</span><span class="n">ntypes</span>
<span class="go">14</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ufunc.outer">
<code class="descname">outer</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the ufunc <cite>op</cite> to all pairs (a, b) with a in <cite>A</cite> and b in <cite>B</cite>.</p>
<p>Let <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">A.ndim</span></code>, <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">B.ndim</span></code>. Then the result, <cite>C</cite>, of
<code class="docutils literal"><span class="pre">op.outer(A,</span> <span class="pre">B)</span></code> is an array of dimension M + N such that:</p>
<div class="math">
\[C[i_0, ..., i_{M-1}, j_0, ..., j_{N-1}] =
op(A[i_0, ..., i_{M-1}], B[j_0, ..., j_{N-1}])\]</div>
<p>For <cite>A</cite> and <cite>B</cite> one-dimensional, this is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)):</span>
        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="c1"># op = ufunc in question</span>
</pre></div>
</div>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>First array</dd>
<dt>B <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Second array</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>Arguments to pass on to the ufunc. Typically <cite>dtype</cite> or <cite>out</cite>.</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array</dd>
</dl>
<p>numpy.outer</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([[ 4,  5,  6],</span>
<span class="go">       [ 8, 10, 12],</span>
<span class="go">       [12, 15, 18]])</span>
</pre></div>
</div>
<p>A multi-dimensional example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">;</span> <span class="n">C</span>
<span class="go">(2, 3, 1, 4)</span>
<span class="go">array([[[[ 1,  2,  3,  4]],</span>
<span class="go">        [[ 2,  4,  6,  8]],</span>
<span class="go">        [[ 3,  6,  9, 12]]],</span>
<span class="go">       [[[ 4,  8, 12, 16]],</span>
<span class="go">        [[ 5, 10, 15, 20]],</span>
<span class="go">        [[ 6, 12, 18, 24]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ufunc.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><em>a</em>, <em>axis=0</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=False</em>, <em>initial</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces <cite>a</cite>’s dimension by one, by applying ufunc along one axis.</p>
<p>Let <span class="math">\(a.shape = (N_0, ..., N_i, ..., N_{M-1})\)</span>.  Then
<span class="math">\(ufunc.reduce(a, axis=i)[k_0, ..,k_{i-1}, k_{i+1}, .., k_{M-1}]\)</span> =
the result of iterating <cite>j</cite> over <span class="math">\(range(N_i)\)</span>, cumulatively applying
ufunc to each <span class="math">\(a[k_0, ..,k_{i-1}, j, k_{i+1}, .., k_{M-1}]\)</span>.
For a one-dimensional array, reduce produces results equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">identity</span> <span class="c1"># op = ufunc</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>For example, add.reduce() is equivalent to sum().</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array to act on.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a reduction is performed.
The default (<cite>axis</cite> = 0) is perform a reduction over the first
dimension of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p>If this is <cite>None</cite>, a reduction is performed over all the axes.
If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
<p class="last">For operations which are either not commutative or not associative,
doing a reduction over multiple axes is not well-defined. The
ufuncs do not currently raise an exception in this case, but will
likely do so in the future.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type code, optional</span></dt>
<dd>The type used to represent the intermediate results. Defaults
to the data-type of the output array if this is provided, or
the data-type of the input array if no output array is provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt>
<dd><p class="first">A location into which the result is stored. If not provided or <cite>None</cite>,
a freshly-allocated array is returned. For consistency with
<span class="xref std std-ref">ufunc.__call__</span>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>arr</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The value with which to start the reduction.
If the ufunc has no identity or the dtype is object, this defaults
to None - otherwise it defaults to ufunc.identity.
If <code class="docutils literal"><span class="pre">None</span></code> is given, the first element of the reduction is used,
and an error is thrown if the reduction is empty.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The reduced array. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to it.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">30</span>
</pre></div>
</div>
<p>A multi-dimensional array example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 4,  6],</span>
<span class="go">       [ 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># confirm: default axis value is 0</span>
<span class="go">array([[ 4,  6],</span>
<span class="go">       [ 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 2,  4],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 1,  5],</span>
<span class="go">       [ 9, 13]])</span>
</pre></div>
</div>
<p>You can use the <code class="docutils literal"><span class="pre">initial</span></code> keyword argument to initialize the reduction with a
different value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">initializer</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">array([14., 14.])</span>
</pre></div>
</div>
<p>Allows reductions of empty arrays where they would normally fail, i.e.
for ufuncs without an identity.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">([],</span> <span class="n">initial</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">zero-size array to reduction operation minimum which has no identity</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.ufunc.reduceat">
<code class="descname">reduceat</code><span class="sig-paren">(</span><em>a</em>, <em>indices</em>, <em>axis=0</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ufunc.reduceat" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a (local) reduce with specified slices over a single axis.</p>
<p>For i in <code class="docutils literal"><span class="pre">range(len(indices))</span></code>, <cite>reduceat</cite> computes
<code class="docutils literal"><span class="pre">ufunc.reduce(a[indices[i]:indices[i+1]])</span></code>, which becomes the i-th
generalized “row” parallel to <cite>axis</cite> in the final result (i.e., in a
2-D array, for example, if <cite>axis = 0</cite>, it becomes the i-th row, but if
<cite>axis = 1</cite>, it becomes the i-th column).  There are three exceptions to this:</p>
<ul class="simple">
<li>when <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">len(indices)</span> <span class="pre">-</span> <span class="pre">1</span></code> (so for the last index),
<code class="docutils literal"><span class="pre">indices[i+1]</span> <span class="pre">=</span> <span class="pre">a.shape[axis]</span></code>.</li>
<li>if <code class="docutils literal"><span class="pre">indices[i]</span> <span class="pre">&gt;=</span> <span class="pre">indices[i</span> <span class="pre">+</span> <span class="pre">1]</span></code>, the i-th generalized “row” is
simply <code class="docutils literal"><span class="pre">a[indices[i]]</span></code>.</li>
<li>if <code class="docutils literal"><span class="pre">indices[i]</span> <span class="pre">&gt;=</span> <span class="pre">len(a)</span></code> or <code class="docutils literal"><span class="pre">indices[i]</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, an error is raised.</li>
</ul>
<p>The shape of the output depends on the size of <cite>indices</cite>, and may be
larger than <cite>a</cite> (this happens if <code class="docutils literal"><span class="pre">len(indices)</span> <span class="pre">&gt;</span> <span class="pre">a.shape[axis]</span></code>).</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array to act on.</dd>
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Paired indices, comma separated (not colon), specifying slices to
reduce.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to apply the reduceat.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type code, optional</span></dt>
<dd>The type used to represent the intermediate results. Defaults
to the data type of the output array if this is provided, or
the data type of the input array if no output array is provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt>
<dd><p class="first">A location into which the result is stored. If not provided or <cite>None</cite>,
a freshly-allocated array is returned. For consistency with
<span class="xref std std-ref">ufunc.__call__</span>, if given as a keyword, this may be wrapped in a
1-element tuple.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.13.0: </span>Tuples are allowed for keyword argument.</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The reduced values. If <cite>out</cite> was supplied, <cite>r</cite> is a reference to
<cite>out</cite>.</dd>
</dl>
<p>A descriptive example:</p>
<p>If <cite>a</cite> is 1-D, the function <cite>ufunc.accumulate(a)</cite> is the same as
<code class="docutils literal"><span class="pre">ufunc.reduceat(a,</span> <span class="pre">indices)[::2]</span></code> where <cite>indices</cite> is
<code class="docutils literal"><span class="pre">range(len(array)</span> <span class="pre">-</span> <span class="pre">1)</span></code> with a zero placed
in every other element:
<code class="docutils literal"><span class="pre">indices</span> <span class="pre">=</span> <span class="pre">zeros(2</span> <span class="pre">*</span> <span class="pre">len(a)</span> <span class="pre">-</span> <span class="pre">1)</span></code>, <code class="docutils literal"><span class="pre">indices[1::2]</span> <span class="pre">=</span> <span class="pre">range(1,</span> <span class="pre">len(a))</span></code>.</p>
<p>Don’t be fooled by this attribute’s name: <cite>reduceat(a)</cite> is not
necessarily smaller than <cite>a</cite>.</p>
<p>To take the running sum of four successive values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">])[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([ 6, 10, 14, 18])</span>
</pre></div>
</div>
<p>A 2-D example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[  0.,   1.,   2.,   3.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.],</span>
<span class="go">       [ 12.,  13.,  14.,  15.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># reduce such that the result has the following five rows:</span>
<span class="c1"># [row1 + row2 + row3]</span>
<span class="c1"># [row4]</span>
<span class="c1"># [row2]</span>
<span class="c1"># [row3]</span>
<span class="c1"># [row1 + row2 + row3 + row4]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([[ 12.,  15.,  18.,  21.],</span>
<span class="go">       [ 12.,  13.,  14.,  15.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.],</span>
<span class="go">       [ 24.,  28.,  32.,  36.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># reduce such that result has the following two columns:</span>
<span class="c1"># [col1 * col2 * col3, col4]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[    0.,     3.],</span>
<span class="go">       [  120.,     7.],</span>
<span class="go">       [  720.,    11.],</span>
<span class="go">       [ 2184.,    15.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.signature">
<code class="descname">signature</code><a class="headerlink" href="#numpy.ufunc.signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of the core elements a generalized ufunc operates on.</p>
<p>The signature determines how the dimensions of each input/output array
are split into core and loop dimensions:</p>
<ol class="arabic simple">
<li>Each dimension in the signature is matched to a dimension of the
corresponding passed-in array, starting from the end of the shape tuple.</li>
<li>Core dimensions assigned to the same label in the signature must have
exactly matching sizes, no broadcasting is performed.</li>
<li>The core dimensions are removed from all inputs and the remaining
dimensions are broadcast together, defining the loop dimensions.</li>
</ol>
<p>Generalized ufuncs are used internally in many linalg functions, and in
the testing suite; the examples below are taken from these.
For ufuncs that operate on scalars, the signature is <cite>None</cite>, which is
equivalent to ‘()’ for every argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">umath_tests</span><span class="o">.</span><span class="n">matrix_multiply</span><span class="o">.</span><span class="n">signature</span>
<span class="go">&#39;(m,n),(n,p)-&gt;(m,p)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">_umath_linalg</span><span class="o">.</span><span class="n">det</span><span class="o">.</span><span class="n">signature</span>
<span class="go">&#39;(m,m)-&gt;()&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">signature</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True  # equivalent to &#39;(),()-&gt;()&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ufunc.types">
<code class="descname">types</code><a class="headerlink" href="#numpy.ufunc.types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with types grouped input-&gt;output.</p>
<p>Data attribute listing the data-type “Domain-Range” groupings the ufunc can
deliver. The data-types are given using the character codes.</p>
<p>numpy.ufunc.ntypes</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;??-&gt;?&#39;, &#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;,</span>
<span class="go">&#39;LL-&gt;L&#39;, &#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;,</span>
<span class="go">&#39;GG-&gt;G&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;??-&gt;?&#39;, &#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;,</span>
<span class="go">&#39;LL-&gt;L&#39;, &#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;,</span>
<span class="go">&#39;GG-&gt;G&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;, &#39;LL-&gt;L&#39;,</span>
<span class="go">&#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;FF-&gt;F&#39;, &#39;DD-&gt;D&#39;, &#39;GG-&gt;G&#39;,</span>
<span class="go">&#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;f-&gt;f&#39;, &#39;d-&gt;d&#39;, &#39;g-&gt;g&#39;, &#39;F-&gt;F&#39;, &#39;D-&gt;D&#39;, &#39;G-&gt;G&#39;, &#39;O-&gt;O&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="o">.</span><span class="n">types</span>
<span class="go">[&#39;bb-&gt;b&#39;, &#39;BB-&gt;B&#39;, &#39;hh-&gt;h&#39;, &#39;HH-&gt;H&#39;, &#39;ii-&gt;i&#39;, &#39;II-&gt;I&#39;, &#39;ll-&gt;l&#39;, &#39;LL-&gt;L&#39;,</span>
<span class="go">&#39;qq-&gt;q&#39;, &#39;QQ-&gt;Q&#39;, &#39;ff-&gt;f&#39;, &#39;dd-&gt;d&#39;, &#39;gg-&gt;g&#39;, &#39;OO-&gt;O&#39;]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.arange">
<code class="descclassname">numpy.</code><code class="descname">arange</code><span class="sig-paren">(</span><span class="optional">[</span><em>start</em>, <span class="optional">]</span><em>stop</em>, <span class="optional">[</span><em>step</em>, <span class="optional">]</span><em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <code class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(in other words, the interval including <cite>start</cite> but excluding <cite>stop</cite>).
For integer arguments the function is equivalent to the Python built-in
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">range</a> function,
but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <code class="docutils literal"><span class="pre">linspace</span></code> for these cases.</p>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">number, optional</span></dt>
<dd>Start of interval.  The interval includes this value.  The default
start value is 0.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>End of interval.  The interval does not include this value, except
in some cases where <cite>step</cite> is not an integer and floating point
round-off affects the length of <cite>out</cite>.</dd>
<dt>step <span class="classifier-delimiter">:</span> <span class="classifier">number, optional</span></dt>
<dd>Spacing between values.  For any output <cite>out</cite>, this is the distance
between two adjacent values, <code class="docutils literal"><span class="pre">out[i+1]</span> <span class="pre">-</span> <span class="pre">out[i]</span></code>.  The default
step size is 1.  If <cite>step</cite> is specified as a position argument,
<cite>start</cite> must also be given.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</dd>
</dl>
<dl class="docutils">
<dt>arange <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">Array of evenly spaced values.</p>
<p class="last">For floating point arguments, the length of the result is
<code class="docutils literal"><span class="pre">ceil((stop</span> <span class="pre">-</span> <span class="pre">start)/step)</span></code>.  Because of floating point overflow,
this rule may result in the last element of <cite>out</cite> being greater
than <cite>stop</cite>.</p>
</dd>
</dl>
<p>linspace : Evenly spaced numbers with careful handling of endpoints.
ogrid: Arrays of evenly spaced numbers in N-dimensions.
mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="go">array([3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([3, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array">
<code class="descclassname">numpy.</code><code class="descname">array</code><span class="sig-paren">(</span><em>object</em>, <em>dtype=None</em>, <em>copy=True</em>, <em>order='K'</em>, <em>subok=False</em>, <em>ndmin=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array.</p>
<dl class="docutils">
<dt>object <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An array, any object exposing the array interface, an object whose
__array__ method returns an array, or any (nested) sequence.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The desired data-type for the array.  If not given, then the type will
be determined as the minimum type required to hold the objects in the
sequence.  This argument can only be used to ‘upcast’ the array.  For
downcasting, use the .astype(t) method.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If true (default), then the object is copied.  Otherwise, a copy will
only be made if __array__ returns a copy, if obj is a nested sequence,
or if a copy is needed to satisfy any of the other requirements
(<cite>dtype</cite>, <cite>order</cite>, etc.).</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘K’, ‘A’, ‘C’, ‘F’}, optional</span></dt>
<dd><p class="first">Specify the memory layout of the array. If object is not an array, the
newly created array will be in C order (row major) unless ‘F’ is
specified, in which case it will be in Fortran order (column major).
If object is an array the following holds.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="14%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">order</th>
<th class="head">no copy</th>
<th class="head">copy=True</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘K’</td>
<td>unchanged</td>
<td>F &amp; C order preserved, otherwise most similar order</td>
</tr>
<tr class="row-odd"><td>‘A’</td>
<td>unchanged</td>
<td>F order if input is F and not C, otherwise C order</td>
</tr>
<tr class="row-even"><td>‘C’</td>
<td>C order</td>
<td>C order</td>
</tr>
<tr class="row-odd"><td>‘F’</td>
<td>F order</td>
<td>F order</td>
</tr>
</tbody>
</table>
<p class="last">When <code class="docutils literal"><span class="pre">copy=False</span></code> and a copy is made for other reasons, the result is
the same as if <code class="docutils literal"><span class="pre">copy=True</span></code>, with some exceptions for <cite>A</cite>, see the
Notes section. The default order is ‘K’.</p>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</dd>
<dt>ndmin <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Specifies the minimum number of dimensions that the resulting
array should have.  Ones will be pre-pended to the shape as
needed to meet this requirement.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array object satisfying the specified requirements.</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<p>When order is ‘A’ and <cite>object</cite> is an array in neither ‘C’ nor ‘F’ order,
and a copy is forced by a change in dtype, then the order of the result is
not necessarily ‘C’ as expected. This is likely a bug.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Upcasting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<p>More than one dimension:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Minimum dimensions 2:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 3]])</span>
</pre></div>
</div>
<p>Type provided:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j])</span>
</pre></div>
</div>
<p>Data-type consisting of more than one element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>Creating an array from sub-classes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">),</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.zeros">
<code class="descclassname">numpy.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=float</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>Shape of the new array, e.g., <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">2</span></code>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt>
<dd>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of zeros with the given shape, dtype, and order.</dd>
</dl>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.count_nonzero">
<code class="descclassname">numpy.</code><code class="descname">count_nonzero</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of non-zero values in the array <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>The word “non-zero” is in reference to the Python 2.x
built-in method <code class="docutils literal"><span class="pre">__nonzero__()</span></code> (renamed <code class="docutils literal"><span class="pre">__bool__()</span></code>
in Python 3.x) of Python objects that tests an object’s
“truthfulness”. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in <code class="docutils literal"><span class="pre">a</span></code> (and in
sub-arrays thereof) have their <code class="docutils literal"><span class="pre">__nonzero__()</span></code> or <code class="docutils literal"><span class="pre">__bool__()</span></code>
method evaluated to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array for which to count non-zeros.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple, optional</span></dt>
<dd><p class="first">Axis or tuple of axes along which to count non-zeros.
Default is None, meaning that non-zeros will be counted
along a flattened version of <code class="docutils literal"><span class="pre">a</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int or array of int</span></dt>
<dd>Number of non-zero values in the array along a given axis.
Otherwise, the total number of non-zero values in the array
is returned.</dd>
</dl>
<p>nonzero : Return the coordinates of all the non-zero values.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]])</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.empty">
<code class="descclassname">numpy.</code><code class="descname">empty</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=float</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, without initializing entries.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span></dt>
<dd>Shape of the empty array, e.g., <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">2</span></code>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Desired output data-type for the array, e.g, <cite>numpy.int8</cite>. Default is
<cite>numpy.float64</cite>.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt>
<dd>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of uninitialized (arbitrary) data of the given shape, dtype, and
order.  Object arrays will be initialized to None.</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<p><cite>empty</cite>, unlike <cite>zeros</cite>, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[ -9.74499359e+001,   6.69583040e-309],</span>
<span class="go">       [  2.13182611e-314,   3.06959433e-309]])         #random</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1067949133],</span>
<span class="go">       [  496041986,    19249760]])                     #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.broadcast">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">broadcast</code><a class="headerlink" href="#numpy.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Produce an object that mimics broadcasting.</p>
<dl class="docutils">
<dt>in1, in2, … <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input parameters.</dd>
</dl>
<dl class="docutils">
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">broadcast object</span></dt>
<dd>Broadcast the input parameters against one another, and
return an object that encapsulates the result.
Amongst others, it has <code class="docutils literal"><span class="pre">shape</span></code> and <code class="docutils literal"><span class="pre">nd</span></code> properties, and
may be used as an iterator.</dd>
</dl>
<p>broadcast_arrays
broadcast_to</p>
<p>Manually adding two vectors, using broadcasting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="o">+</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span>
<span class="go">array([[ 5.,  6.,  7.],</span>
<span class="go">       [ 6.,  7.,  8.],</span>
<span class="go">       [ 7.,  8.,  9.]])</span>
</pre></div>
</div>
<p>Compare against built-in broadcasting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">array([[5, 6, 7],</span>
<span class="go">       [6, 7, 8],</span>
<span class="go">       [7, 8, 9]])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.broadcast.index">
<code class="descname">index</code><a class="headerlink" href="#numpy.broadcast.index" title="Permalink to this definition">¶</a></dt>
<dd><p>current index in broadcasted result</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">((1, 4), (1, 5), (1, 6))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.iters">
<code class="descname">iters</code><a class="headerlink" href="#numpy.broadcast.iters" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple of iterators along <code class="docutils literal"><span class="pre">self</span></code>’s “components.”</p>
<p>Returns a tuple of <cite>numpy.flatiter</cite> objects, one for each “component”
of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>numpy.flatiter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">iters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">col</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.nd">
<code class="descname">nd</code><a class="headerlink" href="#numpy.broadcast.nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions of broadcasted result. For code intended for NumPy
1.12.0 and later the more consistent <cite>ndim</cite> is preferred.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">nd</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#numpy.broadcast.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions of broadcasted result. Alias for <cite>nd</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.numiter">
<code class="descname">numiter</code><a class="headerlink" href="#numpy.broadcast.numiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterators possessed by the broadcasted result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">numiter</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.broadcast.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the broadcasted result’s iterator(s).</p>
<p>None</p>
<p>None</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">((1, 4), (2, 4), (3, 4))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">index</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.shape">
<code class="descname">shape</code><a class="headerlink" href="#numpy.broadcast.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of broadcasted result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.broadcast.size">
<code class="descname">size</code><a class="headerlink" href="#numpy.broadcast.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Total size of broadcasted result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">size</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.dtype">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">dtype</code><span class="sig-paren">(</span><em>obj</em>, <em>align=False</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Create a data type object.</p>
<p>A numpy array is homogeneous, and contains elements described by a
dtype object. A dtype object can be constructed from different
combinations of fundamental numeric types.</p>
<dl class="docutils">
<dt>obj</dt>
<dd>Object to be converted to a data type object.</dd>
<dt>align <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Add padding to the fields to match what a C compiler would output
for a similar C-struct. Can be <code class="docutils literal"><span class="pre">True</span></code> only if <cite>obj</cite> is a dictionary
or a comma-separated string. If a struct dtype is being created,
this also sets a sticky alignment flag <code class="docutils literal"><span class="pre">isalignedstruct</span></code>.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Make a new copy of the data-type object. If <code class="docutils literal"><span class="pre">False</span></code>, the result
may just be a reference to a built-in data-type object.</dd>
</dl>
<p>result_type</p>
<p>Using array-scalar type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="go">dtype(&#39;int16&#39;)</span>
</pre></div>
</div>
<p>Structured type, one field name ‘f1’, containing int16:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="go">dtype([(&#39;f1&#39;, &#39;&lt;i2&#39;)])</span>
</pre></div>
</div>
<p>Structured type, one field named ‘f1’, in itself containing a structured
type with one field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])])</span>
<span class="go">dtype([(&#39;f1&#39;, [(&#39;f1&#39;, &#39;&lt;i2&#39;)])])</span>
</pre></div>
</div>
<p>Structured type, two fields: the first field contains an unsigned int, the
second an int32:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)])</span>
<span class="go">dtype([(&#39;f1&#39;, &#39;&lt;u4&#39;), (&#39;f2&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<p>Using array-protocol type strings:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;f8&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;S10&#39;</span><span class="p">)])</span>
<span class="go">dtype([(&#39;a&#39;, &#39;&lt;f8&#39;), (&#39;b&#39;, &#39;|S10&#39;)])</span>
</pre></div>
</div>
<p>Using comma-separated field formats.  The shape is (2,3):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;i4, (2,3)f8&quot;</span><span class="p">)</span>
<span class="go">dtype([(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;f8&#39;, (2, 3))])</span>
</pre></div>
</div>
<p>Using tuples.  <code class="docutils literal"><span class="pre">int</span></code> is a fixed type, 3 the field’s shape.  <code class="docutils literal"><span class="pre">void</span></code>
is a flexible type, here of size 10:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;hello&#39;</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="mi">3</span><span class="p">)),(</span><span class="s1">&#39;world&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">,</span><span class="mi">10</span><span class="p">)])</span>
<span class="go">dtype([(&#39;hello&#39;, &#39;&lt;i4&#39;, 3), (&#39;world&#39;, &#39;|V10&#39;)])</span>
</pre></div>
</div>
<p>Subdivide <code class="docutils literal"><span class="pre">int16</span></code> into 2 <code class="docutils literal"><span class="pre">int8</span></code>’s, called x and y.  0 and 1 are
the offsets in bytes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;y&#39;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span><span class="mi">1</span><span class="p">)}))</span>
<span class="go">dtype((&#39;&lt;i2&#39;, [(&#39;x&#39;, &#39;|i1&#39;), (&#39;y&#39;, &#39;|i1&#39;)]))</span>
</pre></div>
</div>
<p>Using dictionaries.  Two fields named ‘gender’ and ‘age’:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">({</span><span class="s1">&#39;names&#39;</span><span class="p">:[</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">],</span> <span class="s1">&#39;formats&#39;</span><span class="p">:[</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">]})</span>
<span class="go">dtype([(&#39;gender&#39;, &#39;|S1&#39;), (&#39;age&#39;, &#39;|u1&#39;)])</span>
</pre></div>
</div>
<p>Offsets in bytes, here 0 and 25:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">({</span><span class="s1">&#39;surname&#39;</span><span class="p">:(</span><span class="s1">&#39;S25&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;age&#39;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span><span class="mi">25</span><span class="p">)})</span>
<span class="go">dtype([(&#39;surname&#39;, &#39;|S25&#39;), (&#39;age&#39;, &#39;|u1&#39;)])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.dtype.alignment">
<code class="descname">alignment</code><a class="headerlink" href="#numpy.dtype.alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>The required alignment (bytes) of this data-type according to the compiler.</p>
<p>More information is available in the C-API section of the manual.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.base">
<code class="descname">base</code><a class="headerlink" href="#numpy.dtype.base" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.byteorder">
<code class="descname">byteorder</code><a class="headerlink" href="#numpy.dtype.byteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>A character indicating the byte-order of this data-type object.</p>
<p>One of:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>‘=’</td>
<td>native</td>
</tr>
<tr class="row-even"><td>‘&lt;’</td>
<td>little-endian</td>
</tr>
<tr class="row-odd"><td>‘&gt;’</td>
<td>big-endian</td>
</tr>
<tr class="row-even"><td>‘|’</td>
<td>not applicable</td>
</tr>
</tbody>
</table>
<p>All built-in data-type objects have byteorder either ‘=’ or ‘|’.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">byteorder</span>
<span class="go">&#39;=&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># endian is not relevant for 8 bit numbers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;i1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">byteorder</span>
<span class="go">&#39;|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># or ASCII strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">byteorder</span>
<span class="go">&#39;|&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Even if specific code is given, and it is native</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &#39;=&#39; is the byteorder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_is_le</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_code</span> <span class="o">=</span> <span class="n">sys_is_le</span> <span class="ow">and</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">or</span> <span class="s1">&#39;&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swapped_code</span> <span class="o">=</span> <span class="n">sys_is_le</span> <span class="ow">and</span> <span class="s1">&#39;&gt;&#39;</span> <span class="ow">or</span> <span class="s1">&#39;&lt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">native_code</span> <span class="o">+</span> <span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">byteorder</span>
<span class="go">&#39;=&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Swapped code shows up as itself</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">swapped_code</span> <span class="o">+</span> <span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="n">swapped_code</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.char">
<code class="descname">char</code><a class="headerlink" href="#numpy.dtype.char" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique character code for each of the 21 different built-in types.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.descr">
<code class="descname">descr</code><a class="headerlink" href="#numpy.dtype.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>PEP3118 interface description of the data-type.</p>
<p>The format is that required by the ‘descr’ key in the
PEP3118 <cite>__array_interface__</cite> attribute.</p>
<p>Warning: This attribute exists specifically for PEP3118 compliance, and
is not a datatype description compatible with <cite>np.dtype</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.fields">
<code class="descname">fields</code><a class="headerlink" href="#numpy.dtype.fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of named fields defined for this data type, or <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>The dictionary is indexed by keys that are the names of the fields.
Each entry in the dictionary is a tuple fully describing the field:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">offset</span><span class="p">[,</span> <span class="n">title</span><span class="p">])</span>
</pre></div>
</div>
<p>If present, the optional title can be any object (if it is a string
or unicode then it will also be a key in the fields dictionary,
otherwise it’s meta-data). Notice also that the first two elements
of the tuple can be passed directly as arguments to the <code class="docutils literal"><span class="pre">ndarray.getfield</span></code>
and <code class="docutils literal"><span class="pre">ndarray.setfield</span></code> methods.</p>
<p>ndarray.getfield, ndarray.setfield</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
<span class="go">{&#39;grades&#39;: (dtype((&#39;float64&#39;,(2,))), 16), &#39;name&#39;: (dtype(&#39;|S16&#39;), 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.flags">
<code class="descname">flags</code><a class="headerlink" href="#numpy.dtype.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Bit-flags describing how this data type is to be interpreted.</p>
<p>Bit-masks are in <cite>numpy.core.multiarray</cite> as the constants
<cite>ITEM_HASOBJECT</cite>, <cite>LIST_PICKLE</cite>, <cite>ITEM_IS_POINTER</cite>, <cite>NEEDS_INIT</cite>,
<cite>NEEDS_PYAPI</cite>, <cite>USE_GETITEM</cite>, <cite>USE_SETITEM</cite>. A full explanation
of these flags is in C-API documentation; they are largely useful
for user-defined data-types.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.hasobject">
<code class="descname">hasobject</code><a class="headerlink" href="#numpy.dtype.hasobject" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean indicating whether this dtype contains any reference-counted
objects in any fields or sub-dtypes.</p>
<p>Recall that what is actually in the ndarray memory representing
the Python object is the memory address of that object (a pointer).
Special handling may be required, and this attribute is useful for
distinguishing data types that may contain arbitrary Python objects
and data-types that won’t.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.isalignedstruct">
<code class="descname">isalignedstruct</code><a class="headerlink" href="#numpy.dtype.isalignedstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean indicating whether the dtype is a struct which maintains
field alignment. This flag is sticky, so when combining multiple
structs together, it is preserved and produces new dtypes which
are also aligned.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.isbuiltin">
<code class="descname">isbuiltin</code><a class="headerlink" href="#numpy.dtype.isbuiltin" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer indicating how this dtype relates to the built-in dtypes.</p>
<p>Read-only.</p>
<table border="1" class="docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td>if this is a structured array type, with fields</td>
</tr>
<tr class="row-even"><td>1</td>
<td>if this is a dtype compiled into numpy (such as ints, floats etc)</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>if the dtype is for a user-defined numpy type
A user-defined type uses the numpy C-API machinery to extend
numpy to handle a new array type. See
<span class="xref std std-ref">user.user-defined-data-types</span> in the NumPy manual.</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">isbuiltin</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">isbuiltin</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;field1&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">isbuiltin</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.isnative">
<code class="descname">isnative</code><a class="headerlink" href="#numpy.dtype.isnative" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean indicating whether the byte order of this dtype is native
to the platform.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#numpy.dtype.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The element size of this data-type object.</p>
<p>For 18 of the 21 types this number is fixed by the data-type.
For the flexible data-types, this number can be anything.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.kind">
<code class="descname">kind</code><a class="headerlink" href="#numpy.dtype.kind" title="Permalink to this definition">¶</a></dt>
<dd><p>A character code (one of ‘biufcmMOSUV’) identifying the general kind of data.</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>b</td>
<td>boolean</td>
</tr>
<tr class="row-even"><td>i</td>
<td>signed integer</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>unsigned integer</td>
</tr>
<tr class="row-even"><td>f</td>
<td>floating-point</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>complex floating-point</td>
</tr>
<tr class="row-even"><td>m</td>
<td>timedelta</td>
</tr>
<tr class="row-odd"><td>M</td>
<td>datetime</td>
</tr>
<tr class="row-even"><td>O</td>
<td>object</td>
</tr>
<tr class="row-odd"><td>S</td>
<td>(byte-)string</td>
</tr>
<tr class="row-even"><td>U</td>
<td>Unicode</td>
</tr>
<tr class="row-odd"><td>V</td>
<td>void</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#numpy.dtype.metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.name">
<code class="descname">name</code><a class="headerlink" href="#numpy.dtype.name" title="Permalink to this definition">¶</a></dt>
<dd><p>A bit-width name for this data-type.</p>
<p>Un-sized flexible data-type objects do not have this attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.names">
<code class="descname">names</code><a class="headerlink" href="#numpy.dtype.names" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordered list of field names, or <code class="docutils literal"><span class="pre">None</span></code> if there are no fields.</p>
<p>The names are ordered according to increasing byte offset. This can be
used, for example, to walk through all of the named fields in offset order.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;grades&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">names</span>
<span class="go">(&#39;name&#39;, &#39;grades&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#numpy.dtype.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions of the sub-array if this data type describes a
sub-array, and <code class="docutils literal"><span class="pre">0</span></code> otherwise.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.13.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.dtype.newbyteorder">
<code class="descname">newbyteorder</code><span class="sig-paren">(</span><em>new_order='S'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dtype.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new dtype with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<dl class="docutils">
<dt>new_order <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first">Byte order to force; a value from the byte order specifications
below.  The default value (‘S’) results in swapping the current
byte order.  <cite>new_order</cite> codes can be any of:</p>
<ul class="simple">
<li>‘S’ - swap dtype from current to opposite endian</li>
<li>{‘&lt;’, ‘L’} - little endian</li>
<li>{‘&gt;’, ‘B’} - big endian</li>
<li>{‘=’, ‘N’} - native order</li>
<li>{‘|’, ‘I’} - ignore (no change to byte order)</li>
</ul>
<p class="last">The code does a case-insensitive check on the first letter of
<cite>new_order</cite> for these alternatives.  For example, any of ‘&gt;’
or ‘B’ or ‘b’ or ‘brian’ are valid to specify big-endian.</p>
</dd>
</dl>
<dl class="docutils">
<dt>new_dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>New dtype object with the given change to the byte order.</dd>
</dl>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_is_le</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_code</span> <span class="o">=</span> <span class="n">sys_is_le</span> <span class="ow">and</span> <span class="s1">&#39;&lt;&#39;</span> <span class="ow">or</span> <span class="s1">&#39;&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swapped_code</span> <span class="o">=</span> <span class="n">sys_is_le</span> <span class="ow">and</span> <span class="s1">&#39;&gt;&#39;</span> <span class="ow">or</span> <span class="s1">&#39;&lt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">native_code</span><span class="o">+</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swapped_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">swapped_code</span><span class="o">+</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">swapped_dt</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span> <span class="o">==</span> <span class="n">swapped_dt</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span> <span class="o">==</span> <span class="n">swapped_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span> <span class="o">==</span> <span class="n">swapped_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span> <span class="o">==</span> <span class="n">swapped_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">native_dt</span> <span class="o">==</span> <span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;&lt;i2&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;&lt;i2&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;&gt;i2&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;&gt;i2&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">native_dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.num">
<code class="descname">num</code><a class="headerlink" href="#numpy.dtype.num" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique number for each of the 21 different built-in types.</p>
<p>These are roughly ordered from least-to-most precision.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.shape">
<code class="descname">shape</code><a class="headerlink" href="#numpy.dtype.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape tuple of the sub-array if this data type describes a sub-array,
and <code class="docutils literal"><span class="pre">()</span></code> otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.str">
<code class="descname">str</code><a class="headerlink" href="#numpy.dtype.str" title="Permalink to this definition">¶</a></dt>
<dd><p>The array-protocol typestring of this data-type object.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.subdtype">
<code class="descname">subdtype</code><a class="headerlink" href="#numpy.dtype.subdtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple <code class="docutils literal"><span class="pre">(item_dtype,</span> <span class="pre">shape)</span></code> if this <cite>dtype</cite> describes a sub-array, and
None otherwise.</p>
<p>The <em>shape</em> is the fixed shape of the sub-array described by this
data type, and <em>item_dtype</em> the data type of the array.</p>
<p>If a field whose dtype object has this attribute is retrieved,
then the extra dimensions implied by <em>shape</em> are tacked on to
the end of the retrieved array.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.dtype.type">
<code class="descname">type</code><a class="headerlink" href="#numpy.dtype.type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type object used to instantiate a scalar of this data-type.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.fromstring">
<code class="descclassname">numpy.</code><code class="descname">fromstring</code><span class="sig-paren">(</span><em>string</em>, <em>dtype=float</em>, <em>count=-1</em>, <em>sep=''</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>A new 1-D array initialized from text data in a string.</p>
<dl class="docutils">
<dt>string <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A string containing the data.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The data type of the array; default: float.  For binary input data,
the data must be in exactly this format.</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Read this number of <cite>dtype</cite> elements from the data.  If this is
negative (the default), the count will be determined from the
length of the data.</dd>
<dt>sep <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">The string separating numbers in the data; extra whitespace between
elements is also ignored.</p>
<div class="last deprecated">
<p><span class="versionmodified">Deprecated since version 1.14: </span>If this argument is not provided, <cite>fromstring</cite> falls back on the
behaviour of <cite>frombuffer</cite> after encoding unicode string inputs as
either utf-8 (python 3), or the default encoding (python 2).</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The constructed array.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the string is not the correct size to satisfy the requested
<cite>dtype</cite> and <cite>count</cite>.</dd>
</dl>
<p>frombuffer, fromfile, fromiter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;1 2&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;1, 2&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fromfile">
<code class="descclassname">numpy.</code><code class="descname">fromfile</code><span class="sig-paren">(</span><em>file</em>, <em>dtype=float</em>, <em>count=-1</em>, <em>sep=''</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from data in a text or binary file.</p>
<p>A highly efficient way of reading binary data with a known data-type,
as well as parsing simply formatted text files.  Data written using the
<cite>tofile</cite> method can be read using this function.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">file or str</span></dt>
<dd>Open file object or filename.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>Data type of the returned array.
For binary files, it is used to determine the size and byte-order
of the items in the file.</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of items to read. <code class="docutils literal"><span class="pre">-1</span></code> means all items (i.e., the complete
file).</dd>
<dt>sep <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Separator between items if file is a text file.
Empty (“”) separator means the file should be treated as binary.
Spaces (” “) in the separator match zero or more whitespace characters.
A separator consisting only of spaces must match at least one
whitespace.</dd>
</dl>
<p>load, save
ndarray.tofile
loadtxt : More flexible way of loading data from a text file.</p>
<p>Do not rely on the combination of <cite>tofile</cite> and <cite>fromfile</cite> for
data storage, as the binary files generated are are not platform
independent.  In particular, no byte-order or data-type information is
saved.  Data can be stored in the platform independent <code class="docutils literal"><span class="pre">.npy</span></code> format
using <cite>save</cite> and <cite>load</cite> instead.</p>
<p>Construct an ndarray:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;sec&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]),</span>
<span class="gp">... </span>               <span class="p">(</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;temp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">98.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i4&#39;), (&#39;sec&#39;, &#39;&lt;i4&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p>Save the raw data to disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">tmpnam</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the raw data from disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i4&#39;), (&#39;sec&#39;, &#39;&lt;i4&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
<p>The recommended way to store and load data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
<span class="go">array([((10, 0), 98.25)],</span>
<span class="go">      dtype=[(&#39;time&#39;, [(&#39;min&#39;, &#39;&lt;i4&#39;), (&#39;sec&#39;, &#39;&lt;i4&#39;)]), (&#39;temp&#39;, &#39;&lt;f8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.frombuffer">
<code class="descclassname">numpy.</code><code class="descname">frombuffer</code><span class="sig-paren">(</span><em>buffer</em>, <em>dtype=float</em>, <em>count=-1</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.frombuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a buffer as a 1-dimensional array.</p>
<dl class="docutils">
<dt>buffer <span class="classifier-delimiter">:</span> <span class="classifier">buffer_like</span></dt>
<dd>An object that exposes the buffer interface.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Data-type of the returned array; default: float.</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of items to read. <code class="docutils literal"><span class="pre">-1</span></code> means all data in the buffer.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Start reading the buffer from this offset (in bytes); default: 0.</dd>
</dl>
<p>If the buffer has data that is not in machine byte-order, this should
be specified as part of the data-type, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>The data of the resulting array will not be byteswapped, but will be
interpreted correctly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">array([&#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;],</span>
<span class="go">      dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([1, 2], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03\x04\x05</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([1, 2, 3], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.int_asbuffer">
<code class="descclassname">numpy.</code><code class="descname">int_asbuffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.int_asbuffer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="numpy.where">
<code class="descclassname">numpy.</code><code class="descname">where</code><span class="sig-paren">(</span><em>condition</em><span class="optional">[</span>, <em>x</em>, <em>y</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Return elements, either from <cite>x</cite> or <cite>y</cite>, depending on <cite>condition</cite>.</p>
<p>If only <cite>condition</cite> is given, return <code class="docutils literal"><span class="pre">condition.nonzero()</span></code>.</p>
<dl class="docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="classifier">array_like, bool</span></dt>
<dd>When True, yield <cite>x</cite>, otherwise yield <cite>y</cite>.</dd>
<dt>x, y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Values from which to choose. <cite>x</cite>, <cite>y</cite> and <cite>condition</cite> need to be
broadcastable to some shape.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or tuple of ndarrays</span></dt>
<dd><p class="first">If both <cite>x</cite> and <cite>y</cite> are specified, the output array contains
elements of <cite>x</cite> where <cite>condition</cite> is True, and elements from
<cite>y</cite> elsewhere.</p>
<p class="last">If only <cite>condition</cite> is given, return the tuple
<code class="docutils literal"><span class="pre">condition.nonzero()</span></code>, the indices where <cite>condition</cite> is True.</p>
</dd>
</dl>
<p>nonzero, choose</p>
<p>If <cite>x</cite> and <cite>y</cite> are given and input arrays are 1-D, <cite>where</cite> is
equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">xv</span> <span class="k">if</span> <span class="n">c</span> <span class="k">else</span> <span class="n">yv</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">yv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]],</span>
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span>         <span class="p">[[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="go">array([[1, 8],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="go">(array([0, 1]), array([1, 0]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">)</span>
<span class="go">(array([2, 2, 2]), array([0, 1, 2]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">3.0</span> <span class="p">)]</span>               <span class="c1"># Note: result is 1D.</span>
<span class="go">array([ 4.,  5.,  6.,  7.,  8.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>               <span class="c1"># Note: broadcasting.</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4., -1.],</span>
<span class="go">       [-1., -1., -1.]])</span>
</pre></div>
</div>
<p>Find the indices of elements of <cite>x</cite> that are in <cite>goodvalues</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">goodvalues</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">goodvalues</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ix</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True, False],</span>
<span class="go">       [False,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
<span class="go">(array([1, 1, 2]), array([0, 1, 1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.argwhere">
<code class="descclassname">numpy.</code><code class="descname">argwhere</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argwhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of array elements that are non-zero, grouped by element.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Indices of elements that are non-zero. Indices are grouped by element.</dd>
</dl>
<p>where, nonzero</p>
<p><code class="docutils literal"><span class="pre">np.argwhere(a)</span></code> is the same as <code class="docutils literal"><span class="pre">np.transpose(np.nonzero(a))</span></code>.</p>
<p>The output of <code class="docutils literal"><span class="pre">argwhere</span></code> is not suitable for indexing arrays.
For this purpose use <code class="docutils literal"><span class="pre">nonzero(a)</span></code> instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.copyto">
<code class="descclassname">numpy.</code><code class="descname">copyto</code><span class="sig-paren">(</span><em>dst</em>, <em>src</em>, <em>casting='same_kind'</em>, <em>where=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.copyto" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies values from one array to another, broadcasting as necessary.</p>
<p>Raises a TypeError if the <cite>casting</cite> rule is violated, and if
<cite>where</cite> is provided, it selects which elements to copy.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<dl class="docutils">
<dt>dst <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array into which values are copied.</dd>
<dt>src <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array from which values are copied.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur when copying.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
</dd>
<dt>where <span class="classifier-delimiter">:</span> <span class="classifier">array_like of bool, optional</span></dt>
<dd>A boolean array which is broadcasted to match the dimensions
of <cite>dst</cite>, and selects elements to copy from <cite>src</cite> to <cite>dst</cite>
wherever it contains the value True.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numpy.concatenate">
<code class="descclassname">numpy.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>(a1</em>, <em>a2</em>, <em>...)</em>, <em>axis=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along an existing axis.</p>
<dl class="docutils">
<dt>a1, a2, … <span class="classifier-delimiter">:</span> <span class="classifier">sequence of array_like</span></dt>
<dd>The arrays must have the same shape, except in the dimension
corresponding to <cite>axis</cite> (the first, by default).</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which the arrays will be joined.  If axis is None,
arrays are flattened before use.  Default is 0.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>If provided, the destination to place the result. The shape must be
correct, matching that of what concatenate would have returned if no
out argument were specified.</dd>
</dl>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The concatenated array.</dd>
</dl>
<p>ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or</p>
<blockquote>
<div>near-equal size.</div></blockquote>
<p>split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)</p>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 5],</span>
<span class="go">       [3, 4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [0 -- 2],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 1 2 2 3 4],</span>
<span class="go">             mask = False,</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 -- 2 2 3 4],</span>
<span class="go">             mask = [False  True False False False False],</span>
<span class="go">       fill_value = 999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fastCopyAndTranspose">
<code class="descclassname">numpy.</code><code class="descname">fastCopyAndTranspose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fastCopyAndTranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>_fastCopyAndTranspose(a)</p>
</dd></dl>

<dl class="function">
<dt id="numpy.lexsort">
<code class="descclassname">numpy.</code><code class="descname">lexsort</code><span class="sig-paren">(</span><em>keys</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.lexsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an indirect stable sort using a sequence of keys.</p>
<p>Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, it’s rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.</p>
<dl class="docutils">
<dt>keys <span class="classifier-delimiter">:</span> <span class="classifier">(k, N) array or tuple containing k (N,)-shaped sequences</span></dt>
<dd>The <cite>k</cite> different “columns” to be sorted.  The last column (or row if
<cite>keys</cite> is a 2D array) is the primary sort key.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis to be indirectly sorted.  By default, sort over the last axis.</dd>
</dl>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">(N,) ndarray of ints</span></dt>
<dd>Array of indices that sort the keys along the specified axis.</dd>
</dl>
<p>argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.</p>
<p>Sort names: first by surname, then by name.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">surnames</span> <span class="o">=</span>    <span class="p">(</span><span class="s1">&#39;Hertz&#39;</span><span class="p">,</span>    <span class="s1">&#39;Galilei&#39;</span><span class="p">,</span> <span class="s1">&#39;Hertz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Heinrich&#39;</span><span class="p">,</span> <span class="s1">&#39;Galileo&#39;</span><span class="p">,</span> <span class="s1">&#39;Gustav&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">first_names</span><span class="p">,</span> <span class="n">surnames</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">surnames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">first_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>
<span class="go">[&#39;Galilei, Galileo&#39;, &#39;Hertz, Gustav&#39;, &#39;Hertz, Heinrich&#39;]</span>
</pre></div>
</div>
<p>Sort two columns of numbers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># First column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Second column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">))</span> <span class="c1"># Sort by a, then by b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
<span class="go">[2 0 4 6 5 3 1]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>
<span class="go">[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]</span>
</pre></div>
</div>
<p>Note that sorting is first according to the elements of <code class="docutils literal"><span class="pre">a</span></code>.
Secondary sorting is according to the elements of <code class="docutils literal"><span class="pre">b</span></code>.</p>
<p>A normal <code class="docutils literal"><span class="pre">argsort</span></code> would have yielded:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
<span class="go">[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]</span>
</pre></div>
</div>
<p>Structured arrays are sorted lexically by <code class="docutils literal"><span class="pre">argsort</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">... </span>             <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># or np.argsort(x, order=(&#39;x&#39;, &#39;y&#39;))</span>
<span class="go">array([2, 0, 4, 6, 5, 3, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.set_numeric_ops">
<code class="descclassname">numpy.</code><code class="descname">set_numeric_ops</code><span class="sig-paren">(</span><em>op1=func1</em>, <em>op2=func2</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_numeric_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Set numerical operators for array objects.</p>
<dl class="docutils">
<dt>op1, op2, … <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>Each <code class="docutils literal"><span class="pre">op</span> <span class="pre">=</span> <span class="pre">func</span></code> pair describes an operator to be replaced.
For example, <code class="docutils literal"><span class="pre">add</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">np.add(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">5</span></code> would replace
addition by modulus 5 addition.</dd>
</dl>
<dl class="docutils">
<dt>saved_ops <span class="classifier-delimiter">:</span> <span class="classifier">list of callables</span></dt>
<dd>A list of all operators, stored before making replacements.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Use with care!  Incorrect usage may lead to memory errors.</p>
</div>
<p>A function replacing an operator cannot make use of that operator.
For example, when replacing add, you may not use <code class="docutils literal"><span class="pre">+</span></code>.  Instead,
directly call ufuncs.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_mod5</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_funcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_numeric_ops</span><span class="p">(</span><span class="n">add</span><span class="o">=</span><span class="n">add_mod5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
<span class="go">array([[0, 2, 4, 1],</span>
<span class="go">       [3, 0, 2, 4],</span>
<span class="go">       [1, 3, 0, 2]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ignore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_numeric_ops</span><span class="p">(</span><span class="o">**</span><span class="n">old_funcs</span><span class="p">)</span> <span class="c1"># restore operators</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.can_cast">
<code class="descclassname">numpy.</code><code class="descname">can_cast</code><span class="sig-paren">(</span><em>from_</em>, <em>to</em>, <em>casting='safe'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.can_cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if cast between data types can occur according to the
casting rule.  If from is a scalar or array scalar, also returns
True if the scalar value can be cast without overflow or truncation
to an integer.</p>
<dl class="docutils">
<dt><a href="#id81"><span class="problematic" id="id82">from_</span></a> <span class="classifier-delimiter">:</span> <span class="classifier">dtype, dtype specifier, scalar, or array</span></dt>
<dd>Data type, scalar, or array to cast from.</dd>
<dt>to <span class="classifier-delimiter">:</span> <span class="classifier">dtype or dtype specifier</span></dt>
<dd>Data type to cast to.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if cast can occur according to the casting rule.</dd>
</dl>
<p>Starting in NumPy 1.9, can_cast function now returns False in ‘safe’
casting mode for integer/float dtype and string dtype if the string dtype
length is not long enough to store the max integer/float value converted
to a string. Previously can_cast in ‘safe’ mode returned True for
integer/float dtype and a string dtype of any length.</p>
<p>dtype, result_type</p>
<p>Basic examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;S4&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Casting scalars</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mf">3.5e100</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Array scalar checks the value, array does not</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">1000.0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1000.0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Using the casting rules</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;equiv&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;equiv&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;u4&#39;</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="s1">&#39;&lt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;u4&#39;</span><span class="p">,</span> <span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.promote_types">
<code class="descclassname">numpy.</code><code class="descname">promote_types</code><span class="sig-paren">(</span><em>type1</em>, <em>type2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.promote_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data type with the smallest size and smallest scalar
kind to which both <code class="docutils literal"><span class="pre">type1</span></code> and <code class="docutils literal"><span class="pre">type2</span></code> may be safely cast.
The returned data type is always in native byte order.</p>
<p>This function is symmetric, but rarely associative.</p>
<dl class="docutils">
<dt>type1 <span class="classifier-delimiter">:</span> <span class="classifier">dtype or dtype specifier</span></dt>
<dd>First data type.</dd>
<dt>type2 <span class="classifier-delimiter">:</span> <span class="classifier">dtype or dtype specifier</span></dt>
<dd>Second data type.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The promoted data type.</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<p>Starting in NumPy 1.9, promote_types function now returns a valid string
length when given an integer or float dtype as one argument and a string
dtype as another argument. Previously it always returned the input string
dtype, even if it wasn’t long enough to store the max integer/float value
converted to a string.</p>
<p>result_type, dtype, can_cast</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;&gt;i8&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;c8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;S8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;S11&#39;)</span>
</pre></div>
</div>
<p>An example of a non-associative case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="s1">&#39;i1&#39;</span><span class="p">,</span> <span class="s1">&#39;u1&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;S6&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;i1&#39;</span><span class="p">),</span> <span class="s1">&#39;u1&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;S4&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.min_scalar_type">
<code class="descclassname">numpy.</code><code class="descname">min_scalar_type</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.min_scalar_type" title="Permalink to this definition">¶</a></dt>
<dd><p>For scalar <code class="docutils literal"><span class="pre">a</span></code>, returns the data type with the smallest size
and smallest scalar kind which can hold its value.  For non-scalar
array <code class="docutils literal"><span class="pre">a</span></code>, returns the vector’s dtype unmodified.</p>
<p>Floating point values are not demoted to integers,
and complex values are not demoted to floats.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like</span></dt>
<dd>The value whose minimal data type is to be found.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The minimal data type.</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<p>result_type, promote_types, dtype, can_cast</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">dtype(&#39;uint8&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="o">-</span><span class="mi">260</span><span class="p">)</span>
<span class="go">dtype(&#39;int16&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mf">3.1</span><span class="p">)</span>
<span class="go">dtype(&#39;float16&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="mf">1e50</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.result_type">
<code class="descclassname">numpy.</code><code class="descname">result_type</code><span class="sig-paren">(</span><em>*arrays_and_dtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.result_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type that results from applying the NumPy
type promotion rules to the arguments.</p>
<p>Type promotion in NumPy works similarly to the rules in languages
like C++, with some slight differences.  When both scalars and
arrays are used, the array’s type takes precedence and the actual value
of the scalar is taken into account.</p>
<p>For example, calculating 3*a, where a is an array of 32-bit floats,
intuitively should result in a 32-bit float output.  If the 3 is a
32-bit integer, the NumPy rules indicate it can’t convert losslessly
into a 32-bit float, so a 64-bit float should be the result type.
By examining the value of the constant, ‘3’, we see that it fits in
an 8-bit integer, which can be cast losslessly into the 32-bit float.</p>
<dl class="docutils">
<dt>arrays_and_dtypes <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays and dtypes</span></dt>
<dd>The operands of some operation whose result type is needed.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The result type.</dd>
</dl>
<p>dtype, promote_types, min_scalar_type, can_cast</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<p>The specific algorithm used is as follows.</p>
<p>Categories are determined by first checking which of boolean,
integer (int/uint), or floating point (float/complex) the maximum
kind of all the arrays and the scalars are.</p>
<p>If there are only scalars or the maximum category of the scalars
is higher than the maximum category of the arrays,
the data types are combined with <a class="reference internal" href="#numpy.promote_types" title="numpy.promote_types"><code class="xref py py-func docutils literal"><span class="pre">promote_types()</span></code></a>
to produce the return value.</p>
<p>Otherwise, <cite>min_scalar_type</cite> is called on each array, and
the resulting data types are all combined with <a class="reference internal" href="#numpy.promote_types" title="numpy.promote_types"><code class="xref py py-func docutils literal"><span class="pre">promote_types()</span></code></a>
to produce the return value.</p>
<p>The set of int values is not a subset of the uint values for types
with the same number of bits, something not reflected in
<a class="reference internal" href="#numpy.min_scalar_type" title="numpy.min_scalar_type"><code class="xref py py-func docutils literal"><span class="pre">min_scalar_type()</span></code></a>, but handled as a special case in <cite>result_type</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i1&#39;</span><span class="p">))</span>
<span class="go">dtype(&#39;int8&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;c8&#39;</span><span class="p">)</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asarray">
<code class="descclassname">numpy.</code><code class="descname">asarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>By default, the data-type is inferred from the input data.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array interpretation of <cite>a</cite>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <cite>a</cite> is a
subclass of ndarray, a base class ndarray is returned.</dd>
</dl>
<p>asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div>memory order.</div></blockquote>
<p>asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div>positions.</div></blockquote>
<p>Convert a list into an array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Existing arrays are not copied:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>dtype</cite> is set, array is copied only if dtype does not match:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Contrary to <cite>asanyarray</cite>, ndarray subclasses are not passed through:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asanyarray">
<code class="descclassname">numpy.</code><code class="descname">asanyarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asanyarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an ndarray, but pass ndarray subclasses through.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data, in any form that can be converted to an array.  This
includes scalars, lists, lists of tuples, tuples, tuples of tuples,
tuples of lists, and ndarrays.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>By default, the data-type is inferred from the input data.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Whether to use row-major (C-style) or column-major
(Fortran-style) memory representation.  Defaults to ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or an ndarray subclass</span></dt>
<dd>Array interpretation of <cite>a</cite>.  If <cite>a</cite> is an ndarray or a subclass
of ndarray, it is returned as-is and no copy is performed.</dd>
</dl>
<p>asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div>memory order.</div></blockquote>
<dl class="docutils">
<dt>asarray_chkfinite <span class="classifier-delimiter">:</span> <span class="classifier">Similar function which checks input for NaNs and</span></dt>
<dd>Infs.</dd>
</dl>
<p>fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div>positions.</div></blockquote>
<p>Convert a list into an array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Instances of <cite>ndarray</cite> subclasses are passed through as-is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ascontiguousarray">
<code class="descclassname">numpy.</code><code class="descname">ascontiguousarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ascontiguousarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous array in memory (C order).</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype object, optional</span></dt>
<dd>Data-type of returned array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Contiguous array of same shape and content as <cite>a</cite>, with type <cite>dtype</cite>
if specified.</dd>
</dl>
<dl class="docutils">
<dt>asfortranarray <span class="classifier-delimiter">:</span> <span class="classifier">Convert input to an ndarray with column-major</span></dt>
<dd>memory order.</dd>
</dl>
<p>require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asfortranarray">
<code class="descclassname">numpy.</code><code class="descname">asfortranarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asfortranarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array laid out in Fortran order in memory.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype object, optional</span></dt>
<dd>By default, the data-type is inferred from the input data.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The input <cite>a</cite> in Fortran, or column-major, order.</dd>
</dl>
<p>ascontiguousarray : Convert input to a contiguous (C order) array.
asanyarray : Convert input to an ndarray with either row or</p>
<blockquote>
<div>column-major memory order.</div></blockquote>
<p>require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isfortran">
<code class="descclassname">numpy.</code><code class="descname">isfortran</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isfortran" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array is Fortran contiguous but <em>not</em> C contiguous.</p>
<p>This function is obsolete and, because of changes due to relaxed stride
checking, its return value for the same array may differ for versions
of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an
array is Fortran contiguous use <code class="docutils literal"><span class="pre">a.flags.f_contiguous</span></code> instead.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array.</dd>
</dl>
<p>np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;FORTRAN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The transpose of a C-ordered array is a FORTRAN-ordered array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [3, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfortran</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;FORTRAN&#39;</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.empty_like">
<code class="descclassname">numpy.</code><code class="descname">empty_like</code><span class="sig-paren">(</span><em>prototype</em>, <em>dtype=None</em>, <em>order='K'</em>, <em>subok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.empty_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the same shape and type as a given array.</p>
<dl class="docutils">
<dt>prototype <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The shape and data-type of <cite>prototype</cite> define these same attributes
of the returned array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first">Overrides the data type of the result.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt>
<dd><p class="first">Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <code class="docutils literal"><span class="pre">prototype</span></code> is Fortran
contiguous, ‘C’ otherwise. ‘K’ means match the layout of <code class="docutils literal"><span class="pre">prototype</span></code>
as closely as possible.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional.</span></dt>
<dd>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of uninitialized (arbitrary) data with the same
shape and type as <cite>prototype</cite>.</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.</p>
<p>This function does <em>not</em> initialize the returned array; to do that use
<cite>zeros_like</cite> or <cite>ones_like</cite> instead.  It may be marginally faster than
the functions that do set the array values.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>                         <span class="c1"># a is array-like</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[-1073741821, -1073741821,           3],    #random</span>
<span class="go">       [          0,           0, -1073741821]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000],#random</span>
<span class="go">       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.zeros_like">
<code class="descclassname">numpy.</code><code class="descname">zeros_like</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order='K'</em>, <em>subok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first">Overrides the data type of the result.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt>
<dd><p class="first">Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional.</span></dt>
<dd>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of zeros with the same shape and type as <cite>a</cite>.</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ones_like">
<code class="descclassname">numpy.</code><code class="descname">ones_like</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order='K'</em>, <em>subok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type as a given array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first">Overrides the data type of the result.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt>
<dd><p class="first">Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional.</span></dt>
<dd>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of ones with the same shape and type as <cite>a</cite>.</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [1, 1, 1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.correlate">
<code class="descclassname">numpy.</code><code class="descname">correlate</code><span class="sig-paren">(</span><em>a</em>, <em>v</em>, <em>mode='valid'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-correlation of two 1-dimensional sequences.</p>
<p>This function computes the correlation as generally defined in signal
processing texts:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">c_</span><span class="p">{</span><span class="n">av</span><span class="p">}[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_n</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with a and v sequences being zero-padded where necessary and conj being
the conjugate.</p>
<dl class="docutils">
<dt>a, v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input sequences.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘valid’, ‘same’, ‘full’}, optional</span></dt>
<dd>Refer to the <cite>convolve</cite> docstring.  Note that the default
is ‘valid’, unlike <cite>convolve</cite>, which uses ‘full’.</dd>
<dt>old_behavior <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><cite>old_behavior</cite> was removed in NumPy 1.10. If you need the old
behavior, use <cite>multiarray.correlate</cite>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Discrete cross-correlation of <cite>a</cite> and <cite>v</cite>.</dd>
</dl>
<p>convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.</p>
<p>The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">c</span><span class="s1">&#39;_</span><span class="si">{av}</span><span class="s1">[k] = sum_n a[n] conj(v[n+k])</span>
</pre></div>
</div>
<p>which is related to <code class="docutils literal"><span class="pre">c_{av}[k]</span></code> by <code class="docutils literal"><span class="pre">c'_{av}[k]</span> <span class="pre">=</span> <span class="pre">c_{av}[-k]</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="go">array([ 3.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>
<span class="go">array([ 2. ,  3.5,  3. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
<span class="go">array([ 0.5,  2. ,  3.5,  3. ,  0. ])</span>
</pre></div>
</div>
<p>Using complex sequences:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="go">array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])</span>
</pre></div>
</div>
<p>Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
<code class="docutils literal"><span class="pre">c_{va}[k]</span> <span class="pre">=</span> <span class="pre">c^{*}_{av}[-k]</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="go">array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.convolve">
<code class="descclassname">numpy.</code><code class="descname">convolve</code><span class="sig-paren">(</span><em>a</em>, <em>v</em>, <em>mode='full'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the discrete, linear convolution of two one-dimensional sequences.</p>
<p>The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal <a href="#id83"><span class="problematic" id="id11">[1]_</span></a>.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.</p>
<p>If <cite>v</cite> is longer than <cite>a</cite>, the arrays are swapped before computation.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">(N,) array_like</span></dt>
<dd>First one-dimensional input array.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">(M,) array_like</span></dt>
<dd>Second one-dimensional input array.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘full’, ‘valid’, ‘same’}, optional</span></dt>
<dd><dl class="first last docutils">
<dt>‘full’:</dt>
<dd>By default, mode is ‘full’.  This returns the convolution
at each point of overlap, with an output shape of (N+M-1,). At
the end-points of the convolution, the signals do not overlap
completely, and boundary effects may be seen.</dd>
<dt>‘same’:</dt>
<dd>Mode ‘same’ returns output of length <code class="docutils literal"><span class="pre">max(M,</span> <span class="pre">N)</span></code>.  Boundary
effects are still visible.</dd>
<dt>‘valid’:</dt>
<dd>Mode ‘valid’ returns output of length
<code class="docutils literal"><span class="pre">max(M,</span> <span class="pre">N)</span> <span class="pre">-</span> <span class="pre">min(M,</span> <span class="pre">N)</span> <span class="pre">+</span> <span class="pre">1</span></code>.  The convolution product is only given
for points where the signals overlap completely.  Values outside
the signal boundary have no effect.</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Discrete, linear convolution of <cite>a</cite> and <cite>v</cite>.</dd>
</dl>
<dl class="docutils">
<dt>scipy.signal.fftconvolve <span class="classifier-delimiter">:</span> <span class="classifier">Convolve two arrays using the Fast Fourier</span></dt>
<dd>Transform.</dd>
</dl>
<p>scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also</p>
<blockquote>
<div>accepts poly1d objects as input.</div></blockquote>
<p>The discrete convolution operation is defined as</p>
<div class="math">
\[(a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]\]</div>
<p>It can be shown that a convolution <span class="math">\(x(t) * y(t)\)</span> in time/space
is equivalent to the multiplication <span class="math">\(X(f) Y(f)\)</span> in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function <cite>scipy.signal.fftconvolve</cite> exploits the
FFT to calculate the convolution of large data-sets.</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Wikipedia, “Convolution”, <a class="reference external" href="http://en.wikipedia.org/wiki/Convolution">http://en.wikipedia.org/wiki/Convolution</a>.</td></tr>
</tbody>
</table>
<p>Note how the convolution operator flips the second array
before “sliding” the two across one another:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="go">array([ 0. ,  1. ,  2.5,  4. ,  1.5])</span>
</pre></div>
</div>
<p>Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="go">array([ 1. ,  2.5,  4. ])</span>
</pre></div>
</div>
<p>The two arrays are of the same length, so there
is only one position where they completely overlap:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="go">array([ 2.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.inner">
<code class="descclassname">numpy.</code><code class="descname">inner</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of two arrays.</p>
<p>Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.</p>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>If <cite>a</cite> and <cite>b</cite> are nonscalar, their last dimensions must match.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>out.shape = a.shape[:-1] + b.shape[:-1]</cite></dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the last dimension of <cite>a</cite> and <cite>b</cite> has different size.</dd>
</dl>
<p>tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of <cite>b</cite>.
einsum : Einstein summation convention.</p>
<p>For vectors (1-D arrays) it computes the ordinary inner-product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[:]</span><span class="o">*</span><span class="n">b</span><span class="p">[:])</span>
</pre></div>
</div>
<p>More generally, if <cite>ndim(a) = r &gt; 0</cite> and <cite>ndim(b) = s &gt; 0</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>or explicitly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
     <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span>
</pre></div>
</div>
<p>In addition <cite>a</cite> or <cite>b</cite> may be scalars, in which case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
</pre></div>
</div>
<p>Ordinary inner product for vectors:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>A multidimensional example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 14,  38,  62],</span>
<span class="go">       [ 86, 110, 134]])</span>
</pre></div>
</div>
<p>An example where <cite>b</cite> is a scalar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[ 7.,  0.],</span>
<span class="go">       [ 0.,  7.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.dot">
<code class="descclassname">numpy.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays. Specifically,</p>
<ul>
<li><p class="first">If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p>
</li>
<li><p class="first">If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <a class="reference internal" href="#numpy.matmul" title="numpy.matmul"><code class="xref py py-func docutils literal"><span class="pre">matmul()</span></code></a> or <code class="docutils literal"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p>
</li>
<li><p class="first">If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <code class="xref py py-func docutils literal"><span class="pre">multiply()</span></code>
and using <code class="docutils literal"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p>
</li>
<li><p class="first">If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p>
</li>
<li><p class="first">If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>First argument.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Second argument.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</dd>
</dl>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : ‘&#64;’ operator as method with out parameter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it is the matrix product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">499128</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.outer">
<code class="descclassname">numpy.</code><code class="descname">outer</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the outer product of two vectors.</p>
<p>Given two vectors, <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">...,</span> <span class="pre">aM]</span></code> and
<code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">[b0,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">bN]</span></code>,
the outer product <a href="#id84"><span class="problematic" id="id13">[1]_</span></a> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span><span class="o">*</span><span class="n">b0</span>  <span class="n">a0</span><span class="o">*</span><span class="n">b1</span> <span class="o">...</span> <span class="n">a0</span><span class="o">*</span><span class="n">bN</span> <span class="p">]</span>
 <span class="p">[</span><span class="n">a1</span><span class="o">*</span><span class="n">b0</span>    <span class="o">.</span>
 <span class="p">[</span> <span class="o">...</span>          <span class="o">.</span>
 <span class="p">[</span><span class="n">aM</span><span class="o">*</span><span class="n">b0</span>            <span class="n">aM</span><span class="o">*</span><span class="n">bN</span> <span class="p">]]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">(M,) array_like</span></dt>
<dd>First input vector.  Input is flattened if
not already 1-dimensional.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">(N,) array_like</span></dt>
<dd>Second input vector.  Input is flattened if
not already 1-dimensional.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray, optional</span></dt>
<dd><p class="first">A location where the result is stored</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray</span></dt>
<dd><code class="docutils literal"><span class="pre">out[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[j]</span></code></dd>
</dl>
<p>inner
einsum : <code class="docutils literal"><span class="pre">einsum('i,j-&gt;ij',</span> <span class="pre">a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">np.multiply.outer(a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.</div></blockquote>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>: G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd
ed., Baltimore, MD, Johns Hopkins University Press, 1996,
pg. 8.</td></tr>
</tbody>
</table>
<p>Make a (<em>very</em> coarse) grid for computing a Mandelbrot set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span>
<span class="go">array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>
<span class="go">array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],</span>
<span class="go">       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],</span>
<span class="go">       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],</span>
<span class="go">       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],</span>
<span class="go">       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">+</span> <span class="n">im</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>
<span class="go">array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="go">       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="go">       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="go">       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="go">       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>
</pre></div>
</div>
<p>An example using a “vector” of letters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([[a, aa, aaa],</span>
<span class="go">       [b, bb, bbb],</span>
<span class="go">       [c, cc, ccc]], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.vdot">
<code class="descclassname">numpy.</code><code class="descname">vdot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of two vectors.</p>
<p>The vdot(<cite>a</cite>, <cite>b</cite>) function handles complex numbers differently than
dot(<cite>a</cite>, <cite>b</cite>).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.</p>
<p>Note that <cite>vdot</cite> handles multidimensional arrays differently than <cite>dot</cite>:
it does <em>not</em> perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>If <cite>a</cite> is complex the complex conjugate is taken before calculation
of the dot product.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Second argument to the dot product.</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Dot product of <cite>a</cite> and <cite>b</cite>.  Can be an int, float, or
complex depending on the types of <cite>a</cite> and <cite>b</cite>.</dd>
</dl>
<dl class="docutils">
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">Return the dot product without using the complex conjugate of the</span></dt>
<dd>first argument.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">,</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(70-8j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">(70+8j)</span>
</pre></div>
</div>
<p>Note that higher-dimensional arrays are flattened!</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="mi">2</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.roll">
<code class="descclassname">numpy.</code><code class="descname">roll</code><span class="sig-paren">(</span><em>a</em>, <em>shift</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll array elements along a given axis.</p>
<p>Elements that roll beyond the last position are re-introduced at
the first.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>shift <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>The number of places by which elements are shifted.  If a tuple,
then <cite>axis</cite> must be a tuple of the same size, and each of the
given axes is shifted by the corresponding number.  If an int
while <cite>axis</cite> is a tuple of ints, then the same value is used for
all given axes.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints, optional</span></dt>
<dd>Axis or axes along which elements are shifted.  By default, the
array is flattened before shifting, after which the original
shape is restored.</dd>
</dl>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array, with the same shape as <cite>a</cite>.</dd>
</dl>
<dl class="docutils">
<dt>rollaxis <span class="classifier-delimiter">:</span> <span class="classifier">Roll the specified axis backwards, until it lies in a</span></dt>
<dd>given position.</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>Supports rolling over multiple dimensions simultaneously.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[9, 0, 1, 2, 3],</span>
<span class="go">       [4, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[4, 0, 1, 2, 3],</span>
<span class="go">       [9, 5, 6, 7, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.rollaxis">
<code class="descclassname">numpy.</code><code class="descname">rollaxis</code><span class="sig-paren">(</span><em>a</em>, <em>axis</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rollaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
<p>This function continues to be supported for backward compatibility, but you
should prefer <cite>moveaxis</cite>. The <cite>moveaxis</cite> function was added in NumPy
1.11.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis to roll backwards.  The positions of the other axes do not
change relative to one another.</dd>
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis is rolled until it lies before this position.  The default,
0, results in a “complete” roll.</dd>
</dl>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>For NumPy &gt;= 1.10.0 a view of <cite>a</cite> is always returned. For earlier
NumPy versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</dd>
</dl>
<p>moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a</p>
<blockquote>
<div>given axis.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 6, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 5, 6, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.moveaxis">
<code class="descclassname">numpy.</code><code class="descname">moveaxis</code><span class="sig-paren">(</span><em>a</em>, <em>source</em>, <em>destination</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Move axes of an array to new positions.</p>
<p>Other axes remain in their original order.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>The array whose axes should be reordered.</dd>
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of int</span></dt>
<dd>Original positions of the axes to move. These must be unique.</dd>
<dt>destination <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of int</span></dt>
<dd>Destination positions for each of the original axes. These must also be
unique.</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>Array with moved axes. This array is a view of the input array.</dd>
</dl>
<p>transpose: Permute the dimensions of an array.
swapaxes: Interchange two axes of an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4)</span>
</pre></div>
</div>
<p>These all achieve the same result:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.cross">
<code class="descclassname">numpy.</code><code class="descname">cross</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>axisa=-1</em>, <em>axisb=-1</em>, <em>axisc=-1</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cross product of two (arrays of) vectors.</p>
<p>The cross product of <cite>a</cite> and <cite>b</cite> in <span class="math">\(R^3\)</span> is a vector perpendicular
to both <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are arrays of vectors, the vectors
are defined by the last axis of <cite>a</cite> and <cite>b</cite> by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either <cite>a</cite> or <cite>b</cite> is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Components of the first vector(s).</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Components of the second vector(s).</dd>
<dt>axisa <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis of <cite>a</cite> that defines the vector(s).  By default, the last axis.</dd>
<dt>axisb <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis of <cite>b</cite> that defines the vector(s).  By default, the last axis.</dd>
<dt>axisc <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis of <cite>c</cite> containing the cross product vector(s).  Ignored if
both input vectors have dimension 2, as the return is scalar.
By default, the last axis.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>If defined, the axis of <cite>a</cite>, <cite>b</cite> and <cite>c</cite> that defines the vector(s)
and cross product(s).  Overrides <cite>axisa</cite>, <cite>axisb</cite> and <cite>axisc</cite>.</dd>
</dl>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Vector cross product(s).</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>When the dimension of the vector(s) in <cite>a</cite> and/or <cite>b</cite> does not
equal 2 or 3.</dd>
</dl>
<p>inner : Inner product
outer : Outer product.
<a href="#id85"><span class="problematic" id="id86">ix_</span></a> : Construct index arrays.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<p>Supports full broadcasting of the inputs.</p>
<p>Vector cross-product.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([-3,  6, -3])</span>
</pre></div>
</div>
<p>One vector with dimension 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Equivalently:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Both vectors with dimension 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the <cite>right-hand rule</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[-3,  6, -3],</span>
<span class="go">       [ 3, -6,  3]])</span>
</pre></div>
</div>
<p>The orientation of <cite>c</cite> can be changed using the <cite>axisc</cite> keyword.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-3,  3],</span>
<span class="go">       [ 6, -6],</span>
<span class="go">       [-3,  3]])</span>
</pre></div>
</div>
<p>Change the vector definition of <cite>x</cite> and <cite>y</cite> using <cite>axisa</cite> and <cite>axisb</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[ -6,  12,  -6],</span>
<span class="go">       [  0,   0,   0],</span>
<span class="go">       [  6, -12,   6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-24,  48, -24],</span>
<span class="go">       [-30,  60, -30],</span>
<span class="go">       [-36,  72, -36]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tensordot">
<code class="descclassname">numpy.</code><code class="descname">tensordot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>axes=2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tensor dot product along specified axes for arrays &gt;= 1-D.</p>
<p>Given two tensors (arrays of dimension greater than or equal to one),
<cite>a</cite> and <cite>b</cite>, and an array_like object containing two array_like
objects, <code class="docutils literal"><span class="pre">(a_axes,</span> <span class="pre">b_axes)</span></code>, sum the products of <cite>a</cite>’s and <cite>b</cite>’s
elements (components) over the axes specified by <code class="docutils literal"><span class="pre">a_axes</span></code> and
<code class="docutils literal"><span class="pre">b_axes</span></code>. The third argument can be a single non-negative
integer_like scalar, <code class="docutils literal"><span class="pre">N</span></code>; if it is such, then the last <code class="docutils literal"><span class="pre">N</span></code>
dimensions of <cite>a</cite> and the first <code class="docutils literal"><span class="pre">N</span></code> dimensions of <cite>b</cite> are summed
over.</p>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">array_like, len(shape) &gt;= 1</span></dt>
<dd>Tensors to “dot”.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">int or (2,) array_like</span></dt>
<dd><ul class="first last simple">
<li>integer_like
If an int N, sum over the last N axes of <cite>a</cite> and the first N axes
of <cite>b</cite> in order. The sizes of the corresponding axes must match.</li>
<li>(2,) array_like
Or, a list of axes to be summed over, first sequence applying to <cite>a</cite>,
second to <cite>b</cite>. Both elements array_like must be of the same length.</li>
</ul>
</dd>
</dl>
<p>dot, einsum</p>
<dl class="docutils">
<dt>Three common use cases are:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">0</span></code> : tensor product <span class="math">\(a\otimes b\)</span></li>
<li><code class="docutils literal"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">1</span></code> : tensor dot product <span class="math">\(a\cdot b\)</span></li>
<li><code class="docutils literal"><span class="pre">axes</span> <span class="pre">=</span> <span class="pre">2</span></code> : (default) tensor double contraction <span class="math">\(a:b\)</span></li>
</ul>
</dd>
</dl>
<p>When <cite>axes</cite> is integer_like, the sequence for evaluation will be: first
the -Nth axis in <cite>a</cite> and 0th axis in <cite>b</cite>, and the -1th axis in <cite>a</cite> and
Nth axis in <cite>b</cite> last.</p>
<p>When there is more than one axis to sum over - and they are not the last
(first) axes of <cite>a</cite> (<cite>b</cite>) - the argument <cite>axes</cite> should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.</p>
<p>A “traditional” example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A slower but equivalent way of computing the same...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">array([[ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True],</span>
<span class="go">       [ True,  True]])</span>
</pre></div>
</div>
<p>An extended example taking advantage of the overloading of + and *:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">;</span> <span class="n">A</span>
<span class="go">array([[[1, 2],</span>
<span class="go">        [3, 4]],</span>
<span class="go">       [[5, 6],</span>
<span class="go">        [7, 8]]])</span>
<span class="go">array([[a, b],</span>
<span class="go">       [c, d]], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="c1"># third argument default is 2 for double-contraction</span>
<span class="go">array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[[acc, bdd],</span>
<span class="go">        [aaacccc, bbbdddd]],</span>
<span class="go">       [[aaaaacccccc, bbbbbdddddd],</span>
<span class="go">        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># tensor product (result too long to incl.)</span>
<span class="go">array([[[[[a, b],</span>
<span class="go">          [c, d]],</span>
<span class="go">          ...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[[abbbbb, cddddd],</span>
<span class="go">        [aabbbbbb, ccdddddd]],</span>
<span class="go">       [[aaabbbbbbb, cccddddddd],</span>
<span class="go">        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[[abb, cdd],</span>
<span class="go">        [aaabbbb, cccdddd]],</span>
<span class="go">       [[aaaaabbbbbb, cccccdddddd],</span>
<span class="go">        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.require">
<code class="descclassname">numpy.</code><code class="descname">require</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>requirements=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ndarray of the provided type that satisfies requirements.</p>
<p>This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The object to be converted to a type-and-requirement-satisfying array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>The required data-type. If None preserve the current dtype. If your
application requires the data to be in native byteorder, include
a byteorder specification as a part of the dtype specification.</dd>
<dt>requirements <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str</span></dt>
<dd><p class="first">The requirements list can be any of the following</p>
<ul class="last simple">
<li>‘F_CONTIGUOUS’ (‘F’) - ensure a Fortran-contiguous array</li>
<li>‘C_CONTIGUOUS’ (‘C’) - ensure a C-contiguous array</li>
<li>‘ALIGNED’ (‘A’)      - ensure a data-type aligned array</li>
<li>‘WRITEABLE’ (‘W’)    - ensure a writable array</li>
<li>‘OWNDATA’ (‘O’)      - ensure an array that owns its own data</li>
<li>‘ENSUREARRAY’, (‘E’) - ensure a base array, instead of a subclass</li>
</ul>
</dd>
</dl>
<p>asarray : Convert input to an ndarray.
asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div>memory order.</div></blockquote>
<p>ndarray.flags : Information about the memory layout of the array.</p>
<p>The returned array will be guaranteed to have the listed requirements
by making a copy if needed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : False</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : False</span>
<span class="go">  F_CONTIGUOUS : True</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fromiter">
<code class="descclassname">numpy.</code><code class="descname">fromiter</code><span class="sig-paren">(</span><em>iterable</em>, <em>dtype</em>, <em>count=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new 1-dimensional array from an iterable object.</p>
<dl class="docutils">
<dt>iterable <span class="classifier-delimiter">:</span> <span class="classifier">iterable object</span></dt>
<dd>An iterable object providing data for the array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>The data-type of the returned array.</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of items to read from <em>iterable</em>.  The default is -1,
which means all data is read.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The output array.</dd>
</dl>
<p>Specify <cite>count</cite> to improve performance.  It allows <code class="docutils literal"><span class="pre">fromiter</span></code> to
pre-allocate the output array, instead of resizing it on demand.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterable</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">array([  0.,   1.,   4.,   9.,  16.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array_equal">
<code class="descclassname">numpy.</code><code class="descname">array_equal</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if two arrays have the same shape and elements, False otherwise.</p>
<dl class="docutils">
<dt>a1, a2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays.</dd>
</dl>
<dl class="docutils">
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Returns True if the arrays are equal.</dd>
</dl>
<dl class="docutils">
<dt>allclose: Returns True if two arrays are element-wise equal within a</dt>
<dd>tolerance.</dd>
<dt>array_equiv: Returns True if input arrays are shape consistent and all</dt>
<dd>elements equal.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array_equiv">
<code class="descclassname">numpy.</code><code class="descname">array_equiv</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_equiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if input arrays are shape consistent and all elements equal.</p>
<p>Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.</p>
<dl class="docutils">
<dt>a1, a2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if equivalent, False otherwise.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Showing the shape equivalence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.indices">
<code class="descclassname">numpy.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>dimensions</em>, <em>dtype=&lt;class 'int'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array representing the indices of a grid.</p>
<p>Compute an array where the subarrays contain index values 0,1,…
varying only along the corresponding axis.</p>
<dl class="docutils">
<dt>dimensions <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd>The shape of the grid.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Data type of the result.</dd>
</dl>
<dl class="docutils">
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array of grid indices,
<code class="docutils literal"><span class="pre">grid.shape</span> <span class="pre">=</span> <span class="pre">(len(dimensions),)</span> <span class="pre">+</span> <span class="pre">tuple(dimensions)</span></code>.</dd>
</dl>
<p>mgrid, meshgrid</p>
<p>The output shape is obtained by prepending the number of dimensions
in front of the tuple of dimensions, i.e. if <cite>dimensions</cite> is a tuple
<code class="docutils literal"><span class="pre">(r0,</span> <span class="pre">...,</span> <span class="pre">rN-1)</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the output shape is
<code class="docutils literal"><span class="pre">(N,r0,...,rN-1)</span></code>.</p>
<p>The subarrays <code class="docutils literal"><span class="pre">grid[k]</span></code> contains the N-D array of indices along the
<code class="docutils literal"><span class="pre">k-th</span></code> axis. Explicitly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">iN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ik</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="c1"># row indices</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [1, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>        <span class="c1"># column indices</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [0, 1, 2]])</span>
</pre></div>
</div>
<p>The indices can be used as an index into an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<p>Note that it would be more straightforward in the above example to
extract the required elements directly with <code class="docutils literal"><span class="pre">x[:2,</span> <span class="pre">:3]</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.fromfunction">
<code class="descclassname">numpy.</code><code class="descname">fromfunction</code><span class="sig-paren">(</span><em>function</em>, <em>shape</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromfunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by executing a function over each coordinate.</p>
<p>The resulting array therefore has a value <code class="docutils literal"><span class="pre">fn(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> at
coordinate <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.</p>
<dl class="docutils">
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>The function is called with N parameters, where N is the rank of
<cite>shape</cite>.  Each parameter represents the coordinates of the array
varying along a specific axis.  For example, if <cite>shape</cite>
were <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">2)</span></code>, then the parameters would be
<code class="docutils literal"><span class="pre">array([[0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">1]])</span></code> and <code class="docutils literal"><span class="pre">array([[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]])</span></code></dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">(N,) tuple of ints</span></dt>
<dd>Shape of the output array, which also determines the shape of
the coordinate arrays passed to <cite>function</cite>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Data-type of the coordinate arrays passed to <cite>function</cite>.
By default, <cite>dtype</cite> is float.</dd>
</dl>
<dl class="docutils">
<dt>fromfunction <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>The result of the call to <cite>function</cite> is passed back directly.
Therefore the shape of <cite>fromfunction</cite> is completely determined by
<cite>function</cite>.  If <cite>function</cite> returns a scalar value, the shape of
<cite>fromfunction</cite> would match the <cite>shape</cite> parameter.</dd>
</dl>
<p>indices, meshgrid</p>
<p>Keywords other than <cite>dtype</cite> are passed to <cite>function</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[ True, False, False],</span>
<span class="go">       [False,  True, False],</span>
<span class="go">       [False, False,  True]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isclose">
<code class="descclassname">numpy.</code><code class="descname">isclose</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>rtol=1e-05</em>, <em>atol=1e-08</em>, <em>equal_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array where two arrays are element-wise equal within a
tolerance.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The default <cite>atol</cite> is not appropriate for comparing numbers
that are much smaller than one (see Notes).</p>
</div>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays to compare.</dd>
<dt>rtol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The relative tolerance parameter (see Notes).</dd>
<dt>atol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The absolute tolerance parameter (see Notes).</dd>
<dt>equal_nan <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Returns a boolean array of where <cite>a</cite> and <cite>b</cite> are equal within the
given tolerance. If both <cite>a</cite> and <cite>b</cite> are scalars, returns a single
boolean value.</dd>
</dl>
<p>allclose</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p>For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.</p>
<blockquote>
<div>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</div></blockquote>
<p>Unlike the built-in <cite>math.isclose</cite>, the above equation is not symmetric
in <cite>a</cite> and <cite>b</cite> – it assumes <cite>b</cite> is the reference value – so that
<cite>isclose(a, b)</cite> might be different from <cite>isclose(b, a)</cite>. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
<cite>atol</cite> should be carefully selected for the use case at hand. A zero value
for <cite>atol</cite> will result in <cite>False</cite> if either <cite>a</cite> or <cite>b</cite> is zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">array([True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([False, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True, False], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-100</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False, False], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.999999e-10</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False,  True], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.load">
<code class="descclassname">numpy.</code><code class="descname">load</code><span class="sig-paren">(</span><em>file</em>, <em>mmap_mode=None</em>, <em>allow_pickle=True</em>, <em>fix_imports=True</em>, <em>encoding='ASCII'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load arrays or pickled objects from <code class="docutils literal"><span class="pre">.npy</span></code>, <code class="docutils literal"><span class="pre">.npz</span></code> or pickled files.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">file-like object, string, or pathlib.Path</span></dt>
<dd>The file to read. File-like objects must support the
<code class="docutils literal"><span class="pre">seek()</span></code> and <code class="docutils literal"><span class="pre">read()</span></code> methods. Pickled files require that the
file-like object support the <code class="docutils literal"><span class="pre">readline()</span></code> method as well.</dd>
<dt>mmap_mode <span class="classifier-delimiter">:</span> <span class="classifier">{None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional</span></dt>
<dd>If not None, then memory-map the file, using the given mode (see
<cite>numpy.memmap</cite> for a detailed description of the modes).  A
memory-mapped array is kept on disk. However, it can be accessed
and sliced like any ndarray.  Memory mapping is especially useful
for accessing small fragments of large files without reading the
entire file into memory.</dd>
<dt>allow_pickle <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Allow loading pickled object arrays stored in npy files. Reasons for
disallowing pickles include security, as loading pickled data can
execute arbitrary code. If pickles are disallowed, loading object
arrays will fail.
Default: True</dd>
<dt>fix_imports <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Only useful when loading Python 2 generated pickled files on Python 3,
which includes npy/npz files containing object arrays. If <cite>fix_imports</cite>
is True, pickle will try to map the old Python 2 names to the new names
used in Python 3.</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>What encoding to use when reading Python 2 strings. Only useful when
loading Python 2 generated pickled files in Python 3, which includes
npy/npz files containing object arrays. Values other than ‘latin1’,
‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical
data. Default: ‘ASCII’</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">array, tuple, dict, etc.</span></dt>
<dd>Data stored in the file. For <code class="docutils literal"><span class="pre">.npz</span></code> files, the returned instance
of NpzFile class must be closed to avoid leaking file descriptors.</dd>
</dl>
<dl class="docutils">
<dt>IOError</dt>
<dd>If the input file does not exist or cannot be read.</dd>
<dt>ValueError</dt>
<dd>The file contains an object array, but allow_pickle=False given.</dd>
</dl>
<p>save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.
lib.format.open_memmap : Create or load a memory-mapped <code class="docutils literal"><span class="pre">.npy</span></code> file.</p>
<ul>
<li><p class="first">If the file contains pickle data, then whatever object is stored
in the pickle is returned.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npy</span></code> file, then a single array is returned.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npz</span></code> file, then a dictionary-like object is
returned, containing <code class="docutils literal"><span class="pre">{filename:</span> <span class="pre">array}</span></code> key-value pairs, one for
each file in the archive.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npz</span></code> file, the returned value supports the
context manager protocol in a similar fashion to the open function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">load</span><span class="p">(</span><span class="s1">&#39;foo.npz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The underlying file descriptor is closed when exiting the ‘with’
block.</p>
</li>
</ul>
<p>Store data to disk, and load it again:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/tmp/123&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<p>Store compressed data to disk, and load it again:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Mem-map the stored array, and then access the second row
directly from disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">memmap([4, 5, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.loads">
<code class="descclassname">numpy.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.loads" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="numpy.isscalar">
<code class="descclassname">numpy.</code><code class="descname">isscalar</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the type of <cite>num</cite> is a scalar type.</p>
<dl class="docutils">
<dt>num <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>Input argument, can be of any type and shape.</dd>
</dl>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if <cite>num</cite> is a scalar type, False if it is not.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="mf">3.1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">([</span><span class="mf">3.1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>NumPy supports PEP 3141 numbers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isscalar</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isscalar</span><span class="p">(</span><span class="n">Number</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.binary_repr">
<code class="descclassname">numpy.</code><code class="descname">binary_repr</code><span class="sig-paren">(</span><em>num</em>, <em>width=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.binary_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the binary representation of the input number as a string.</p>
<p>For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two’s complement of the number is
returned, with respect to that width.</p>
<p>In a two’s-complement system negative numbers are represented by the two’s
complement of the absolute value. This is the most common method of
representing signed integers on computers <a href="#id87"><span class="problematic" id="id15">[1]_</span></a>. A N-bit two’s-complement
system can represent every integer in the range
<span class="math">\(-2^{N-1}\)</span> to <span class="math">\(+2^{N-1}-1\)</span>.</p>
<dl class="docutils">
<dt>num <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Only an integer decimal number can be used.</dd>
<dt>width <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">The length of the returned string if <cite>num</cite> is positive, or the length
of the two’s complement if <cite>num</cite> is negative, provided that <cite>width</cite> is
at least a sufficient number of bits for <cite>num</cite> to be represented in the
designated form.</p>
<p>If the <cite>width</cite> value is insufficient, it will be ignored, and <cite>num</cite> will
be returned in binary (<cite>num</cite> &gt; 0) or two’s complement (<cite>num</cite> &lt; 0) form
with its width equal to the minimum number of bits needed to represent
the number in the designated form. This behavior is deprecated and will
later raise an error.</p>
<div class="last deprecated">
<p><span class="versionmodified">Deprecated since version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>bin <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Binary representation of <cite>num</cite> or two’s complement of <cite>num</cite>.</dd>
</dl>
<dl class="docutils">
<dt>base_repr: Return a string representation of a number in the given base</dt>
<dd>system.</dd>
</dl>
<p>bin: Python’s built-in binary representation generator of an integer.</p>
<p><cite>binary_repr</cite> is equivalent to using <cite>base_repr</cite> with base 2, but about 25x
faster.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Wikipedia, “Two’s complement”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Two's_complement">http://en.wikipedia.org/wiki/Two’s_complement</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;-11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;0011&#39;</span>
</pre></div>
</div>
<p>The two’s complement is returned when the input number is negative and
width is specified:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.base_repr">
<code class="descclassname">numpy.</code><code class="descname">base_repr</code><span class="sig-paren">(</span><em>number</em>, <em>base=2</em>, <em>padding=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.base_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of a number in the given base system.</p>
<dl class="docutils">
<dt>number <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The value to convert. Positive and negative values are handled.</dd>
<dt>base <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Convert <cite>number</cite> to the <cite>base</cite> number system. The valid range is 2-36,
the default value is 2.</dd>
<dt>padding <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of zeros padded on the left. Default is 0 (no padding).</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>String representation of <cite>number</cite> in <cite>base</cite> system.</dd>
</dl>
<p>binary_repr : Faster version of <cite>base_repr</cite> for base 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;00012&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;20&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ones">
<code class="descclassname">numpy.</code><code class="descname">ones</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype=None</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with ones.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Shape of the new array, e.g., <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">2</span></code>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional, default: C</span></dt>
<dd>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of ones with the given shape, dtype, and order.</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 1.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.identity">
<code class="descclassname">numpy.</code><code class="descname">identity</code><span class="sig-paren">(</span><em>n</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the identity array.</p>
<p>The identity array is a square array with ones on
the main diagonal.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of rows (and columns) in <cite>n</cite> x <cite>n</cite> output.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Data-type of the output.  Defaults to <code class="docutils literal"><span class="pre">float</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>n</cite> x <cite>n</cite> array with its main diagonal set to one,
and all other elements 0.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.allclose">
<code class="descclassname">numpy.</code><code class="descname">allclose</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>rtol=1e-05</em>, <em>atol=1e-08</em>, <em>equal_nan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.allclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if two arrays are element-wise equal within a tolerance.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<p>If either array contains one or more NaNs, False is returned.
Infs are treated as equal if they are in the same place and of the same
sign in both arrays.</p>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays to compare.</dd>
<dt>rtol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The relative tolerance parameter (see Notes).</dd>
<dt>atol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The absolute tolerance parameter (see Notes).</dd>
<dt>equal_nan <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to compare NaN’s as equal.  If True, NaN’s in <cite>a</cite> will be
considered equal to NaN’s in <cite>b</cite> in the output array.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>allclose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Returns True if the two arrays are equal within the given
tolerance; False otherwise.</dd>
</dl>
<p>isclose, all, any, equal</p>
<p>If the following equation is element-wise True, then allclose returns
True.</p>
<blockquote>
<div>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</div></blockquote>
<p>The above equation is not symmetric in <cite>a</cite> and <cite>b</cite>, so that
<code class="docutils literal"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> might be different from <code class="docutils literal"><span class="pre">allclose(b,</span> <span class="pre">a)</span></code> in
some rare cases.</p>
<p>The comparison of <cite>a</cite> and <cite>b</cite> uses standard broadcasting, which
means that <cite>a</cite> and <cite>b</cite> need not have the same shape in order for
<code class="docutils literal"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> to evaluate to True.  The same is true for
<cite>equal</cite> but not <cite>array_equal</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.compare_chararrays">
<code class="descclassname">numpy.</code><code class="descname">compare_chararrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.compare_chararrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="numpy.putmask">
<code class="descclassname">numpy.</code><code class="descname">putmask</code><span class="sig-paren">(</span><em>a</em>, <em>mask</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.putmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes elements of an array based on conditional and input values.</p>
<p>Sets <code class="docutils literal"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for each n where <code class="docutils literal"><span class="pre">mask.flat[n]==True</span></code>.</p>
<p>If <cite>values</cite> is not the same size as <cite>a</cite> and <cite>mask</cite> then it will repeat.
This gives behavior different from <code class="docutils literal"><span class="pre">a[mask]</span> <span class="pre">=</span> <span class="pre">values</span></code>.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Target array.</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Boolean mask array. It has to be the same shape as <cite>a</cite>.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to put into <cite>a</cite> where <cite>mask</cite> is True. If <cite>values</cite> is smaller
than <cite>a</cite> it will be repeated.</dd>
</dl>
<p>place, put, take, copyto</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [ 9, 16, 25]])</span>
</pre></div>
</div>
<p>If <cite>values</cite> is smaller than <cite>a</cite> it is repeated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">33</span><span class="p">,</span> <span class="o">-</span><span class="mi">44</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([  0,   1, -33, -44, -33])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.seterr">
<code class="descclassname">numpy.</code><code class="descname">seterr</code><span class="sig-paren">(</span><em>all=None</em>, <em>divide=None</em>, <em>over=None</em>, <em>under=None</em>, <em>invalid=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set how floating-point errors are handled.</p>
<p>Note that operations on integer scalar types (such as <cite>int16</cite>) are
handled like floating point, and are affected by these settings.</p>
<dl class="docutils">
<dt>all <span class="classifier-delimiter">:</span> <span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt>
<dd><p class="first">Set treatment for all types of floating-point errors at once:</p>
<ul class="simple">
<li>ignore: Take no action when the exception occurs.</li>
<li>warn: Print a <cite>RuntimeWarning</cite> (via the Python <cite>warnings</cite> module).</li>
<li>raise: Raise a <cite>FloatingPointError</cite>.</li>
<li>call: Call a function specified using the <cite>seterrcall</cite> function.</li>
<li>print: Print a warning directly to <code class="docutils literal"><span class="pre">stdout</span></code>.</li>
<li>log: Record error in a Log object specified by <cite>seterrcall</cite>.</li>
</ul>
<p class="last">The default is not to change the current behavior.</p>
</dd>
<dt>divide <span class="classifier-delimiter">:</span> <span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt>
<dd>Treatment for division by zero.</dd>
<dt>over <span class="classifier-delimiter">:</span> <span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt>
<dd>Treatment for floating-point overflow.</dd>
<dt>under <span class="classifier-delimiter">:</span> <span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt>
<dd>Treatment for floating-point underflow.</dd>
<dt>invalid <span class="classifier-delimiter">:</span> <span class="classifier">{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}, optional</span></dt>
<dd>Treatment for invalid floating-point operation.</dd>
</dl>
<dl class="docutils">
<dt>old_settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Dictionary containing the old settings.</dd>
</dl>
<p>seterrcall : Set a callback function for the ‘call’ mode.
geterr, geterrcall, errstate</p>
<p>The floating-point exceptions are defined in the IEEE 754 standard <a href="#id88"><span class="problematic" id="id17">[1]_</span></a>:</p>
<ul class="simple">
<li>Division by zero: infinite result obtained from finite numbers.</li>
<li>Overflow: result too large to be expressed.</li>
<li>Underflow: result so close to zero that some precision
was lost.</li>
<li>Invalid operation: result is not an expressible number, typically
indicates that a NaN was produced.</li>
</ul>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="http://en.wikipedia.org/wiki/IEEE_754">http://en.wikipedia.org/wiki/IEEE_754</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  <span class="c1">#seterr to known value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="go">{&#39;over&#39;: &#39;ignore&#39;, &#39;divide&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;,</span>
<span class="go"> &#39;under&#39;: &#39;ignore&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>  <span class="c1"># reset to default</span>
<span class="go">{&#39;over&#39;: &#39;raise&#39;, &#39;divide&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;,</span>
<span class="go"> &#39;under&#39;: &#39;ignore&#39;}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">30464</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">FloatingPointError</span>: <span class="n">overflow encountered in short_scalars</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;print&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;print&#39;, &#39;divide&#39;: &#39;print&#39;, &#39;invalid&#39;: &#39;print&#39;, &#39;under&#39;: &#39;print&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">32000</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Warning: overflow encountered in short_scalars</span>
<span class="go">30464</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.geterr">
<code class="descclassname">numpy.</code><code class="descname">geterr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current way of handling floating-point errors.</p>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>A dictionary with keys “divide”, “over”, “under”, and “invalid”,
whose values are from the strings “ignore”, “print”, “log”, “warn”,
“raise”, and “call”. The keys represent possible floating-point
exceptions, and the values define how these exceptions are handled.</dd>
</dl>
<p>geterrcall, seterr, seterrcall</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;,</span>
<span class="go">&#39;under&#39;: &#39;ignore&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">array([ NaN,   1.,   1.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldsettings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;raise&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;, &#39;under&#39;: &#39;warn&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="go">__main__:1: RuntimeWarning: invalid value encountered in divide</span>
<span class="go">array([ NaN,   1.,   1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.setbufsize">
<code class="descclassname">numpy.</code><code class="descname">setbufsize</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setbufsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the size of the buffer used in ufuncs.</p>
<dl class="docutils">
<dt>size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Size of buffer.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numpy.getbufsize">
<code class="descclassname">numpy.</code><code class="descname">getbufsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.getbufsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of the buffer used in ufuncs.</p>
<dl class="docutils">
<dt>getbufsize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Size of ufunc buffer in bytes.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numpy.seterrcall">
<code class="descclassname">numpy.</code><code class="descname">seterrcall</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterrcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the floating-point error callback function or log object.</p>
<p>There are two ways to capture floating-point error messages.  The first
is to set the error-handler to ‘call’, using <cite>seterr</cite>.  Then, set
the function to call using this function.</p>
<p>The second is to set the error-handler to ‘log’, using <cite>seterr</cite>.
Floating-point errors then trigger a call to the ‘write’ method of
the provided object.</p>
<dl class="docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">callable f(err, flag) or object with write method</span></dt>
<dd><p class="first">Function to call upon floating-point errors (‘call’-mode) or
object whose ‘write’ method is used to log such message (‘log’-mode).</p>
<p>The call function takes two arguments. The first is a string describing
the type of error (such as “divide by zero”, “overflow”, “underflow”,
or “invalid value”), and the second is the status flag.  The flag is a
byte, whose four least-significant bits indicate the type of error, one
of “divide”, “over”, “under”, “invalid”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">divide</span> <span class="n">over</span> <span class="n">under</span> <span class="n">invalid</span><span class="p">]</span>
</pre></div>
</div>
<p>In other words, <code class="docutils literal"><span class="pre">flags</span> <span class="pre">=</span> <span class="pre">divide</span> <span class="pre">+</span> <span class="pre">2*over</span> <span class="pre">+</span> <span class="pre">4*under</span> <span class="pre">+</span> <span class="pre">8*invalid</span></code>.</p>
<p class="last">If an object is provided, its write method should take one argument,
a string.</p>
</dd>
</dl>
<dl class="docutils">
<dt>h <span class="classifier-delimiter">:</span> <span class="classifier">callable, log instance or None</span></dt>
<dd>The old error handler.</dd>
</dl>
<p>seterr, geterr, geterrcall</p>
<p>Callback upon error:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">saved_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">Floating point error (divide by zero), with flag 1</span>
<span class="go">array([ Inf,  Inf,  Inf])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">saved_handler</span><span class="p">)</span>
<span class="go">&lt;function err_handler at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">save_err</span><span class="p">)</span>
<span class="go">{&#39;over&#39;: &#39;call&#39;, &#39;divide&#39;: &#39;call&#39;, &#39;invalid&#39;: &#39;call&#39;, &#39;under&#39;: &#39;call&#39;}</span>
</pre></div>
</div>
<p>Log error message:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Log</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LOG: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">Log</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">saved_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">LOG: Warning: divide by zero encountered in divide</span>

<span class="go">array([ Inf,  Inf,  Inf])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">saved_handler</span><span class="p">)</span>
<span class="go">&lt;__main__.Log object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">save_err</span><span class="p">)</span>
<span class="go">{&#39;over&#39;: &#39;log&#39;, &#39;divide&#39;: &#39;log&#39;, &#39;invalid&#39;: &#39;log&#39;, &#39;under&#39;: &#39;log&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.geterrcall">
<code class="descclassname">numpy.</code><code class="descname">geterrcall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterrcall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current callback function used on floating-point errors.</p>
<p>When the error handling for a floating-point error (one of “divide”,
“over”, “under”, or “invalid”) is set to ‘call’ or ‘log’, the function
that is called or the log instance that is written to is returned by
<cite>geterrcall</cite>. This function or log instance has been set with
<cite>seterrcall</cite>.</p>
<dl class="docutils">
<dt>errobj <span class="classifier-delimiter">:</span> <span class="classifier">callable, log instance or None</span></dt>
<dd>The current error handler. If no handler was set through <cite>seterrcall</cite>,
<code class="docutils literal"><span class="pre">None</span></code> is returned.</dd>
</dl>
<p>seterrcall, seterr, geterr</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span>  <span class="c1"># we did not yet set a handler, returns None</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldsettings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oldhandler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.0</span>
<span class="go">Floating point error (divide by zero), with flag 1</span>
<span class="go">array([ Inf,  Inf,  Inf])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cur_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur_handler</span> <span class="ow">is</span> <span class="n">err_handler</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.errstate">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">errstate</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.errstate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Context manager for floating-point error handling.</p>
<p>Using an instance of <cite>errstate</cite> as a context manager allows statements in
that context to execute with a known error handling behavior. Upon entering
the context the error handling is set with <cite>seterr</cite> and <cite>seterrcall</cite>, and
upon exiting it is reset to what it was before.</p>
<dl class="docutils">
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">{divide, over, under, invalid}</span></dt>
<dd>Keyword arguments. The valid keywords are the possible floating-point
exceptions. Each keyword should have a string value that defines the
treatment for the particular error. Possible values are
{‘ignore’, ‘warn’, ‘raise’, ‘call’, ‘print’, ‘log’}.</dd>
</dl>
<p>seterr, geterr, seterrcall, geterrcall</p>
<p>The <code class="docutils literal"><span class="pre">with</span></code> statement was introduced in Python 2.5, and can only be used
there by importing it: <code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">with_statement</span></code>. In
earlier Python versions the <code class="docutils literal"><span class="pre">with</span></code> statement is not available.</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span>  <span class="c1"># use &#39;with&#39; in Python 2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>  <span class="c1"># Set error handling to known state.</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.</span>
<span class="go">array([ NaN,  Inf,  Inf])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.</span>
<span class="gp">...</span>
<span class="go">__main__:2: RuntimeWarning: divide by zero encountered in divide</span>
<span class="go">array([ NaN,  Inf,  Inf])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">FloatingPointError</span>: <span class="n">invalid value encountered in sqrt</span>
</pre></div>
</div>
<p>Outside the context the error handling behavior has not changed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;,</span>
<span class="go">&#39;under&#39;: &#39;ignore&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.flatnonzero">
<code class="descclassname">numpy.</code><code class="descname">flatnonzero</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flatnonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices that are non-zero in the flattened version of a.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
</dl>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array, containing the indices of the elements of <cite>a.ravel()</cite>
that are non-zero.</dd>
</dl>
<p>nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([-2, -1,  0,  1,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 1, 3, 4])</span>
</pre></div>
</div>
<p>Use the indices of the non-zero elements as an index array to extract
these elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([-2, -1,  1,  2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="numpy.ComplexWarning">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">ComplexWarning</code><a class="headerlink" href="#numpy.ComplexWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeWarning</span></code></p>
<p>The warning raised when casting a complex dtype to a real dtype.</p>
<p>As implemented, casting a complex number to a real discards its imaginary
part, but this behavior may not be what the user actually wants.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.full">
<code class="descclassname">numpy.</code><code class="descname">full</code><span class="sig-paren">(</span><em>shape</em>, <em>fill_value</em>, <em>dtype=None</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with <cite>fill_value</cite>.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Shape of the new array, e.g., <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">2</span></code>.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Fill value.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><dl class="first last docutils">
<dt>The desired data-type for the array  The default, <cite>None</cite>, means</dt>
<dd><cite>np.array(fill_value).dtype</cite>.</dd>
</dl>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of <cite>fill_value</cite> with the given shape, dtype, and order.</dd>
</dl>
<p>full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array([[ inf,  inf],</span>
<span class="go">       [ inf,  inf]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 10],</span>
<span class="go">       [10, 10]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.full_like">
<code class="descclassname">numpy.</code><code class="descname">full_like</code><span class="sig-paren">(</span><em>a</em>, <em>fill_value</em>, <em>dtype=None</em>, <em>order='K'</em>, <em>subok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.full_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full array with the same shape and type as a given array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Fill value.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Overrides the data type of the result.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt>
<dd>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional.</span></dt>
<dd>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of <cite>fill_value</cite> with the same shape and type as <cite>a</cite>.</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([ nan,  nan,  nan,  nan,  nan,  nan])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.matmul">
<code class="descclassname">numpy.</code><code class="descname">matmul</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix product of two arrays.</p>
<p>The behavior depends on the arguments in the following way.</p>
<ul class="simple">
<li>If both arguments are 2-D they are multiplied like conventional
matrices.</li>
<li>If either argument is N-D, N &gt; 2, it is treated as a stack of
matrices residing in the last two indexes and broadcast accordingly.</li>
<li>If the first argument is 1-D, it is promoted to a matrix by
prepending a 1 to its dimensions. After matrix multiplication
the prepended 1 is removed.</li>
<li>If the second argument is 1-D, it is promoted to a matrix by
appending a 1 to its dimensions. After matrix multiplication
the appended 1 is removed.</li>
</ul>
<p>Multiplication by a scalar is not allowed, use <code class="docutils literal"><span class="pre">*</span></code> instead. Note that
multiplying a stack of matrices with a vector will result in a stack of
vectors, but matmul will not recognize it as such.</p>
<p><code class="docutils literal"><span class="pre">matmul</span></code> differs from <code class="docutils literal"><span class="pre">dot</span></code> in two important ways.</p>
<ul class="simple">
<li>Multiplication by scalars is not allowed.</li>
<li>Stacks of matrices are broadcast together as if the matrices
were elements.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is preliminary and included in NumPy 1.10.0 for testing
and documentation. Its semantics will not change, but the number and
order of the optional arguments will.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>First argument.</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Second argument.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
1-D arrays then a scalar is returned; otherwise an array is
returned.  If <cite>out</cite> is given, then it is returned.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd><p class="first">If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
<p class="last">If scalar value is passed.</p>
</dd>
</dl>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
dot : alternative matrix product with different broadcasting rules.</p>
<p>The matmul function implements the semantics of the <cite>&#64;</cite> operator introduced
in Python 3.5 following PEP465.</p>
<p>For 2-D arrays it is the matrix product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>For 2-D mixed with 1-D, the result is the usual.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Broadcasting is conventional for stacks of arrays</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">98</span>
</pre></div>
</div>
<p>Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>Scalar multiplication raises an error.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Scalar operands are not allowed, use &#39;*&#39; instead</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.shares_memory">
<code class="descclassname">numpy.</code><code class="descname">shares_memory</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>max_work=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.shares_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two arrays share memory</p>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input arrays</dd>
<dt>max_work <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">Effort to spend on solving the overlap problem (maximum number
of candidate solutions to consider). The following special
values are recognized:</p>
<dl class="last docutils">
<dt>max_work=MAY_SHARE_EXACT  (default)</dt>
<dd>The problem is solved exactly. In this case, the function returns
True only if there is an element shared between the arrays.</dd>
<dt>max_work=MAY_SHARE_BOUNDS</dt>
<dd>Only the memory bounds of a and b are checked.</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>numpy.TooHardError</dt>
<dd>Exceeded max_work.</dd>
</dl>
<p>out : bool</p>
<p>may_share_memory</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.may_share_memory">
<code class="descclassname">numpy.</code><code class="descname">may_share_memory</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>max_work=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.may_share_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two arrays might share memory</p>
<p>A return of True does not necessarily mean that the two arrays
share any element.  It just means that they <em>might</em>.</p>
<p>Only the memory bounds of a and b are checked by default.</p>
<dl class="docutils">
<dt>a, b <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input arrays</dd>
<dt>max_work <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Effort to spend on solving the overlap problem.  See
<cite>shares_memory</cite> for details.  Default for <code class="docutils literal"><span class="pre">may_share_memory</span></code>
is to do a bounds check.</dd>
</dl>
<p>out : bool</p>
<p>shares_memory</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="numpy.TooHardError">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">TooHardError</code><a class="headerlink" href="#numpy.TooHardError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="numpy.AxisError">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">AxisError</code><span class="sig-paren">(</span><em>axis</em>, <em>ndim=None</em>, <em>msg_prefix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.AxisError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code>, <code class="xref py py-class docutils literal"><span class="pre">IndexError</span></code></p>
<p>Axis supplied was invalid.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.alen">
<code class="descclassname">numpy.</code><code class="descname">alen</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.alen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the first dimension of the input array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>alen <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Length of the first dimension of <cite>a</cite>.</dd>
</dl>
<p>shape, size</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">alen</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.all">
<code class="descclassname">numpy.</code><code class="descname">all</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a logical AND reduction is performed.
The default (<cite>axis</cite> = <cite>None</cite>) is to perform a logical AND over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code class="docutils literal"><span class="pre">dtype(out)</span></code> is float, the result
will consist of 0.0’s and 1.0’s).  See <cite>doc.ufuncs</cite> (Section
“Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>all</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>all <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, bool</span></dt>
<dd>A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>                             
<span class="go">(28293632, 28293632, array([ True]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.alltrue">
<code class="descclassname">numpy.</code><code class="descname">alltrue</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.alltrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all elements of input array are true.</p>
<p>numpy.all : Equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.amax">
<code class="descclassname">numpy.</code><code class="descname">amax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.amax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amax</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The minimum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>amax <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>amin :</dt>
<dd>The minimum value of an array along a given axis, propagating any NaNs.</dd>
<dt>nanmax :</dt>
<dd>The maximum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>maximum :</dt>
<dd>Element-wise maximum of two arrays, propagating any NaNs.</dd>
<dt>fmax :</dt>
<dd>Element-wise maximum of two arrays, ignoring any NaNs.</dd>
<dt>argmax :</dt>
<dd>Return the indices of the maximum values.</dd>
</dl>
<p>nanmin, minimum, fmin</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.amin">
<code class="descclassname">numpy.</code><code class="descname">amin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.amin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>amax :</dt>
<dd>The maximum value of an array along a given axis, propagating any NaNs.</dd>
<dt>nanmin :</dt>
<dd>The minimum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>minimum :</dt>
<dd>Element-wise minimum of two arrays, propagating any NaNs.</dd>
<dt>fmin :</dt>
<dd>Element-wise minimum of two arrays, ignoring any NaNs.</dd>
<dt>argmin :</dt>
<dd>Return the indices of the minimum values.</dd>
</dl>
<p>nanmax, maximum, fmax</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis</span>
<span class="go">array([0, 2])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal"><span class="pre">default</span></code> argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.any">
<code class="descclassname">numpy.</code><code class="descname">any</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal"><span class="pre">None</span></code></p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a logical OR reduction is performed.
The default (<cite>axis</cite> = <cite>None</cite>) is to perform a logical OR over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of <cite>a</cite>).
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>any</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>any <span class="classifier-delimiter">:</span> <span class="classifier">bool or ndarray</span></dt>
<dd>A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.any : equivalent method</p>
<p>all : Test whether all elements along a given axis evaluate to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">,</span> <span class="n">o</span>
<span class="go">(array([ True]), array([ True]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check now that z is a reference to o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># identity of z and o              </span>
<span class="go">(191614240, 191614240)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.argmax">
<code class="descclassname">numpy.</code><code class="descname">argmax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the maximum values along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>By default, the index is into the flattened array, otherwise
along the specified axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</dd>
</dl>
<p>ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.</p>
<p>In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<p>Indexes of the maximal elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 5, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.argmin">
<code class="descclassname">numpy.</code><code class="descname">argmin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the minimum values along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>By default, the index is into the flattened array, otherwise
along the specified axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</dd>
</dl>
<p>ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.</p>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
</pre></div>
</div>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 1, 2, 3, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.argpartition">
<code class="descclassname">numpy.</code><code class="descname">argpartition</code><span class="sig-paren">(</span><em>a</em>, <em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an indirect partition along the given axis using the
algorithm specified by the <cite>kind</cite> keyword. It returns an array of
indices of the same shape as <cite>a</cite> that index data along the given
axis in partitioned order.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to sort.</dd>
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The k-th element will be in its
final sorted position and all smaller elements will be moved
before it and all larger elements behind it. The order all
elements in the partitions is undefined. If provided with a
sequence of k-th it will partition all of them into their sorted
position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. The default is -1 (the last axis). If
None, the flattened array is used.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc. A single
field can be specified as a string, and not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, int</span></dt>
<dd>Array of indices that partition <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal"><span class="pre">a[index_array]</span></code> yields a partitioned <cite>a</cite>.
More generally, <code class="docutils literal"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the partitioned <cite>a</cite>, irrespective of dimensionality.</dd>
</dl>
<p>partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort</p>
<p>See <cite>partition</cite> for notes on the different selection algorithms.</p>
<p>One dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.argsort">
<code class="descclassname">numpy.</code><code class="descname">argsort</code><span class="sig-paren">(</span><em>a</em>, <em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <cite>kind</cite> keyword. It returns an array of indices of the same shape as
<cite>a</cite> that index data along the given axis in sorted order.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to sort.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, int</span></dt>
<dd>Array of indices that sort <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.
More generally, <code class="docutils literal"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the sorted <cite>a</cite>, irrespective of dimensionality.</dd>
</dl>
<p>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.</p>
<p>See <cite>sort</cite> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <cite>argsort</cite> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>One dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<p>Two-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sorts along first axis (down)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts along last axis (across)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [0, 1]])</span>
</pre></div>
</div>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>  <span class="c1"># same as np.sort(x, axis=None)</span>
<span class="go">array([0, 2, 2, 3])</span>
</pre></div>
</div>
<p>Sorting with keys:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1, 0), (0, 1)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.around">
<code class="descclassname">numpy.</code><code class="descname">around</code><span class="sig-paren">(</span><em>a</em>, <em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.around" title="Permalink to this definition">¶</a></dt>
<dd><p>Evenly round to the given number of decimals.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>decimals <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See <cite>doc.ufuncs</cite> (Section
“Output arguments”) for details.</dd>
</dl>
<dl class="docutils">
<dt>rounded_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">An array of the same type as <cite>a</cite>, containing the rounded values.
Unless <cite>out</cite> was specified, a new array is created.  A reference to
the result is returned.</p>
<p class="last">The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
</dd>
</dl>
<p>ndarray.round : equivalent method</p>
<p>ceil, fix, floor, rint, trunc</p>
<p>For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
to the inexact representation of decimal fractions in the IEEE
floating point standard <a href="#id89"><span class="problematic" id="id19">[1]_</span></a> and errors introduced when scaling
by powers of ten.</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>“Lecture Notes on the Status of  IEEE 754”, William Kahan,
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>“How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?”, William Kahan,
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/Mindless.pdf">http://www.cs.berkeley.edu/~wkahan/Mindless.pdf</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">])</span>
<span class="go">array([ 0.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.4,  1.6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span> <span class="c1"># rounds to nearest even value</span>
<span class="go">array([ 0.,  2.,  2.,  4.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ndarray of ints is returned</span>
<span class="go">array([ 1,  2,  3, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0,  0,  0, 10])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.choose">
<code class="descclassname">numpy.</code><code class="descname">choose</code><span class="sig-paren">(</span><em>a</em>, <em>choices</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from an index array and a set of arrays to choose from.</p>
<p>First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
<cite>numpy.lib.index_tricks</cite>):</p>
<p><code class="docutils literal"><span class="pre">np.choose(a,c)</span> <span class="pre">==</span> <span class="pre">np.array([c[a[I]][I]</span> <span class="pre">for</span> <span class="pre">I</span> <span class="pre">in</span> <span class="pre">ndi.ndindex(a.shape)])</span></code>.</p>
<p>But this omits some subtleties.  Here is a fully general summary:</p>
<p>Given an “index” array (<cite>a</cite>) of integers and a sequence of <cite>n</cite> arrays
(<cite>choices</cite>), <cite>a</cite> and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these <em>Ba</em> and <em>Bchoices[i], i =
0,…,n-1</em> we have that, necessarily, <code class="docutils literal"><span class="pre">Ba.shape</span> <span class="pre">==</span> <span class="pre">Bchoices[i].shape</span></code>
for each <cite>i</cite>.  Then, a new array with shape <code class="docutils literal"><span class="pre">Ba.shape</span></code> is created as
follows:</p>
<ul class="simple">
<li>if <code class="docutils literal"><span class="pre">mode=raise</span></code> (the default), then, first of all, each element of
<cite>a</cite> (and thus <cite>Ba</cite>) must be in the range <cite>[0, n-1]</cite>; now, suppose that
<cite>i</cite> (in that range) is the value at the <cite>(j0, j1, …, jm)</cite> position
in <cite>Ba</cite> - then the value at the same position in the new array is the
value in <cite>Bchoices[i]</cite> at that same position;</li>
<li>if <code class="docutils literal"><span class="pre">mode=wrap</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; modular arithmetic is used to map integers outside the range
<cite>[0, n-1]</cite> back into that range; and then the new array is constructed
as above;</li>
<li>if <code class="docutils literal"><span class="pre">mode=clip</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; negative integers are mapped to 0; values greater than <cite>n-1</cite>
are mapped to <cite>n-1</cite>; and then the new array is constructed as above.</li>
</ul>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">int array</span></dt>
<dd>This array must contain integers in <cite>[0, n-1]</cite>, where <cite>n</cite> is the number
of choices, unless <code class="docutils literal"><span class="pre">mode=wrap</span></code> or <code class="docutils literal"><span class="pre">mode=clip</span></code>, in which cases any
integers are permissible.</dd>
<dt>choices <span class="classifier-delimiter">:</span> <span class="classifier">sequence of arrays</span></dt>
<dd>Choice arrays. <cite>a</cite> and all of the choices must be broadcastable to the
same shape.  If <cite>choices</cite> is itself an array (not recommended), then
its outermost dimension (i.e., the one corresponding to
<code class="docutils literal"><span class="pre">choices.shape[0]</span></code>) is taken as defining the “sequence”.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’ (default), ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how indices outside <cite>[0, n-1]</cite> will be treated:</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘raise’ : an exception is raised</li>
<li>‘wrap’ : value becomes value mod <cite>n</cite></li>
<li>‘clip’ : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</li>
</ul>
</div></blockquote>
</dd>
</dl>
<dl class="docutils">
<dt>merged_array <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>The merged result.</dd>
</dl>
<dl class="docutils">
<dt>ValueError: shape mismatch</dt>
<dd>If <cite>a</cite> and each choice array are not all broadcastable to the same
shape.</dd>
</dl>
<p>ndarray.choose : equivalent method</p>
<p>To reduce the chance of misinterpretation, even though the following
“abuse” is nominally supported, <cite>choices</cite> should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
<span class="gp">... </span>  <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span>
<span class="gp">... </span><span class="c1"># the first element of the result will be the first element of the</span>
<span class="gp">... </span><span class="c1"># third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="gp">... </span><span class="c1"># will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="gp">... </span><span class="c1"># 31, etc.</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to 3 (4-1)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because there are 4 choice arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to (4 mod 4)</span>
<span class="go">array([20,  1, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># i.e., 0</span>
</pre></div>
</div>
<p>A couple examples illustrating how choose broadcasts:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>
<span class="go">array([[ 10, -10,  10],</span>
<span class="go">       [-10,  10, -10],</span>
<span class="go">       [ 10, -10,  10]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With thanks to Anne Archibald</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="c1"># result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span>
<span class="go">array([[[ 1,  1,  1,  1,  1],</span>
<span class="go">        [ 2,  2,  2,  2,  2],</span>
<span class="go">        [ 3,  3,  3,  3,  3]],</span>
<span class="go">       [[-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.clip">
<code class="descclassname">numpy.</code><code class="descname">clip</code><span class="sig-paren">(</span><em>a</em>, <em>a_min</em>, <em>a_max</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing elements to clip.</dd>
<dt>a_min <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like or <cite>None</cite></span></dt>
<dd>Minimum value. If <cite>None</cite>, clipping is not performed on lower
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
<cite>None</cite>.</dd>
<dt>a_max <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like or <cite>None</cite></span></dt>
<dd>Maximum value. If <cite>None</cite>, clipping is not performed on upper
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
<cite>None</cite>. If <cite>a_min</cite> or <cite>a_max</cite> are array_like, then the three
arrays will be broadcasted to match their shapes.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>The results will be placed in this array. It may be the input
array for in-place clipping.  <cite>out</cite> must be of the right shape
to hold the output.  Its type is preserved.</dd>
</dl>
<dl class="docutils">
<dt>clipped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the elements of <cite>a</cite>, but where values
&lt; <cite>a_min</cite> are replaced with <cite>a_min</cite>, and those &gt; <cite>a_max</cite>
with <cite>a_max</cite>.</dd>
</dl>
<p>numpy.doc.ufuncs : Section “Output arguments”</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.compress">
<code class="descclassname">numpy.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>condition</em>, <em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return selected slices of an array along given axis.</p>
<p>When working along a given axis, a slice along that axis is returned in
<cite>output</cite> for each index where <cite>condition</cite> evaluates to True. When
working on a 1-D array, <cite>compress</cite> is equivalent to <cite>extract</cite>.</p>
<dl class="docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="classifier">1-D array of bools</span></dt>
<dd>Array that selects which entries to return. If len(condition)
is less than the size of <cite>a</cite> along the given axis, then output is
truncated to the length of the condition array.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array from which to extract a part.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to take slices. If None (default), work on the
flattened array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output array.  Its type is preserved and it must be of the right
shape to hold the output.</dd>
</dl>
<dl class="docutils">
<dt>compressed_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <cite>a</cite> without the slices along axis for which <cite>condition</cite>
is false.</dd>
</dl>
<p>take, choose, diag, diagonal, select
ndarray.compress : Equivalent method in ndarray
np.extract: Equivalent method when working on 1-D arrays
numpy.doc.ufuncs : Section “Output arguments”</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [4],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
<p>Working on the flattened array does not return slices along an axis but
selects elements.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.cumprod">
<code class="descclassname">numpy.</code><code class="descname">cumprod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative product is computed.  By default
the input is flattened.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</dd>
</dl>
<dl class="docutils">
<dt>cumprod <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</dd>
</dl>
<p>numpy.doc.ufuncs : Section “Output arguments”</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2</span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output</span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.cumproduct">
<code class="descclassname">numpy.</code><code class="descname">cumproduct</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product over the given axis.</p>
<p>cumprod : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.cumsum">
<code class="descclassname">numpy.</code><code class="descname">cumsum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <cite>doc.ufuncs</cite>
(Section “Output arguments”) for more details.</dd>
</dl>
<dl class="docutils">
<dt>cumsum_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray.</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to <cite>out</cite> is returned. The
result has the same size as <cite>a</cite>, and the same shape as <cite>a</cite> if
<cite>axis</cite> is not None or <cite>a</cite> is a 1-d array.</dd>
</dl>
<p>sum : Sum array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>diff :  Calculate the n-th discrete difference along given axis.</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>     <span class="c1"># specifies type of output value(s)</span>
<span class="go">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># sum over rows for each of the 3 columns</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [5, 7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># sum over columns for each of the 2 rows</span>
<span class="go">array([[ 1,  3,  6],</span>
<span class="go">       [ 4,  9, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.diagonal">
<code class="descclassname">numpy.</code><code class="descname">diagonal</code><span class="sig-paren">(</span><em>a</em>, <em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals.</p>
<p>If <cite>a</cite> is 2-D, returns the diagonal of <cite>a</cite> with the given offset,
i.e., the collection of elements of the form <code class="docutils literal"><span class="pre">a[i,</span> <span class="pre">i+offset]</span></code>.  If
<cite>a</cite> has more than two dimensions, then the axes specified by <cite>axis1</cite>
and <cite>axis2</cite> are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing <cite>axis1</cite> and <cite>axis2</cite> and appending an index to the right equal
to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.</p>
<p>If you don’t write to the array returned by this function, then you can
just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use <code class="docutils literal"><span class="pre">np.diagonal(a).copy()</span></code> instead
of just <code class="docutils literal"><span class="pre">np.diagonal(a)</span></code>. This will work with both past and future
versions of NumPy.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal.  Can be positive or
negative.  Defaults to main diagonal (0).</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis to be used as the first axis of the 2-D sub-arrays from which
the diagonals should be taken.  Defaults to first axis (0).</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis to be used as the second axis of the 2-D sub-arrays from
which the diagonals should be taken. Defaults to second axis (1).</dd>
</dl>
<dl class="docutils">
<dt>array_of_diagonals <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">If <cite>a</cite> is 2-D, then a 1-D array containing the diagonal and of the
same type as <cite>a</cite> is returned unless <cite>a</cite> is a <cite>matrix</cite>, in which case
a 1-D array rather than a (2-D) <cite>matrix</cite> is returned in order to
maintain backward compatibility.</p>
<p class="last">If <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, then the dimensions specified by <cite>axis1</cite> and <cite>axis2</cite>
are removed, and a new axis inserted at the end corresponding to the
diagonal.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the dimension of <cite>a</cite> is less than 2.</dd>
</dl>
<p>diag : MATLAB work-a-like for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="go">array([0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<p>A 3-D example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># Main diagonals of two arrays created by skipping</span>
<span class="gp">... </span>           <span class="mi">0</span><span class="p">,</span> <span class="c1"># across the outer(left)-most axis last and</span>
<span class="gp">... </span>           <span class="mi">1</span><span class="p">)</span> <span class="c1"># the &quot;middle&quot; (row) axis first.</span>
<span class="go">array([[0, 6],</span>
<span class="go">       [1, 7]])</span>
</pre></div>
</div>
<p>The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are “packed” in rows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># main diagonal is [0 6]</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># main diagonal is [1 7]</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.mean">
<code class="descclassname">numpy.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for floating point inputs, it is the same as the
input dtype.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.
See <cite>doc.ufuncs</cite> for details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>mean</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</dd>
</dl>
<p>average : Weighted average
std, var, nanmean, nanstd, nanvar</p>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for <cite>float32</cite> (see
example below).  Specifying a higher-precision accumulator using the
<cite>dtype</cite> keyword can alleviate this issue.</p>
<p>By default, <cite>float16</cite> results are computed using <cite>float32</cite> intermediates
for extra precision.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.5,  3.5])</span>
</pre></div>
</div>
<p>In single precision, <cite>mean</cite> can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.54999924</span>
</pre></div>
</div>
<p>Computing the mean in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.55000000074505806</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ndim">
<code class="descclassname">numpy.</code><code class="descname">ndim</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.  If it is not already an ndarray, a conversion is
attempted.</dd>
</dl>
<dl class="docutils">
<dt>number_of_dimensions <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of dimensions in <cite>a</cite>.  Scalars are zero-dimensional.</dd>
</dl>
<p>ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nonzero">
<code class="descclassname">numpy.</code><code class="descname">nonzero</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <cite>a</cite>,
containing the indices of the non-zero elements in that
dimension. The values in <cite>a</cite> are always tested and returned in
row-major, C-style order. The corresponding non-zero
values can be obtained with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
</pre></div>
</div>
<p>To group the indices by element, rather than dimension, use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">transpose</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>The result of this is always a 2-D array, with a row for
each non-zero element.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>tuple_of_arrays <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Indices of elements that are non-zero.</dd>
</dl>
<dl class="docutils">
<dt>flatnonzero :</dt>
<dd>Return indices that are non-zero in the flattened version of the input
array.</dd>
<dt>ndarray.nonzero :</dt>
<dd>Equivalent ndarray method.</dd>
<dt>count_nonzero :</dt>
<dd>Counts the number of non-zero elements in the input array.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 0, 0],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [1, 1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([1, 2, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [2, 1])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">nonzero</span></code> method of the boolean array can also be called.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.partition">
<code class="descclassname">numpy.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>a</em>, <em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a partitioned copy of an array.</p>
<p>Creates a copy of the array with its elements rearranged in such a
way that the value of the element in k-th position is in the
position it would be in a sorted array. All elements smaller than
the k-th element are moved before this element and all equal or
greater are moved behind it. The ordering of the elements in the two
partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The k-th value of the element
will be in its final sorted position and all smaller elements
will be moved before it and all equal or greater elements behind
it. The order of all elements in the partitions is undefined. If
provided with a sequence of k-th it will partition all elements
indexed by k-th  of them into their sorted position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc.  A single
field can be specified as a string.  Not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>partitioned_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting</p>
<p>The various selection algorithms are characterized by their average
speed, worst case performance, work space size, and whether they are
stable. A stable sort keeps items with the same key in the same
relative order. The available algorithms have the following
properties:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="13%" />
<col width="23%" />
<col width="21%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">kind</th>
<th class="head">speed</th>
<th class="head">worst case</th>
<th class="head">work space</th>
<th class="head">stable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘introselect’</td>
<td>1</td>
<td>O(n)</td>
<td>0</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently,
partitioning along the last axis is faster and uses less space than
partitioning along any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the
real and imaginary parts are non-nan then the order is determined by
the real parts except when they are equal, in which case the order
is determined by the imaginary parts.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.prod">
<code class="descclassname">numpy.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>prod</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The starting value for this product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>product_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see <cite>dtype</cite> parameter above.</span></dt>
<dd>An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</dd>
</dl>
<p>ndarray.prod : equivalent method
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">16</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>By default, calculate the product of all elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.product">
<code class="descclassname">numpy.</code><code class="descname">product</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>prod : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.ptp">
<code class="descclassname">numpy.</code><code class="descname">ptp</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Range of values (maximum - minimum) along an axis.</p>
<p>The name of the function comes from the acronym for ‘peak to peak’.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis along which to find the peaks.  By default, flatten the
array.  <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>ptp</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ptp <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result, unless <cite>out</cite> was
specified, in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.put">
<code class="descclassname">numpy.</code><code class="descname">put</code><span class="sig-paren">(</span><em>a</em>, <em>ind</em>, <em>v</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces specified elements of an array with given values.</p>
<p>The indexing works on the flattened target array. <cite>put</cite> is roughly
equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</pre></div>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Target array.</dd>
<dt>ind <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Target indices, interpreted as integers.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to place in <cite>a</cite> at target indices. If <cite>v</cite> is shorter than
<cite>ind</cite> it will be repeated as necessary.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li>‘raise’ – raise an error (default)</li>
<li>‘wrap’ – wrap around</li>
<li>‘clip’ – clip to the range</li>
</ul>
<p class="last">‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
<p>putmask, place
put_along_axis : Put elements by matching the array and the index arrays</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">44</span><span class="p">,</span> <span class="o">-</span><span class="mi">55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-44,   1, -55,   3,   4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0,  1,  2,  3, -5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.rank">
<code class="descclassname">numpy.</code><code class="descname">rank</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of dimensions of an array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is deprecated in NumPy 1.9 to avoid confusion with
<cite>numpy.linalg.matrix_rank</cite>. The <code class="docutils literal"><span class="pre">ndim</span></code> attribute or function
should be used instead.</p>
</div>
<p>ndim : equivalent non-deprecated function</p>
<p>In the old Numeric package, <cite>rank</cite> was the term used for the number of
dimensions, but in NumPy <cite>ndim</cite> is used instead.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.ravel">
<code class="descclassname">numpy.</code><code class="descname">ravel</code><span class="sig-paren">(</span><em>a</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.  The elements in <cite>a</cite> are read in the order specified by
<cite>order</cite>, and packed as a 1-D array.</dd>
</dl>
<p>order : {‘C’,’F’, ‘A’, ‘K’}, optional</p>
<blockquote>
<div>The elements of <cite>a</cite> are read using this index order. ‘C’ means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  ‘F’ means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  ‘A’ means to read the elements in
Fortran-like index order if <cite>a</cite> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  ‘K’ means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, ‘C’
index order is used.</div></blockquote>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>y is an array of the same subtype as <cite>a</cite>, with shape <code class="docutils literal"><span class="pre">(a.size,)</span></code>.
Note that matrices are special cased for backward compatibility, if <cite>a</cite>
is a matrix, then y is a 1-D ndarray.</dd>
</dl>
<p>ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array</p>
<blockquote>
<div>in row-major order.</div></blockquote>
<p>ndarray.reshape : Change the shape of an array without changing its data.</p>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code class="docutils literal"><span class="pre">arr.reshape(-1)</span></code>
may be preferable.</p>
<p>It is equivalent to <code class="docutils literal"><span class="pre">reshape(-1,</span> <span class="pre">order=order)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">order</span></code> is ‘A’, it will preserve the array’s ‘C’ or ‘F’ ordering:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">order</span></code> is ‘K’, it will preserve orderings that are neither ‘C’
nor ‘F’, but won’t reverse axes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[ 0,  2,  4],</span>
<span class="go">        [ 1,  3,  5]],</span>
<span class="go">       [[ 6,  8, 10],</span>
<span class="go">        [ 7,  9, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.repeat">
<code class="descclassname">numpy.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>a</em>, <em>repeats</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>repeats <span class="classifier-delimiter">:</span> <span class="classifier">int or array of ints</span></dt>
<dd>The number of repetitions for each element.  <cite>repeats</cite> is broadcasted
to fit the shape of the given axis.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</dd>
</dl>
<dl class="docutils">
<dt>repeated_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array which has the same shape as <cite>a</cite>, except along
the given axis.</dd>
</dl>
<p>tile : Tile an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.reshape">
<code class="descclassname">numpy.</code><code class="descname">reshape</code><span class="sig-paren">(</span><em>a</em>, <em>newshape</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a new shape to an array without changing its data.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be reshaped.</dd>
<dt>newshape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>The new shape should be compatible with the original shape. If
an integer, then the result will be a 1-D array of that length.
One shape dimension can be -1. In this case, the value is
inferred from the length of the array and remaining dimensions.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’}, optional</span></dt>
<dd>Read the elements of <cite>a</cite> using this index order, and place the
elements into the reshaped array using this index order.  ‘C’
means to read / write the elements using C-like index order,
with the last axis index changing fastest, back to the first
axis index changing slowest. ‘F’ means to read / write the
elements using Fortran-like index order, with the first index
changing fastest, and the last index changing slowest. Note that
the ‘C’ and ‘F’ options take no account of the memory layout of
the underlying array, and only refer to the order of indexing.
‘A’ means to read / write the elements in Fortran-like index
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.</dd>
</dl>
<dl class="docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>This will be a new view object if possible; otherwise, it will
be a copy.  Note there is no guarantee of the <em>memory layout</em> (C- or
Fortran- contiguous) of the returned array.</dd>
</dl>
<p>ndarray.reshape : Equivalent method.</p>
<p>It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go"># A transpose makes the array non-contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="go"># Taking a view makes it possible to modify the shape without modifying</span>
<span class="go"># the initial object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">AttributeError: incompatible shape for a non-contiguous array</span>
</pre></div>
</div>
<p>The <cite>order</cite> keyword gives the index ordering both for <em>fetching</em> the values
from <cite>a</cite>, and then <em>placing</em> the values into the output array.
For example, let’s say you have an array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
</pre></div>
</div>
<p>You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># C-like index ordering</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># equivalent to C ravel then C reshape</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1"># Fortran-like index ordering</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>       <span class="c1"># the unspecified value is inferred to be 2</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.resize">
<code class="descclassname">numpy.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>a</em>, <em>new_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new
array is filled with repeated copies of <cite>a</cite>.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of <cite>a</cite>.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be resized.</dd>
<dt>new_shape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span></dt>
<dd>Shape of resized array.</dd>
</dl>
<dl class="docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The new array is formed from the data in the old array, repeated
if necessary to fill out the required number of elements.  The
data are repeated in the order that they are stored in memory.</dd>
</dl>
<p>ndarray.resize : resize an array in-place.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3],</span>
<span class="go">       [0, 1, 2, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.round_">
<code class="descclassname">numpy.</code><code class="descname">round_</code><span class="sig-paren">(</span><em>a</em>, <em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.round_" title="Permalink to this definition">¶</a></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>Refer to <cite>around</cite> for full documentation.</p>
<p>around : equivalent function</p>
</dd></dl>

<dl class="function">
<dt id="numpy.searchsorted">
<code class="descclassname">numpy.</code><code class="descname">searchsorted</code><span class="sig-paren">(</span><em>a</em>, <em>v</em>, <em>side='left'</em>, <em>sorter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements should be inserted to maintain order.</p>
<p>Find the indices into a sorted array <cite>a</cite> such that, if the
corresponding elements in <cite>v</cite> were inserted before the indices, the
order of <cite>a</cite> would be preserved.</p>
<p>Assuming that <cite>a</cite> is sorted:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>side</cite></th>
<th class="head">returned index <cite>i</cite> satisfies</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>left</td>
<td><code class="docutils literal"><span class="pre">a[i-1]</span> <span class="pre">&lt;</span> <span class="pre">v</span> <span class="pre">&lt;=</span> <span class="pre">a[i]</span></code></td>
</tr>
<tr class="row-odd"><td>right</td>
<td><code class="docutils literal"><span class="pre">a[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">a[i]</span></code></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like</span></dt>
<dd>Input array. If <cite>sorter</cite> is None, then it must be sorted in
ascending order, otherwise <cite>sorter</cite> must be an array of indices
that sort it.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to insert into <cite>a</cite>.</dd>
<dt>side <span class="classifier-delimiter">:</span> <span class="classifier">{‘left’, ‘right’}, optional</span></dt>
<dd>If ‘left’, the index of the first suitable location found is given.
If ‘right’, return the last such index.  If there is no suitable
index, return either 0 or N (where N is the length of <cite>a</cite>).</dd>
<dt>sorter <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like, optional</span></dt>
<dd><p class="first">Optional array of integer indices that sort array a into ascending
order. They are typically the result of argsort.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array of ints</span></dt>
<dd>Array of insertion points with the same shape as <cite>v</cite>.</dd>
</dl>
<p>sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.</p>
<p>Binary search is used to find the required insertion points.</p>
<p>As of NumPy 1.4.0 <cite>searchsorted</cite> works with real/complex arrays containing
<cite>nan</cite> values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>This function is a faster version of the builtin python <cite>bisect.bisect_left</cite>
(<code class="docutils literal"><span class="pre">side='left'</span></code>) and <cite>bisect.bisect_right</cite> (<code class="docutils literal"><span class="pre">side='right'</span></code>) functions,
which is also vectorized in the <cite>v</cite> argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([0, 5, 1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.shape">
<code class="descclassname">numpy.</code><code class="descname">shape</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shape of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The elements of the shape tuple give the lengths of the
corresponding array dimensions.</dd>
</dl>
<p>alen
ndarray.shape : Equivalent array method.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(1,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.size">
<code class="descclassname">numpy.</code><code class="descname">size</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the elements are counted.  By default, give
the total number of elements.</dd>
</dl>
<dl class="docutils">
<dt>element_count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of elements along the specified axis.</dd>
</dl>
<p>shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.sometrue">
<code class="descclassname">numpy.</code><code class="descname">sometrue</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sometrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether some values are true.</p>
<p>Refer to <cite>any</cite> for full documentation.</p>
<p>any : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.sort">
<code class="descclassname">numpy.</code><code class="descname">sort</code><span class="sig-paren">(</span><em>a</em>, <em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted copy of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm. Default is ‘quicksort’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.</p>
<p>The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="14%" />
<col width="25%" />
<col width="24%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">kind</th>
<th class="head">speed</th>
<th class="head">worst case</th>
<th class="head">work space</th>
<th class="head">stable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘quicksort’</td>
<td>1</td>
<td>O(n^2)</td>
<td>0</td>
<td>no</td>
</tr>
<tr class="row-odd"><td>‘mergesort’</td>
<td>2</td>
<td>O(n*log(n))</td>
<td>~n/2</td>
<td>yes</td>
</tr>
<tr class="row-even"><td>‘heapsort’</td>
<td>3</td>
<td>O(n*log(n))</td>
<td>0</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.</p>
<p>Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:</p>
<blockquote>
<div><ul class="simple">
<li>Real: [R, nan]</li>
<li>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</li>
</ul>
</div></blockquote>
<p>where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>quicksort has been changed to an introsort which will switch
heapsort when it does not make enough progress. This makes its
worst case O(n*log(n)).</p>
<p>‘stable’ automatically choses the best stable sorting algorithm
for the data type being sorted. It is currently mapped to
merge sort.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                <span class="c1"># sort along the last axis</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># sort the flattened array</span>
<span class="go">array([1, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># sort along the first axis</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S10&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Arthur&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Lancelot&#39;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="s1">&#39;Galahad&#39;</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">38</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>       <span class="c1"># create a structured array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>                        
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="go">       (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<p>Sort by age, then height if ages are equal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>               
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="go">       (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.squeeze">
<code class="descclassname">numpy.</code><code class="descname">squeeze</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>squeezed <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <cite>a</cite> itself
or a view into <cite>a</cite>.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>axis</cite> is not <cite>None</cite>, and an axis being squeezed is not of length 1</dd>
</dl>
<p>expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot select an axis to squeeze out which has size not equal to one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.std">
<code class="descclassname">numpy.</code><code class="descname">std</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Calculate the standard deviation of these values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the standard deviation is computed. The
default is to compute the standard deviation of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of elements.
By default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>std</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>standard_deviation <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above.</span></dt>
<dd>If <cite>out</cite> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</dd>
</dl>
<p>var, mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <code class="docutils literal"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is specified,
the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard statistical
practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the variance
of the infinite population. <code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the <cite>dtype</cite> keyword can
alleviate this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.1180339887498949</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.5,  0.5])</span>
</pre></div>
</div>
<p>In single precision, std() can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.45000005</span>
</pre></div>
</div>
<p>Computing the standard deviation in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.44999999925494177</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.sum">
<code class="descclassname">numpy.</code><code class="descname">sum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Elements to sum.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a sum is performed.  The default,
axis=None, will sum all of the elements of the input array.  If
axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>sum</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">Starting value for the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>sum_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.sum : Equivalent method.</p>
<p>cumsum : Cumulative sum of array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>mean, average</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.swapaxes">
<code class="descclassname">numpy.</code><code class="descname">swapaxes</code><span class="sig-paren">(</span><em>a</em>, <em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchange two axes of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>First axis.</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Second axis.</dd>
</dl>
<dl class="docutils">
<dt>a_swapped <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>For NumPy &gt;= 1.10.0, if <cite>a</cite> is an ndarray, then a view of <cite>a</cite> is
returned; otherwise a new array is created. For earlier NumPy
versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[[0, 4],</span>
<span class="go">        [2, 6]],</span>
<span class="go">       [[1, 5],</span>
<span class="go">        [3, 7]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.take">
<code class="descclassname">numpy.</code><code class="descname">take</code><span class="sig-paren">(</span><em>a</em>, <em>indices</em>, <em>axis=None</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take elements from an array along an axis.</p>
<p>When axis is not None, this function does the same thing as “fancy”
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code class="docutils literal"><span class="pre">np.take(arr,</span> <span class="pre">indices,</span> <span class="pre">axis=3)</span></code> is equivalent to
<code class="docutils literal"><span class="pre">arr[:,:,:,indices,...]</span></code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <cite>ndindex</cite>, which sets each of <code class="docutils literal"><span class="pre">ii</span></code>, <code class="docutils literal"><span class="pre">jj</span></code>, and <code class="docutils literal"><span class="pre">kk</span></code> to a tuple of
indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">Nj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],)</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like (Ni…, M, Nk…)</span></dt>
<dd>The source array.</dd>
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array_like (Nj…)</span></dt>
<dd><p class="first">The indices of the values to extract.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<p class="last">Also allow scalars for indices.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis over which to select values. By default, the flattened
input array is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional (Ni…, Nj…, Nk…)</span></dt>
<dd>If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li>‘raise’ – raise an error (default)</li>
<li>‘wrap’ – wrap around</li>
<li>‘clip’ – clip to the range</li>
</ul>
<p class="last">‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (Ni…, Nj…, Nk…)</span></dt>
<dd>The returned array has the same type as <cite>a</cite>.</dd>
</dl>
<p>compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays</p>
<p>By eliminating the inner loop in the description above, and using <cite>s_</cite> to
build simple slice objects, <cite>take</cite> can be expressed  in terms of applying
fancy indexing to each 1-d slice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
</pre></div>
</div>
<p>For this reason, it is equivalent to (but faster than) the following use
of <cite>apply_along_axis</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a_1d</span><span class="p">:</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>In this example if <cite>a</cite> is an ndarray, “fancy” indexing can be used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>If <cite>indices</cite> is not one dimensional, the output also has these dimensions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.trace">
<code class="descclassname">numpy.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>a</em>, <em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>If <cite>a</cite> is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements <code class="docutils literal"><span class="pre">a[i,i+offset]</span></code> for all i.</p>
<p>If <cite>a</cite> has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of <cite>a</cite> with <cite>axis1</cite>
and <cite>axis2</cite> removed.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array, from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to 0.</dd>
<dt>axis1, axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of <cite>a</cite>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and <cite>a</cite> is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of <cite>a</cite>.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Array into which the output is placed. Its type is preserved and
it must be of the right shape to hold the output.</dd>
</dl>
<dl class="docutils">
<dt>sum_along_diagonals <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>If <cite>a</cite> is 2-D, the sum along the diagonal is returned.  If <cite>a</cite> has
larger dimensions, then an array of sums along diagonals is returned.</dd>
</dl>
<p>diag, diagonal, diagflat</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([6, 8])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.transpose">
<code class="descclassname">numpy.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>a</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">list of ints, optional</span></dt>
<dd>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</dd>
</dl>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>a</cite> with its axes permuted.  A view is returned whenever
possible.</dd>
</dl>
<p>moveaxis
argsort</p>
<p>Use <cite>transpose(a, argsort(axes))</cite> to invert the transposition of tensors
when using the <cite>axes</cite> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.var">
<code class="descclassname">numpy.</code><code class="descname">var</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float32</cite>; for arrays of float types it is the same as
the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of elements. By
default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>var</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>variance <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <code class="docutils literal"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</dd>
</dl>
<p>std , mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.20249999932944759</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.2025</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.frompyfunc">
<code class="descclassname">numpy.</code><code class="descname">frompyfunc</code><span class="sig-paren">(</span><em>func</em>, <em>nin</em>, <em>nout</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.frompyfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an arbitrary Python function and returns a NumPy ufunc.</p>
<p>Can be used, for example, to add broadcasting to a built-in Python
function (see Examples section).</p>
<dl class="docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">Python function object</span></dt>
<dd>An arbitrary Python function.</dd>
<dt>nin <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of input arguments.</dd>
<dt>nout <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of objects returned by <cite>func</cite>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ufunc</span></dt>
<dd>Returns a NumPy universal function (<code class="docutils literal"><span class="pre">ufunc</span></code>) object.</dd>
</dl>
<p>vectorize : evaluates pyfunc over input arrays using broadcasting rules of numpy</p>
<p>The returned ufunc always returns PyObject arrays.</p>
<p>Use frompyfunc to add broadcasting to the Python function <code class="docutils literal"><span class="pre">oct</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span><span class="nb">oct</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oct_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="go">array([012, 036, 0144], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">oct</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="c1"># for comparison</span>
<span class="go">array([&#39;012&#39;, &#39;036&#39;, &#39;0144&#39;],</span>
<span class="go">      dtype=&#39;|S4&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.seterrobj">
<code class="descclassname">numpy.</code><code class="descname">seterrobj</code><span class="sig-paren">(</span><em>errobj</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.seterrobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling
behavior in NumPy. <cite>seterrobj</cite> is used internally by the other
functions that set error handling behavior (<cite>seterr</cite>, <cite>seterrcall</cite>).</p>
<dl class="docutils">
<dt>errobj <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first">The error object, a list containing three elements:
[internal numpy buffer size, error mask, error callback function].</p>
<p>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for “invalid”, “under”, “over”, and
“divide” (in that order). The printed string can be interpreted with</p>
<ul class="last simple">
<li>0 : ‘ignore’</li>
<li>1 : ‘warn’</li>
<li>2 : ‘raise’</li>
<li>3 : ‘call’</li>
<li>4 : ‘print’</li>
<li>5 : ‘log’</li>
</ul>
</dd>
</dl>
<p>geterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_errobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>  <span class="c1"># first get the defaults</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_errobj</span>
<span class="go">[10000, 0, None]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_errobj</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20000</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">err_handler</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">new_errobj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># int for divide=4 (&#39;print&#39;) and over=1 (&#39;warn&#39;)</span>
<span class="go">&#39;14&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
<span class="go">{&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;print&#39;, &#39;invalid&#39;: &#39;ignore&#39;, &#39;under&#39;: &#39;ignore&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrcall</span><span class="p">()</span> <span class="ow">is</span> <span class="n">err_handler</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.geterrobj">
<code class="descclassname">numpy.</code><code class="descname">geterrobj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geterrobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling
behavior in NumPy. <cite>geterrobj</cite> is used internally by the other
functions that get and set error handling behavior (<cite>geterr</cite>, <cite>seterr</cite>,
<cite>geterrcall</cite>, <cite>seterrcall</cite>).</p>
<dl class="docutils">
<dt>errobj <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first">The error object, a list containing three elements:
[internal numpy buffer size, error mask, error callback function].</p>
<p>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for “invalid”, “under”, “over”, and
“divide” (in that order). The printed string can be interpreted with</p>
<ul class="last simple">
<li>0 : ‘ignore’</li>
<li>1 : ‘warn’</li>
<li>2 : ‘raise’</li>
<li>3 : ‘call’</li>
<li>4 : ‘print’</li>
<li>5 : ‘log’</li>
</ul>
</dd>
</dl>
<p>seterrobj, seterr, geterr, seterrcall, geterrcall
getbufsize, setbufsize</p>
<p>For complete documentation of the types of floating-point exceptions and
treatment options, see <cite>seterr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>  <span class="c1"># first get the defaults</span>
<span class="go">[10000, 0, None]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">err_handler</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Floating point error (</span><span class="si">%s</span><span class="s2">), with flag </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_bufsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setbufsize</span><span class="p">(</span><span class="mi">20000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_handler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterrcall</span><span class="p">(</span><span class="n">err_handler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>
<span class="go">[20000, 2, &lt;function err_handler at 0x91dcaac&gt;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">,</span>
<span class="go">                        invalid=&#39;print&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;4351&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.obj2sctype">
<code class="descclassname">numpy.</code><code class="descname">obj2sctype</code><span class="sig-paren">(</span><em>rep</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.obj2sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the scalar dtype or NumPy equivalent of Python type of an object.</p>
<dl class="docutils">
<dt>rep <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>The object of which the type is returned.</dd>
<dt>default <span class="classifier-delimiter">:</span> <span class="classifier">any, optional</span></dt>
<dd>If given, this is returned for objects whose types can not be
determined. If not given, None is returned for those objects.</dd>
</dl>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype or Python type</span></dt>
<dd>The data type of <cite>rep</cite>.</dd>
</dl>
<p>sctype2char, issctype, issubsctype, issubdtype, maximum_sctype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.int32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]))</span>
<span class="go">&lt;type &#39;numpy.float64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="n">j</span><span class="p">]))</span>
<span class="go">&lt;type &#39;numpy.complex128&#39;&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.object_&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.string_&#39;&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">obj2sctype</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;type &#39;list&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.sctype2char">
<code class="descclassname">numpy.</code><code class="descname">sctype2char</code><span class="sig-paren">(</span><em>sctype</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sctype2char" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string representation of a scalar dtype.</p>
<dl class="docutils">
<dt>sctype <span class="classifier-delimiter">:</span> <span class="classifier">scalar dtype or object</span></dt>
<dd>If a scalar dtype, the corresponding string character is
returned. If an object, <cite>sctype2char</cite> tries to infer its scalar type
and then return the corresponding string character.</dd>
</dl>
<dl class="docutils">
<dt>typechar <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>The string character corresponding to the scalar type.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>sctype</cite> is an object for which the type can not be inferred.</dd>
</dl>
<p>obj2sctype, issctype, issubsctype, mintypecode</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">sctype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">sctype</span><span class="p">))</span>
<span class="go">l</span>
<span class="go">d</span>
<span class="go">D</span>
<span class="go">S</span>
<span class="go">O</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&#39;O&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.maximum_sctype">
<code class="descclassname">numpy.</code><code class="descname">maximum_sctype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.maximum_sctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the scalar type of highest precision of the same kind as the input.</p>
<dl class="docutils">
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">dtype or dtype specifier</span></dt>
<dd>The input data type. This can be a <cite>dtype</cite> object or an object that
is convertible to a <cite>dtype</cite>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The highest precision data type of the same kind (<cite>dtype.kind</cite>) as <cite>t</cite>.</dd>
</dl>
<p>obj2sctype, mintypecode, sctype2char
dtype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.int64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.uint64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.complex192&#39;&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.string_&#39;&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="s1">&#39;i2&#39;</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.int64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum_sctype</span><span class="p">(</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.float96&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.issctype">
<code class="descclassname">numpy.</code><code class="descname">issctype</code><span class="sig-paren">(</span><em>rep</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the given object represents a scalar data-type.</p>
<dl class="docutils">
<dt>rep <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>If <cite>rep</cite> is an instance of a scalar dtype, True is returned. If not,
False is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Boolean result of check whether <cite>rep</cite> is a scalar dtype.</dd>
</dl>
<p>issubsctype, issubdtype, obj2sctype, sctype2char</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Strings are also a scalar type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.find_common_type">
<code class="descclassname">numpy.</code><code class="descname">find_common_type</code><span class="sig-paren">(</span><em>array_types</em>, <em>scalar_types</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.find_common_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine common type following standard coercion rules.</p>
<dl class="docutils">
<dt>array_types <span class="classifier-delimiter">:</span> <span class="classifier">sequence</span></dt>
<dd>A list of dtypes or dtype convertible objects representing arrays.</dd>
<dt>scalar_types <span class="classifier-delimiter">:</span> <span class="classifier">sequence</span></dt>
<dd>A list of dtypes or dtype convertible objects representing scalars.</dd>
</dl>
<dl class="docutils">
<dt>datatype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The common data type, which is the maximum of <cite>array_types</cite> ignoring
<cite>scalar_types</cite>, unless the maximum of <cite>scalar_types</cite> is of a
different kind (<cite>dtype.kind</cite>). If the kind is not understood, then
None is returned.</dd>
</dl>
<p>dtype, common_type, can_cast, mintypecode</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="nb">complex</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[])</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>The standard casting rules ensure that a scalar cannot up-cast an
array unless the scalar is of a fundamentally different kind of data
(i.e. under a different hierarchy in the data type hierarchy) then
the array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
<span class="go">dtype(&#39;float32&#39;)</span>
</pre></div>
</div>
<p>Complex is of a different type, so it up-casts the float in the
<cite>array_types</cite> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">],</span> <span class="p">[</span><span class="nb">complex</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
<p>Type specifier strings are convertible to dtypes and can therefore
be used instead of dtypes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;c8&#39;</span><span class="p">])</span>
<span class="go">dtype(&#39;complex128&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.issubdtype">
<code class="descclassname">numpy.</code><code class="descname">issubdtype</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubdtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p>
<dl class="docutils">
<dt>arg1, arg2 <span class="classifier-delimiter">:</span> <span class="classifier">dtype_like</span></dt>
<dd>dtype or string representing a typecode.</dd>
</dl>
<p>out : bool</p>
<p>issubsctype, <a href="#id90"><span class="problematic" id="id91">issubclass_</span></a>
numpy.core.numerictypes : Overview of numpy type hierarchy.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.datetime_data">
<code class="descclassname">numpy.</code><code class="descname">datetime_data</code><span class="sig-paren">(</span><em>dtype</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.datetime_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the step size of a date or time type.</p>
<p>The returned tuple can be passed as the second argument of <cite>datetime64</cite> and
<cite>timedelta64</cite>.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The dtype object, which must be a <cite>datetime64</cite> or <cite>timedelta64</cite> type.</dd>
</dl>
<dl class="docutils">
<dt>unit <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>The <span class="xref std std-ref">datetime unit</span> on which this dtype
is based.</dd>
<dt>count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of base units in a step.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt_25s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;timedelta64[25s]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">dt_25s</span><span class="p">)</span>
<span class="go">(&#39;s&#39;, 25)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dt_25s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[s]&#39;</span><span class="p">)</span>
<span class="go">array(250, dtype=&#39;timedelta64[s]&#39;)</span>
</pre></div>
</div>
<p>The result can be used to construct a datetime that uses the same units
as a timedelta:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2010&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">dt_25s</span><span class="p">))</span>
</pre></div>
</div>
<p>numpy.datetime64(‘2010-01-01T00:00:00’,’25s’)</p>
</dd></dl>

<dl class="function">
<dt id="numpy.datetime_as_string">
<code class="descclassname">numpy.</code><code class="descname">datetime_as_string</code><span class="sig-paren">(</span><em>arr</em>, <em>unit=None</em>, <em>timezone='naive'</em>, <em>casting='same_kind'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.datetime_as_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of datetimes into an array of strings.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64</span></dt>
<dd>The array of UTC timestamps to format.</dd>
<dt>unit <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>One of None, ‘auto’, or a <span class="xref std std-ref">datetime unit</span>.</dd>
<dt>timezone <span class="classifier-delimiter">:</span> <span class="classifier">{‘naive’, ‘UTC’, ‘local’} or tzinfo</span></dt>
<dd>Timezone information to use when displaying the datetime. If ‘UTC’, end
with a Z to indicate UTC time. If ‘local’, convert to the local timezone
first, and suffix with a +-#### timezone offset. If a tzinfo object,
then do as with ‘local’, but use the specified timezone.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}</span></dt>
<dd>Casting to allow when changing between datetime units.</dd>
</dl>
<dl class="docutils">
<dt>str_arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array of strings the same shape as <cite>arr</cite>.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;2002-10-27T04:30&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;M8[m]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">array([&#39;2002-10-27T04:30&#39;, &#39;2002-10-27T05:30&#39;, &#39;2002-10-27T06:30&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30&#39;], dtype=&#39;datetime64[m]&#39;)</span>
</pre></div>
</div>
<p>Setting the timezone to UTC shows the same information, but with a Z suffix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="s1">&#39;UTC&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04:30Z&#39;, &#39;2002-10-27T05:30Z&#39;, &#39;2002-10-27T06:30Z&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30Z&#39;], dtype=&#39;&lt;U35&#39;)</span>
</pre></div>
</div>
<p>Note that we picked datetimes that cross a DST boundary. Passing in a
<code class="docutils literal"><span class="pre">pytz</span></code> timezone object will print the appropriate offset</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">))</span>
<span class="go">array([&#39;2002-10-27T00:30-0400&#39;, &#39;2002-10-27T01:30-0400&#39;,</span>
<span class="go">       &#39;2002-10-27T01:30-0500&#39;, &#39;2002-10-27T02:30-0500&#39;], dtype=&#39;&lt;U39&#39;)</span>
</pre></div>
</div>
<p>Passing in a unit will change the precision</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04&#39;, &#39;2002-10-27T05&#39;, &#39;2002-10-27T06&#39;, &#39;2002-10-27T07&#39;],</span>
<span class="go">      dtype=&#39;&lt;U32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="go">array([&#39;2002-10-27T04:30:00&#39;, &#39;2002-10-27T05:30:00&#39;, &#39;2002-10-27T06:30:00&#39;,</span>
<span class="go">       &#39;2002-10-27T07:30:00&#39;], dtype=&#39;&lt;U38&#39;)</span>
</pre></div>
</div>
<p>‘casting’ can be used to specify whether precision can be changed</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>
<span class="go">TypeError: Cannot create a datetime string as units &#39;h&#39; from a NumPy</span>
<span class="go">datetime with units &#39;m&#39; according to the rule &#39;safe&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.busday_offset">
<code class="descclassname">numpy.</code><code class="descname">busday_offset</code><span class="sig-paren">(</span><em>dates</em>, <em>offsets</em>, <em>roll='raise'</em>, <em>weekmask='1111100'</em>, <em>holidays=None</em>, <em>busdaycal=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busday_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>First adjusts the date to fall on a valid day according to
the <code class="docutils literal"><span class="pre">roll</span></code> rule, then applies offsets to the given dates
counted in valid days.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<dl class="docutils">
<dt>dates <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D]</span></dt>
<dd>The array of dates to process.</dd>
<dt>offsets <span class="classifier-delimiter">:</span> <span class="classifier">array_like of int</span></dt>
<dd>The array of offsets, which is broadcast with <code class="docutils literal"><span class="pre">dates</span></code>.</dd>
<dt>roll <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘nat’, ‘forward’, ‘following’, ‘backward’, ‘preceding’, ‘modifiedfollowing’, ‘modifiedpreceding’}, optional</span></dt>
<dd><p class="first">How to treat dates that do not fall on a valid day. The default
is ‘raise’.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘raise’ means to raise an exception for an invalid day.</li>
<li>‘nat’ means to return a NaT (not-a-time) for an invalid day.</li>
<li>‘forward’ and ‘following’ mean to take the first valid day
later in time.</li>
<li>‘backward’ and ‘preceding’ mean to take the first valid day
earlier in time.</li>
<li>‘modifiedfollowing’ means to take the first valid day
later in time unless it is across a Month boundary, in which
case to take the first valid day earlier in time.</li>
<li>‘modifiedpreceding’ means to take the first valid day
earlier in time unless it is across a Month boundary, in which
case to take the first valid day later in time.</li>
</ul>
</div></blockquote>
</dd>
<dt>weekmask <span class="classifier-delimiter">:</span> <span class="classifier">str or array_like of bool, optional</span></dt>
<dd>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</dd>
<dt>holidays <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D], optional</span></dt>
<dd>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</dd>
<dt>busdaycal <span class="classifier-delimiter">:</span> <span class="classifier">busdaycalendar, optional</span></dt>
<dd>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of datetime64[D], optional</span></dt>
<dd>If provided, this array is filled with the result.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of datetime64[D]</span></dt>
<dd>An array with a shape from broadcasting <code class="docutils literal"><span class="pre">dates</span></code> and <code class="docutils literal"><span class="pre">offsets</span></code>
together, containing the dates with offsets applied.</dd>
</dl>
<p>busdaycalendar: An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day in October 2011 (not accounting for holidays)</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-10&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-10-03&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Last business day in February 2012 (not accounting for holidays)</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2012-03&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2012-02-29&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Third Wednesday in January 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-01&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Wed&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-01-19&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 2012 Mother&#39;s Day in Canada and the U.S.</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2012-05&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Sun&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2012-05-13&#39;,&#39;D&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day on or after a date</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-20&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-21&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-22&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-22&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># First business day after a date</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-20&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-21&#39;,&#39;D&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">busday_offset</span><span class="p">(</span><span class="s1">&#39;2011-03-22&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">roll</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
<span class="go">numpy.datetime64(&#39;2011-03-23&#39;,&#39;D&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.busday_count">
<code class="descclassname">numpy.</code><code class="descname">busday_count</code><span class="sig-paren">(</span><em>begindates</em>, <em>enddates</em>, <em>weekmask='1111100'</em>, <em>holidays=[]</em>, <em>busdaycal=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busday_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of valid days between <cite>begindates</cite> and
<cite>enddates</cite>, not including the day of <cite>enddates</cite>.</p>
<p>If <code class="docutils literal"><span class="pre">enddates</span></code> specifies a date value that is earlier than the
corresponding <code class="docutils literal"><span class="pre">begindates</span></code> date value, the count will be negative.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<dl class="docutils">
<dt>begindates <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D]</span></dt>
<dd>The array of the first dates for counting.</dd>
<dt>enddates <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D]</span></dt>
<dd>The array of the end dates for counting, which are excluded
from the count themselves.</dd>
<dt>weekmask <span class="classifier-delimiter">:</span> <span class="classifier">str or array_like of bool, optional</span></dt>
<dd>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</dd>
<dt>holidays <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D], optional</span></dt>
<dd>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</dd>
<dt>busdaycal <span class="classifier-delimiter">:</span> <span class="classifier">busdaycalendar, optional</span></dt>
<dd>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of int, optional</span></dt>
<dd>If provided, this array is filled with the result.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of int</span></dt>
<dd>An array with a shape from broadcasting <code class="docutils literal"><span class="pre">begindates</span></code> and <code class="docutils literal"><span class="pre">enddates</span></code>
together, containing the number of valid days between
the begin and end dates.</dd>
</dl>
<p>busdaycalendar: An object that specifies a custom set of valid days.
is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of weekdays in January 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-02&#39;</span><span class="p">)</span>
<span class="go">21</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of weekdays in 2011</span>
<span class="gp">... </span> <span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="s1">&#39;2012&#39;</span><span class="p">)</span>
<span class="go">260</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Number of Saturdays in 2011</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">busday_count</span><span class="p">(</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="s1">&#39;2012&#39;</span><span class="p">,</span> <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Sat&#39;</span><span class="p">)</span>
<span class="go">53</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.is_busday">
<code class="descclassname">numpy.</code><code class="descname">is_busday</code><span class="sig-paren">(</span><em>dates</em>, <em>weekmask='1111100'</em>, <em>holidays=None</em>, <em>busdaycal=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.is_busday" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates which of the given dates are valid days, and which are not.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<dl class="docutils">
<dt>dates <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D]</span></dt>
<dd>The array of dates to process.</dd>
<dt>weekmask <span class="classifier-delimiter">:</span> <span class="classifier">str or array_like of bool, optional</span></dt>
<dd>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</dd>
<dt>holidays <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D], optional</span></dt>
<dd>An array of dates to consider as invalid dates.  They may be
specified in any order, and NaT (not-a-time) dates are ignored.
This list is saved in a normalized form that is suited for
fast calculations of valid days.</dd>
<dt>busdaycal <span class="classifier-delimiter">:</span> <span class="classifier">busdaycalendar, optional</span></dt>
<dd>A <cite>busdaycalendar</cite> object which specifies the valid days. If this
parameter is provided, neither weekmask nor holidays may be
provided.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of bool, optional</span></dt>
<dd>If provided, this array is filled with the result.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array of bool</span></dt>
<dd>An array with the same shape as <code class="docutils literal"><span class="pre">dates</span></code>, containing True for
each valid day, and False for each invalid day.</dd>
</dl>
<p>busdaycalendar: An object that specifies a custom set of valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The weekdays are Friday, Saturday, and Monday</span>
<span class="gp">... </span><span class="n">np</span><span class="o">.</span><span class="n">is_busday</span><span class="p">([</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-02&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-18&#39;</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">holidays</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-04&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-17&#39;</span><span class="p">])</span>
<span class="go">array([False, False,  True], dtype=&#39;bool&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.busdaycalendar">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">busdaycalendar</code><span class="sig-paren">(</span><em>weekmask='1111100'</em>, <em>holidays=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.busdaycalendar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A business day calendar object that efficiently stores information
defining valid days for the busday family of functions.</p>
<p>The default valid days are Monday through Friday (“business days”).
A busdaycalendar object can be specified with any set of weekly
valid days, plus an optional “holiday” dates that always will be invalid.</p>
<p>Once a busdaycalendar object is created, the weekmask and holidays
cannot be modified.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<dl class="docutils">
<dt>weekmask <span class="classifier-delimiter">:</span> <span class="classifier">str or array_like of bool, optional</span></dt>
<dd>A seven-element array indicating which of Monday through Sunday are
valid days. May be specified as a length-seven list or array, like
[1,1,1,1,1,0,0]; a length-seven string, like ‘1111100’; or a string
like “Mon Tue Wed Thu Fri”, made up of 3-character abbreviations for
weekdays, optionally separated by white space. Valid abbreviations
are: Mon Tue Wed Thu Fri Sat Sun</dd>
<dt>holidays <span class="classifier-delimiter">:</span> <span class="classifier">array_like of datetime64[D], optional</span></dt>
<dd>An array of dates to consider as invalid dates, no matter which
weekday they fall upon.  Holiday dates may be specified in any
order, and NaT (not-a-time) dates are ignored.  This list is
saved in a normalized form that is suited for fast calculations
of valid days.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">busdaycalendar</span></dt>
<dd>A business day calendar object containing the specified
weekmask and holidays values.</dd>
</dl>
<p>is_busday : Returns a boolean array indicating valid days.
busday_offset : Applies an offset counted in valid days.
busday_count : Counts how many valid days are in a half-open date range.</p>
<p>Note: once a busdaycalendar object is created, you cannot modify the
weekmask or holidays.  The attributes return copies of internal data.
weekmask : (copy) seven-element array of bool
holidays : (copy) sorted array of datetime64[D]</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Some important days in July</span>
<span class="gp">... </span><span class="n">bdd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">busdaycalendar</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">holidays</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2011-07-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-04&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-07-17&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Default is Monday to Friday weekdays</span>
<span class="gp">... </span><span class="n">bdd</span><span class="o">.</span><span class="n">weekmask</span>
<span class="go">array([ True,  True,  True,  True,  True, False, False], dtype=&#39;bool&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Any holidays already on the weekend are removed</span>
<span class="gp">... </span><span class="n">bdd</span><span class="o">.</span><span class="n">holidays</span>
<span class="go">array([&#39;2011-07-01&#39;, &#39;2011-07-04&#39;], dtype=&#39;datetime64[D]&#39;)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.busdaycalendar.holidays">
<code class="descname">holidays</code><a class="headerlink" href="#numpy.busdaycalendar.holidays" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the holiday array indicating additional invalid days.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.busdaycalendar.weekmask">
<code class="descname">weekmask</code><a class="headerlink" href="#numpy.busdaycalendar.weekmask" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the seven-element boolean mask indicating valid days.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="numpy.byte">
<code class="descclassname">numpy.</code><code class="descname">byte</code><a class="headerlink" href="#numpy.byte" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int8" title="numpy.int8"><code class="xref py py-class docutils literal"><span class="pre">numpy.int8</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ubyte">
<code class="descclassname">numpy.</code><code class="descname">ubyte</code><a class="headerlink" href="#numpy.ubyte" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint8" title="numpy.uint8"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint8</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.short">
<code class="descclassname">numpy.</code><code class="descname">short</code><a class="headerlink" href="#numpy.short" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int16" title="numpy.int16"><code class="xref py py-class docutils literal"><span class="pre">numpy.int16</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ushort">
<code class="descclassname">numpy.</code><code class="descname">ushort</code><a class="headerlink" href="#numpy.ushort" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint16" title="numpy.uint16"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint16</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.uint">
<code class="descclassname">numpy.</code><code class="descname">uint</code><a class="headerlink" href="#numpy.uint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.intp">
<code class="descclassname">numpy.</code><code class="descname">intp</code><a class="headerlink" href="#numpy.intp" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.uintp">
<code class="descclassname">numpy.</code><code class="descname">uintp</code><a class="headerlink" href="#numpy.uintp" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.long">
<code class="descclassname">numpy.</code><code class="descname">long</code><a class="headerlink" href="#numpy.long" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">builtins.int</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.longlong">
<code class="descclassname">numpy.</code><code class="descname">longlong</code><a class="headerlink" href="#numpy.longlong" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.ulonglong">
<code class="descclassname">numpy.</code><code class="descname">ulonglong</code><a class="headerlink" href="#numpy.ulonglong" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.half">
<code class="descclassname">numpy.</code><code class="descname">half</code><a class="headerlink" href="#numpy.half" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float16" title="numpy.float16"><code class="xref py py-class docutils literal"><span class="pre">numpy.float16</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.double">
<code class="descclassname">numpy.</code><code class="descname">double</code><a class="headerlink" href="#numpy.double" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float64" title="numpy.float64"><code class="xref py py-class docutils literal"><span class="pre">numpy.float64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.longdouble">
<code class="descclassname">numpy.</code><code class="descname">longdouble</code><a class="headerlink" href="#numpy.longdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float128" title="numpy.float128"><code class="xref py py-class docutils literal"><span class="pre">numpy.float128</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.cfloat">
<code class="descclassname">numpy.</code><code class="descname">cfloat</code><a class="headerlink" href="#numpy.cfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.cdouble">
<code class="descclassname">numpy.</code><code class="descname">cdouble</code><a class="headerlink" href="#numpy.cdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.clongdouble">
<code class="descclassname">numpy.</code><code class="descname">clongdouble</code><a class="headerlink" href="#numpy.clongdouble" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.unicode">
<code class="descclassname">numpy.</code><code class="descname">unicode</code><a class="headerlink" href="#numpy.unicode" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">builtins.str</span></code></p>
</dd></dl>

<dl class="class">
<dt id="numpy.void">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">void</code><a class="headerlink" href="#numpy.void" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.flexible" title="numpy.flexible"><code class="xref py py-class docutils literal"><span class="pre">numpy.flexible</span></code></a></p>
<dl class="attribute">
<dt id="numpy.void.base">
<code class="descname">base</code><a class="headerlink" href="#numpy.void.base" title="Permalink to this definition">¶</a></dt>
<dd><p>base object</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.void.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#numpy.void.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype object</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.void.flags">
<code class="descname">flags</code><a class="headerlink" href="#numpy.void.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>integer value of flags</p>
</dd></dl>

<dl class="method">
<dt id="numpy.void.getfield">
<code class="descname">getfield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.void.getfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.void.setfield">
<code class="descname">setfield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.void.setfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.generic">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">generic</code><a class="headerlink" href="#numpy.generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for numpy scalar types.</p>
<p>Class from which most (all?) numpy scalar types are derived.  For
consistency, exposes the same API as <cite>ndarray</cite>, despite many
consequent attributes being either “get-only,” or completely irrelevant.
This is the class from which it is strongly suggested users should derive
custom scalar types.</p>
<dl class="attribute">
<dt id="numpy.generic.T">
<code class="descname">T</code><a class="headerlink" href="#numpy.generic.T" title="Permalink to this definition">¶</a></dt>
<dd><p>transpose</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.all">
<code class="descname">all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.any">
<code class="descname">any</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.base">
<code class="descname">base</code><a class="headerlink" href="#numpy.generic.base" title="Permalink to this definition">¶</a></dt>
<dd><p>base object</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.byteswap">
<code class="descname">byteswap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.byteswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class so as to
provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.choose">
<code class="descname">choose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.compress">
<code class="descname">compress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.conj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.generic.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.data">
<code class="descname">data</code><a class="headerlink" href="#numpy.generic.data" title="Permalink to this definition">¶</a></dt>
<dd><p>pointer to start of data</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.diagonal">
<code class="descname">diagonal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#numpy.generic.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>get array data-descriptor</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.flags">
<code class="descname">flags</code><a class="headerlink" href="#numpy.generic.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>integer value of flags</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.flat">
<code class="descname">flat</code><a class="headerlink" href="#numpy.generic.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>a 1-d view of scalar</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.getfield">
<code class="descname">getfield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.imag">
<code class="descname">imag</code><a class="headerlink" href="#numpy.generic.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>imaginary part of scalar</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.item">
<code class="descname">item</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.item" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.itemset">
<code class="descname">itemset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.itemset" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#numpy.generic.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>length of one element in bytes</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.max">
<code class="descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.min">
<code class="descname">min</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#numpy.generic.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>length of item in bytes</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#numpy.generic.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>number of array dimensions</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.newbyteorder">
<code class="descname">newbyteorder</code><span class="sig-paren">(</span><em>new_order='S'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <cite>dtype</cite> with a different byte order.</p>
<p>Changes are also made in all fields and sub-arrays of the data type.</p>
<p>The <cite>new_order</cite> code can be any from the following:</p>
<ul class="simple">
<li>‘S’ - swap dtype from current to opposite endian</li>
<li>{‘&lt;’, ‘L’} - little endian</li>
<li>{‘&gt;’, ‘B’} - big endian</li>
<li>{‘=’, ‘N’} - native order</li>
<li>{‘|’, ‘I’} - ignore (no change to byte order)</li>
</ul>
<dl class="docutils">
<dt>new_order <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Byte order to force; a value from the byte order specifications
above.  The default value (‘S’) results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <cite>new_order</cite> for the alternatives above.  For example,
any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</dd>
</dl>
<dl class="docutils">
<dt>new_dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>New <cite>dtype</cite> object with the given change to the byte order.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.prod">
<code class="descname">prod</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.ptp">
<code class="descname">ptp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.put">
<code class="descname">put</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.ravel">
<code class="descname">ravel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.real">
<code class="descname">real</code><a class="headerlink" href="#numpy.generic.real" title="Permalink to this definition">¶</a></dt>
<dd><p>real part of scalar</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.round">
<code class="descname">round</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.searchsorted">
<code class="descname">searchsorted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.setfield">
<code class="descname">setfield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.setflags">
<code class="descname">setflags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class so as to
provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.shape">
<code class="descname">shape</code><a class="headerlink" href="#numpy.generic.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple of array dimensions</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.size">
<code class="descname">size</code><a class="headerlink" href="#numpy.generic.size" title="Permalink to this definition">¶</a></dt>
<dd><p>number of elements in the gentype</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.std">
<code class="descname">std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.generic.strides">
<code class="descname">strides</code><a class="headerlink" href="#numpy.generic.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple of bytes steps in each dimension</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.take">
<code class="descname">take</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tobytes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.generic.tofile">
<code class="descname">tofile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.tostring">
<code class="descname">tostring</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.var">
<code class="descname">var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.generic.view">
<code class="descname">view</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.generic.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Not implemented (virtual attribute)</p>
<p>Class generic exists solely to derive numpy scalars from, and possesses,
albeit unimplemented, all the attributes of the ndarray class
so as to provide a uniform API.</p>
<p>The corresponding attribute of the derived class of interest.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.number">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">number</code><a class="headerlink" href="#numpy.number" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.generic" title="numpy.generic"><code class="xref py py-class docutils literal"><span class="pre">numpy.generic</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.integer">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">integer</code><a class="headerlink" href="#numpy.integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.number" title="numpy.number"><code class="xref py py-class docutils literal"><span class="pre">numpy.number</span></code></a></p>
<dl class="attribute">
<dt id="numpy.integer.denominator">
<code class="descname">denominator</code><a class="headerlink" href="#numpy.integer.denominator" title="Permalink to this definition">¶</a></dt>
<dd><p>denominator of value (1)</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.integer.numerator">
<code class="descname">numerator</code><a class="headerlink" href="#numpy.integer.numerator" title="Permalink to this definition">¶</a></dt>
<dd><p>numerator of value (the value itself)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.inexact">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">inexact</code><a class="headerlink" href="#numpy.inexact" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.number" title="numpy.number"><code class="xref py py-class docutils literal"><span class="pre">numpy.number</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.signedinteger">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">signedinteger</code><a class="headerlink" href="#numpy.signedinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.integer" title="numpy.integer"><code class="xref py py-class docutils literal"><span class="pre">numpy.integer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.unsignedinteger">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">unsignedinteger</code><a class="headerlink" href="#numpy.unsignedinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.integer" title="numpy.integer"><code class="xref py py-class docutils literal"><span class="pre">numpy.integer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.floating">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">floating</code><a class="headerlink" href="#numpy.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.inexact" title="numpy.inexact"><code class="xref py py-class docutils literal"><span class="pre">numpy.inexact</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.complexfloating">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">complexfloating</code><a class="headerlink" href="#numpy.complexfloating" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.inexact" title="numpy.inexact"><code class="xref py py-class docutils literal"><span class="pre">numpy.inexact</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.flexible">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">flexible</code><a class="headerlink" href="#numpy.flexible" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.generic" title="numpy.generic"><code class="xref py py-class docutils literal"><span class="pre">numpy.generic</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.character">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">character</code><a class="headerlink" href="#numpy.character" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.flexible" title="numpy.flexible"><code class="xref py py-class docutils literal"><span class="pre">numpy.flexible</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.bool8">
<code class="descclassname">numpy.</code><code class="descname">bool8</code><a class="headerlink" href="#numpy.bool8" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bool_" title="numpy.bool_"><code class="xref py py-class docutils literal"><span class="pre">numpy.bool_</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.float16">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">float16</code><a class="headerlink" href="#numpy.float16" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.floating" title="numpy.floating"><code class="xref py py-class docutils literal"><span class="pre">numpy.floating</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.float32">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">float32</code><a class="headerlink" href="#numpy.float32" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.floating" title="numpy.floating"><code class="xref py py-class docutils literal"><span class="pre">numpy.floating</span></code></a></p>
<p>32-bit floating-point number. Character code ‘f’. C float compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.float64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">float64</code><a class="headerlink" href="#numpy.float64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.floating" title="numpy.floating"><code class="xref py py-class docutils literal"><span class="pre">numpy.floating</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">float</span></code></p>
<p>64-bit floating-point number. Character code ‘d’. Python float compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.float128">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">float128</code><a class="headerlink" href="#numpy.float128" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.floating" title="numpy.floating"><code class="xref py py-class docutils literal"><span class="pre">numpy.floating</span></code></a></p>
<p>128-bit floating-point number. Character code: ‘g’. C long float
compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.complex64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">complex64</code><a class="headerlink" href="#numpy.complex64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.complexfloating" title="numpy.complexfloating"><code class="xref py py-class docutils literal"><span class="pre">numpy.complexfloating</span></code></a></p>
<p>Composed of two 32 bit floats</p>
</dd></dl>

<dl class="class">
<dt id="numpy.complex128">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">complex128</code><a class="headerlink" href="#numpy.complex128" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.complexfloating" title="numpy.complexfloating"><code class="xref py py-class docutils literal"><span class="pre">numpy.complexfloating</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">complex</span></code></p>
<p>Composed of two 64 bit floats</p>
</dd></dl>

<dl class="class">
<dt id="numpy.complex256">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">complex256</code><a class="headerlink" href="#numpy.complex256" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.complexfloating" title="numpy.complexfloating"><code class="xref py py-class docutils literal"><span class="pre">numpy.complexfloating</span></code></a></p>
<p>Composed of two 128 bit floats</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.object0">
<code class="descclassname">numpy.</code><code class="descname">object0</code><a class="headerlink" href="#numpy.object0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.object_" title="numpy.object_"><code class="xref py py-class docutils literal"><span class="pre">numpy.object_</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.bytes0">
<code class="descclassname">numpy.</code><code class="descname">bytes0</code><a class="headerlink" href="#numpy.bytes0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bytes_" title="numpy.bytes_"><code class="xref py py-class docutils literal"><span class="pre">numpy.bytes_</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.str0">
<code class="descclassname">numpy.</code><code class="descname">str0</code><a class="headerlink" href="#numpy.str0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.str_" title="numpy.str_"><code class="xref py py-class docutils literal"><span class="pre">numpy.str_</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.void0">
<code class="descclassname">numpy.</code><code class="descname">void0</code><a class="headerlink" href="#numpy.void0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.void" title="numpy.void"><code class="xref py py-class docutils literal"><span class="pre">numpy.void</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.datetime64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">datetime64</code><a class="headerlink" href="#numpy.datetime64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.generic" title="numpy.generic"><code class="xref py py-class docutils literal"><span class="pre">numpy.generic</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.timedelta64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">timedelta64</code><a class="headerlink" href="#numpy.timedelta64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.signedinteger" title="numpy.signedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.signedinteger</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.int64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">int64</code><a class="headerlink" href="#numpy.int64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.signedinteger" title="numpy.signedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.signedinteger</span></code></a></p>
<p>64-bit integer. Character code ‘l’. Python int compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.uint64">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">uint64</code><a class="headerlink" href="#numpy.uint64" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.unsignedinteger" title="numpy.unsignedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.unsignedinteger</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.int32">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">int32</code><a class="headerlink" href="#numpy.int32" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.signedinteger" title="numpy.signedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.signedinteger</span></code></a></p>
<p>32-bit integer. Character code ‘i’. C int compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.uint32">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">uint32</code><a class="headerlink" href="#numpy.uint32" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.unsignedinteger" title="numpy.unsignedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.unsignedinteger</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.int16">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">int16</code><a class="headerlink" href="#numpy.int16" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.signedinteger" title="numpy.signedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.signedinteger</span></code></a></p>
<p>16-bit integer. Character code <code class="docutils literal"><span class="pre">h</span></code>. C short compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.uint16">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">uint16</code><a class="headerlink" href="#numpy.uint16" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.unsignedinteger" title="numpy.unsignedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.unsignedinteger</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.int8">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">int8</code><a class="headerlink" href="#numpy.int8" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.signedinteger" title="numpy.signedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.signedinteger</span></code></a></p>
<p>8-bit integer. Character code <code class="docutils literal"><span class="pre">b</span></code>. C char compatible.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.uint8">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">uint8</code><a class="headerlink" href="#numpy.uint8" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.unsignedinteger" title="numpy.unsignedinteger"><code class="xref py py-class docutils literal"><span class="pre">numpy.unsignedinteger</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.complex_">
<code class="descclassname">numpy.</code><code class="descname">complex_</code><a class="headerlink" href="#numpy.complex_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex128" title="numpy.complex128"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex128</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.int0">
<code class="descclassname">numpy.</code><code class="descname">int0</code><a class="headerlink" href="#numpy.int0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.uint0">
<code class="descclassname">numpy.</code><code class="descname">uint0</code><a class="headerlink" href="#numpy.uint0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint64" title="numpy.uint64"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.single">
<code class="descclassname">numpy.</code><code class="descname">single</code><a class="headerlink" href="#numpy.single" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float32" title="numpy.float32"><code class="xref py py-class docutils literal"><span class="pre">numpy.float32</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.csingle">
<code class="descclassname">numpy.</code><code class="descname">csingle</code><a class="headerlink" href="#numpy.csingle" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex64" title="numpy.complex64"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.singlecomplex">
<code class="descclassname">numpy.</code><code class="descname">singlecomplex</code><a class="headerlink" href="#numpy.singlecomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex64" title="numpy.complex64"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.float_">
<code class="descclassname">numpy.</code><code class="descname">float_</code><a class="headerlink" href="#numpy.float_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float64" title="numpy.float64"><code class="xref py py-class docutils literal"><span class="pre">numpy.float64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.intc">
<code class="descclassname">numpy.</code><code class="descname">intc</code><a class="headerlink" href="#numpy.intc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int32" title="numpy.int32"><code class="xref py py-class docutils literal"><span class="pre">numpy.int32</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.uintc">
<code class="descclassname">numpy.</code><code class="descname">uintc</code><a class="headerlink" href="#numpy.uintc" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.uint32" title="numpy.uint32"><code class="xref py py-class docutils literal"><span class="pre">numpy.uint32</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.int_">
<code class="descclassname">numpy.</code><code class="descname">int_</code><a class="headerlink" href="#numpy.int_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.int64" title="numpy.int64"><code class="xref py py-class docutils literal"><span class="pre">numpy.int64</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.longfloat">
<code class="descclassname">numpy.</code><code class="descname">longfloat</code><a class="headerlink" href="#numpy.longfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.float128" title="numpy.float128"><code class="xref py py-class docutils literal"><span class="pre">numpy.float128</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.clongfloat">
<code class="descclassname">numpy.</code><code class="descname">clongfloat</code><a class="headerlink" href="#numpy.clongfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.longcomplex">
<code class="descclassname">numpy.</code><code class="descname">longcomplex</code><a class="headerlink" href="#numpy.longcomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.complex256" title="numpy.complex256"><code class="xref py py-class docutils literal"><span class="pre">numpy.complex256</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.bool_">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">bool_</code><a class="headerlink" href="#numpy.bool_" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.generic" title="numpy.generic"><code class="xref py py-class docutils literal"><span class="pre">numpy.generic</span></code></a></p>
<p>NumPy’s Boolean type.  Character code: <code class="docutils literal"><span class="pre">?</span></code>.  Alias: bool8</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.unicode_">
<code class="descclassname">numpy.</code><code class="descname">unicode_</code><a class="headerlink" href="#numpy.unicode_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.str_" title="numpy.str_"><code class="xref py py-class docutils literal"><span class="pre">numpy.str_</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.object_">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">object_</code><a class="headerlink" href="#numpy.object_" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.generic" title="numpy.generic"><code class="xref py py-class docutils literal"><span class="pre">numpy.generic</span></code></a></p>
<p>Any Python object.  Character code: ‘O’.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.bytes_">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">bytes_</code><a class="headerlink" href="#numpy.bytes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">bytes</span></code>, <a class="reference internal" href="#numpy.character" title="numpy.character"><code class="xref py py-class docutils literal"><span class="pre">numpy.character</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="numpy.str_">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">str_</code><a class="headerlink" href="#numpy.str_" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">str</span></code>, <a class="reference internal" href="#numpy.character" title="numpy.character"><code class="xref py py-class docutils literal"><span class="pre">numpy.character</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.string_">
<code class="descclassname">numpy.</code><code class="descname">string_</code><a class="headerlink" href="#numpy.string_" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#numpy.bytes_" title="numpy.bytes_"><code class="xref py py-class docutils literal"><span class="pre">numpy.bytes_</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="numpy.array2string">
<code class="descclassname">numpy.</code><code class="descname">array2string</code><span class="sig-paren">(</span><em>a</em>, <em>max_line_width=None</em>, <em>precision=None</em>, <em>suppress_small=None</em>, <em>separator=' '</em>, <em>prefix=''</em>, <em>style=&lt;no value&gt;</em>, <em>formatter=None</em>, <em>threshold=None</em>, <em>edgeitems=None</em>, <em>sign=None</em>, <em>floatmode=None</em>, <em>suffix=''</em>, <em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array2string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>max_line_width <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The maximum number of columns the string should span. Newline
characters splits the string appropriately after array elements.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Floating point precision. Default is the current printing
precision (usually 8), which can be altered using <cite>set_printoptions</cite>.</dd>
<dt>suppress_small <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Represent very small numbers as zero. A number is “very small” if it
is smaller than the current printing precision.</dd>
<dt>separator <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Inserted between elements.</dd>
</dl>
<p>prefix : str, optional
suffix: str, optional</p>
<blockquote>
<div><p>The length of the prefix and suffix strings are used to respectively
align and wrap the output. An array is typically printed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">prefix</span> <span class="o">+</span> <span class="n">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">suffix</span>
</pre></div>
</div>
<p>The output is left-padded by the length of the prefix string, and
wrapping is forced at the column <code class="docutils literal"><span class="pre">max_line_width</span> <span class="pre">-</span> <span class="pre">len(suffix)</span></code>.</p>
</div></blockquote>
<dl class="docutils">
<dt>style <span class="classifier-delimiter">:</span> <span class="classifier">_NoValue, optional</span></dt>
<dd><p class="first">Has no effect, do not use.</p>
<div class="last deprecated">
<p><span class="versionmodified">Deprecated since version 1.14.0.</span></p>
</div>
</dd>
<dt>formatter <span class="classifier-delimiter">:</span> <span class="classifier">dict of callables, optional</span></dt>
<dd><p class="first">If not None, the keys should indicate the type(s) that the respective
formatting function applies to.  Callables should return a string.
Types that are not specified (by their corresponding keys) are handled
by the default formatters.  Individual types for which a formatter
can be set are:</p>
<ul class="simple">
<li>‘bool’</li>
<li>‘int’</li>
<li>‘timedelta’ : a <cite>numpy.timedelta64</cite></li>
<li>‘datetime’ : a <cite>numpy.datetime64</cite></li>
<li>‘float’</li>
<li>‘longfloat’ : 128-bit floats</li>
<li>‘complexfloat’</li>
<li>‘longcomplexfloat’ : composed of two 128-bit floats</li>
<li>‘void’ : type <cite>numpy.void</cite></li>
<li>‘numpystr’ : types <cite>numpy.string_</cite> and <cite>numpy.unicode_</cite></li>
<li>‘str’ : all other strings</li>
</ul>
<p>Other keys that can be used to set a group of types at once are:</p>
<ul class="last simple">
<li>‘all’ : sets all types</li>
<li>‘int_kind’ : sets ‘int’</li>
<li>‘float_kind’ : sets ‘float’ and ‘longfloat’</li>
<li>‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’</li>
<li>‘str_kind’ : sets ‘str’ and ‘numpystr’</li>
</ul>
</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Total number of array elements which trigger summarization
rather than full repr.</dd>
<dt>edgeitems <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of array items in summary at beginning and end of
each dimension.</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">string, either ‘-‘, ‘+’, or ‘ ‘, optional</span></dt>
<dd>Controls printing of the sign of floating-point types. If ‘+’, always
print the sign of positive values. If ‘ ‘, always prints a space
(whitespace character) in the sign position of positive values.  If
‘-‘, omit the sign character of positive values.</dd>
<dt>floatmode <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Controls the interpretation of the <cite>precision</cite> option for
floating-point types. Can take the following values:</p>
<ul class="last simple">
<li>‘fixed’: Always print exactly <cite>precision</cite> fractional digits,
even if this would print more or fewer digits than
necessary to specify the value uniquely.</li>
<li>‘unique’: Print the minimum number of fractional digits necessary
to represent each value uniquely. Different elements may
have a different number of digits.  The value of the
<cite>precision</cite> option is ignored.</li>
<li>‘maxprec’: Print at most <cite>precision</cite> fractional digits, but if
an element can be uniquely represented with fewer digits
only print it with that many.</li>
<li>‘maxprec_equal’: Print at most <cite>precision</cite> fractional digits,
but if every element in the array can be uniquely
represented with an equal number of fewer digits, use that
many digits for all elements.</li>
</ul>
</dd>
<dt>legacy <span class="classifier-delimiter">:</span> <span class="classifier">string or <cite>False</cite>, optional</span></dt>
<dd><p class="first">If set to the string <cite>‘1.13’</cite> enables 1.13 legacy printing mode. This
approximates numpy 1.13 print output by including a space in the sign
position of floats and different behavior for 0d arrays. If set to
<cite>False</cite>, disables legacy mode. Unrecognized strings will be ignored
with a warning for forward compatibility.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>array_str <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>String representation of the array.</dd>
</dl>
<dl class="docutils">
<dt>TypeError</dt>
<dd>if a callable in <cite>formatter</cite> does not return a string.</dd>
</dl>
<p>array_str, array_repr, set_printoptions, get_printoptions</p>
<p>If a formatter is specified for a certain type, the <cite>precision</cite> keyword is
ignored for that type.</p>
<p>This is a very flexible function; <cite>array_repr</cite> and <cite>array_str</cite> are using
<cite>array2string</cite> internally so keywords with the same name should work
identically in all three functions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[ 0., 1., 2., 3.]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float_kind&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">})</span>
<span class="go">&#39;[0.00 1.00 2.00]&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;int&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
<span class="go">&#39;[0x0L 0x1L 0x2L]&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array_str">
<code class="descclassname">numpy.</code><code class="descname">array_str</code><span class="sig-paren">(</span><em>a</em>, <em>max_line_width=None</em>, <em>precision=None</em>, <em>suppress_small=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representation of the data in an array.</p>
<p>The data in the array is returned as a single string.  This function is
similar to <cite>array_repr</cite>, the difference being that <cite>array_repr</cite> also
returns information on the kind of array and its data type.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array.</dd>
<dt>max_line_width <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Inserts newlines if text is longer than <cite>max_line_width</cite>.  The
default is, indirectly, 75.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Floating point precision.  Default is the current printing precision
(usually 8), which can be altered using <cite>set_printoptions</cite>.</dd>
<dt>suppress_small <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Represent numbers “very close” to zero as zero; default is False.
Very close is defined by precision: if the precision is 8, e.g.,
numbers smaller (in absolute value) than 5e-9 are represented as
zero.</dd>
</dl>
<p>array2string, array_repr, set_printoptions</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">&#39;[0 1 2]&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array_repr">
<code class="descclassname">numpy.</code><code class="descname">array_repr</code><span class="sig-paren">(</span><em>arr</em>, <em>max_line_width=None</em>, <em>precision=None</em>, <em>suppress_small=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string representation of an array.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array.</dd>
<dt>max_line_width <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The maximum number of columns the string should span. Newline
characters split the string appropriately after array elements.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Floating point precision. Default is the current printing precision
(usually 8), which can be altered using <cite>set_printoptions</cite>.</dd>
<dt>suppress_small <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Represent very small numbers as zero, default is False. Very small
is defined by <cite>precision</cite>, if the precision is 8 then
numbers smaller than 5e-9 are represented as zero.</dd>
</dl>
<dl class="docutils">
<dt>string <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>The string representation of an array.</dd>
</dl>
<p>array_str, array2string, set_printoptions</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">&#39;array([1, 2])&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]))</span>
<span class="go">&#39;MaskedArray([ 0.])&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
<span class="go">&#39;array([], dtype=int32)&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1e-6</span><span class="p">,</span> <span class="mf">4e-7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;array([ 0.000001,  0.      ,  2.      ,  3.      ])&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.set_string_function">
<code class="descclassname">numpy.</code><code class="descname">set_string_function</code><span class="sig-paren">(</span><em>f</em>, <em>repr=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_string_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a Python function to be used when pretty printing arrays.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">function or None</span></dt>
<dd>Function to be used to pretty print arrays. The function should expect
a single array argument and return a string of the representation of
the array. If None, the function is reset to the default NumPy function
to print arrays.</dd>
<dt>repr <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True (default), the function for pretty printing (<code class="docutils literal"><span class="pre">__repr__</span></code>)
is set, if False the function that returns the default string
representation (<code class="docutils literal"><span class="pre">__str__</span></code>) is set.</dd>
</dl>
<p>set_printoptions, get_printoptions</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;HA! - What are you going to do now?&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">pprint</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">HA! - What are you going to do now?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 1 2 3 4 5 6 7 8 9]</span>
</pre></div>
</div>
<p>We can reset the function to the default:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p><cite>repr</cite> affects either pretty printing or normal string representation.
Note that <code class="docutils literal"><span class="pre">__repr__</span></code> is still affected by setting <code class="docutils literal"><span class="pre">__str__</span></code>
because the width of each array element in the returned string becomes
equal to the length of the result of <code class="docutils literal"><span class="pre">__str__()</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
<span class="go">&#39;random&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="go">&#39;array([     0,      1,      2,      3])&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.set_printoptions">
<code class="descclassname">numpy.</code><code class="descname">set_printoptions</code><span class="sig-paren">(</span><em>precision=None</em>, <em>threshold=None</em>, <em>edgeitems=None</em>, <em>linewidth=None</em>, <em>suppress=None</em>, <em>nanstr=None</em>, <em>infstr=None</em>, <em>formatter=None</em>, <em>sign=None</em>, <em>floatmode=None</em>, <em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.set_printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set printing options.</p>
<p>These options determine the way floating point numbers, arrays and
other NumPy objects are displayed.</p>
<dl class="docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Number of digits of precision for floating point output (default 8).
May be <cite>None</cite> if <cite>floatmode</cite> is not <cite>fixed</cite>, to print as many digits as
necessary to uniquely specify the value.</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Total number of array elements which trigger summarization
rather than full repr (default 1000).</dd>
<dt>edgeitems <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of array items in summary at beginning and end of
each dimension (default 3).</dd>
<dt>linewidth <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of characters per line for the purpose of inserting
line breaks (default 75).</dd>
<dt>suppress <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, always print floating point numbers using fixed point
notation, in which case numbers equal to zero in the current precision
will print as zero.  If False, then scientific notation is used when
absolute value of the smallest number is &lt; 1e-4 or the ratio of the
maximum absolute value to the minimum is &gt; 1e3. The default is False.</dd>
<dt>nanstr <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>String representation of floating point not-a-number (default nan).</dd>
<dt>infstr <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>String representation of floating point infinity (default inf).</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">string, either ‘-‘, ‘+’, or ‘ ‘, optional</span></dt>
<dd>Controls printing of the sign of floating-point types. If ‘+’, always
print the sign of positive values. If ‘ ‘, always prints a space
(whitespace character) in the sign position of positive values.  If
‘-‘, omit the sign character of positive values. (default ‘-‘)</dd>
<dt>formatter <span class="classifier-delimiter">:</span> <span class="classifier">dict of callables, optional</span></dt>
<dd><p class="first">If not None, the keys should indicate the type(s) that the respective
formatting function applies to.  Callables should return a string.
Types that are not specified (by their corresponding keys) are handled
by the default formatters.  Individual types for which a formatter
can be set are:</p>
<ul class="simple">
<li>‘bool’</li>
<li>‘int’</li>
<li>‘timedelta’ : a <cite>numpy.timedelta64</cite></li>
<li>‘datetime’ : a <cite>numpy.datetime64</cite></li>
<li>‘float’</li>
<li>‘longfloat’ : 128-bit floats</li>
<li>‘complexfloat’</li>
<li>‘longcomplexfloat’ : composed of two 128-bit floats</li>
<li>‘numpystr’ : types <cite>numpy.string_</cite> and <cite>numpy.unicode_</cite></li>
<li>‘object’ : <cite>np.object_</cite> arrays</li>
<li>‘str’ : all other strings</li>
</ul>
<p>Other keys that can be used to set a group of types at once are:</p>
<ul class="last simple">
<li>‘all’ : sets all types</li>
<li>‘int_kind’ : sets ‘int’</li>
<li>‘float_kind’ : sets ‘float’ and ‘longfloat’</li>
<li>‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’</li>
<li>‘str_kind’ : sets ‘str’ and ‘numpystr’</li>
</ul>
</dd>
<dt>floatmode <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Controls the interpretation of the <cite>precision</cite> option for
floating-point types. Can take the following values:</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>‘fixed’: Always print exactly <cite>precision</cite> fractional digits,</dt>
<dd>even if this would print more or fewer digits than
necessary to specify the value uniquely.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘unique’: Print the minimum number of fractional digits necessary</dt>
<dd>to represent each value uniquely. Different elements may
have a different number of digits. The value of the
<cite>precision</cite> option is ignored.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘maxprec’: Print at most <cite>precision</cite> fractional digits, but if</dt>
<dd>an element can be uniquely represented with fewer digits
only print it with that many.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>‘maxprec_equal’: Print at most <cite>precision</cite> fractional digits,</dt>
<dd>but if every element in the array can be uniquely
represented with an equal number of fewer digits, use that
many digits for all elements.</dd>
</dl>
</li>
</ul>
</dd>
<dt>legacy <span class="classifier-delimiter">:</span> <span class="classifier">string or <cite>False</cite>, optional</span></dt>
<dd><p class="first">If set to the string <cite>‘1.13’</cite> enables 1.13 legacy printing mode. This
approximates numpy 1.13 print output by including a space in the sign
position of floats and different behavior for 0d arrays. If set to
<cite>False</cite>, disables legacy mode. Unrecognized strings will be ignored
with a warning for forward compatibility.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<p>get_printoptions, set_string_function, array2string</p>
<p><cite>formatter</cite> is always reset with a call to <cite>set_printoptions</cite>.</p>
<p>Floating point precision can be set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.123456789</span><span class="p">]))</span>
<span class="go">[ 1.1235]</span>
</pre></div>
</div>
<p>Long arrays can be summarised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0 1 2 ..., 7 8 9]</span>
</pre></div>
</div>
<p>Small results can be suppressed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="go">array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="go">array([-0., -0.,  0.,  0.])</span>
</pre></div>
</div>
<p>A custom formatter can be used to display array elements as desired:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;int: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([int: 0, int: -1, int: -2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">()</span>  <span class="c1"># formatter gets reset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([0, 1, 2])</span>
</pre></div>
</div>
<p>To put back the default options, you can use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">edgeitems</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">infstr</span><span class="o">=</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">linewidth</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">nanstr</span><span class="o">=</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
<span class="gp">... </span><span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.get_printoptions">
<code class="descclassname">numpy.</code><code class="descname">get_printoptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current print options.</p>
<dl class="docutils">
<dt>print_opts <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Dictionary of current print options with keys</p>
<blockquote>
<div><ul class="simple">
<li>precision : int</li>
<li>threshold : int</li>
<li>edgeitems : int</li>
<li>linewidth : int</li>
<li>suppress : bool</li>
<li>nanstr : str</li>
<li>infstr : str</li>
<li>formatter : dict of callables</li>
<li>sign : str</li>
</ul>
</div></blockquote>
<p class="last">For a full description of these options, see <cite>set_printoptions</cite>.</p>
</dd>
</dl>
<p>set_printoptions, set_string_function</p>
</dd></dl>

<dl class="function">
<dt id="numpy.printoptions">
<code class="descclassname">numpy.</code><code class="descname">printoptions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.printoptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager for setting print options.</p>
<p>Set print options for the scope of the <cite>with</cite> block, and restore the old
options at the end. See <cite>set_printoptions</cite> for the full description of
available options.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">3</span>
<span class="go">[0.67]</span>
</pre></div>
</div>
<p>The <cite>as</cite>-clause of the <cite>with</cite>-statement gives the current print options:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">opts</span><span class="p">:</span>
<span class="gp">... </span>     <span class="n">assert_equal</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">())</span>
</pre></div>
</div>
<p>set_printoptions, get_printoptions</p>
</dd></dl>

<dl class="function">
<dt id="numpy.format_float_positional">
<code class="descclassname">numpy.</code><code class="descname">format_float_positional</code><span class="sig-paren">(</span><em>x</em>, <em>precision=None</em>, <em>unique=True</em>, <em>fractional=True</em>, <em>trim='k'</em>, <em>sign=False</em>, <em>pad_left=None</em>, <em>pad_right=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_float_positional" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a floating-point scalar as a decimal string in positional notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the “Dragon4” algorithm.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">python float or numpy floating scalar</span></dt>
<dd>Value to format.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer or None, optional</span></dt>
<dd>Maximum number of digits to print. May be None if <cite>unique</cite> is
<cite>True</cite>, but must be an integer if unique is <cite>False</cite>.</dd>
<dt>unique <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If <cite>True</cite>, use a digit-generation strategy which gives the shortest
representation which uniquely identifies the floating-point number from
other values of the same type, by judicious rounding. If <cite>precision</cite>
was omitted, print out all necessary digits, otherwise digit generation
is cut off after <cite>precision</cite> digits and the remaining value is rounded.
If <cite>False</cite>, digits are generated as if printing an infinite-precision
value and stopping after <cite>precision</cite> digits, rounding the remaining
value.</dd>
<dt>fractional <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If <cite>True</cite>, the cutoff of <cite>precision</cite> digits refers to the total number
of digits after the decimal point, including leading zeros.
If <cite>False</cite>, <cite>precision</cite> refers to the total number of significant
digits, before or after the decimal point, ignoring leading zeros.</dd>
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">one of ‘k’, ‘.’, ‘0’, ‘-‘, optional</span></dt>
<dd><p class="first">Controls post-processing trimming of trailing digits, as follows:</p>
<ul class="last simple">
<li>‘k’ : keep trailing zeros, keep decimal point (no trimming)</li>
<li>‘.’ : trim all trailing zeros, leave decimal point</li>
<li>‘0’ : trim all but the zero before the decimal point. Insert the
zero if it is missing.</li>
<li>‘-‘ : trim trailing zeros and any trailing decimal point</li>
</ul>
</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>Whether to show the sign for positive values.</dd>
<dt>pad_left <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer, optional</span></dt>
<dd>Pad the left side of the string with whitespace until at least that
many characters are to the left of the decimal point.</dd>
<dt>pad_right <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer, optional</span></dt>
<dd>Pad the right side of the string with whitespace until at least that
many characters are to the right of the decimal point.</dd>
</dl>
<dl class="docutils">
<dt>rep <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The string representation of the floating point value</dd>
</dl>
<p>format_float_scientific</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.1415927&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.14&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="mf">0.3</span><span class="p">))</span>
<span class="go">&#39;0.3&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_positional</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="mf">0.3</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;0.3000488281&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.format_float_scientific">
<code class="descclassname">numpy.</code><code class="descname">format_float_scientific</code><span class="sig-paren">(</span><em>x</em>, <em>precision=None</em>, <em>unique=True</em>, <em>trim='k'</em>, <em>sign=False</em>, <em>pad_left=None</em>, <em>exp_digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_float_scientific" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a floating-point scalar as a decimal string in scientific notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the “Dragon4” algorithm.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">python float or numpy floating scalar</span></dt>
<dd>Value to format.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer or None, optional</span></dt>
<dd>Maximum number of digits to print. May be None if <cite>unique</cite> is
<cite>True</cite>, but must be an integer if unique is <cite>False</cite>.</dd>
<dt>unique <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If <cite>True</cite>, use a digit-generation strategy which gives the shortest
representation which uniquely identifies the floating-point number from
other values of the same type, by judicious rounding. If <cite>precision</cite>
was omitted, print all necessary digits, otherwise digit generation is
cut off after <cite>precision</cite> digits and the remaining value is rounded.
If <cite>False</cite>, digits are generated as if printing an infinite-precision
value and stopping after <cite>precision</cite> digits, rounding the remaining
value.</dd>
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">one of ‘k’, ‘.’, ‘0’, ‘-‘, optional</span></dt>
<dd><p class="first">Controls post-processing trimming of trailing digits, as follows:</p>
<ul class="last simple">
<li>‘k’ : keep trailing zeros, keep decimal point (no trimming)</li>
<li>‘.’ : trim all trailing zeros, leave decimal point</li>
<li>‘0’ : trim all but the zero before the decimal point. Insert the
zero if it is missing.</li>
<li>‘-‘ : trim trailing zeros and any trailing decimal point</li>
</ul>
</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>Whether to show the sign for positive values.</dd>
<dt>pad_left <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer, optional</span></dt>
<dd>Pad the left side of the string with whitespace until at least that
many characters are to the left of the decimal point.</dd>
<dt>exp_digits <span class="classifier-delimiter">:</span> <span class="classifier">non-negative integer, optional</span></dt>
<dd>Pad the exponent with zeros until it contains at least this many digits.
If omitted, the exponent will be at least 2 digits.</dd>
</dl>
<dl class="docutils">
<dt>rep <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The string representation of the floating point value</dd>
</dl>
<p>format_float_positional</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">&#39;3.1415927e+00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1.23e24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">&#39;1.230000071797338e+24&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_float_scientific</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">exp_digits</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;1.23e+0024&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">alen</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span></dt>
<dd><p>Return the length of the first dimension of the input array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>alen <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Length of the first dimension of <cite>a</cite>.</dd>
</dl>
<p>shape, size</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">alen</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">all</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a logical AND reduction is performed.
The default (<cite>axis</cite> = <cite>None</cite>) is to perform a logical AND over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code class="docutils literal"><span class="pre">dtype(out)</span></code> is float, the result
will consist of 0.0’s and 1.0’s).  See <cite>doc.ufuncs</cite> (Section
“Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>all</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>all <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, bool</span></dt>
<dd>A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>                             
<span class="go">(28293632, 28293632, array([ True]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">alltrue</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Check if all elements of input array are true.</p>
<p>numpy.all : Equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">amax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amax</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The minimum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>amax <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>amin :</dt>
<dd>The minimum value of an array along a given axis, propagating any NaNs.</dd>
<dt>nanmax :</dt>
<dd>The maximum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>maximum :</dt>
<dd>Element-wise maximum of two arrays, propagating any NaNs.</dd>
<dt>fmax :</dt>
<dd>Element-wise maximum of two arrays, ignoring any NaNs.</dd>
<dt>argmax :</dt>
<dd>Return the indices of the maximum values.</dd>
</dl>
<p>nanmin, minimum, fmin</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">amin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to operate.  By default, flattened input is
used.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for more details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>amax :</dt>
<dd>The maximum value of an array along a given axis, propagating any NaNs.</dd>
<dt>nanmin :</dt>
<dd>The minimum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>minimum :</dt>
<dd>Element-wise minimum of two arrays, propagating any NaNs.</dd>
<dt>fmin :</dt>
<dd>Element-wise minimum of two arrays, ignoring any NaNs.</dd>
<dt>argmin :</dt>
<dd>Return the indices of the minimum values.</dd>
</dl>
<p>nanmax, maximum, fmax</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis</span>
<span class="go">array([0, 2])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal"><span class="pre">default</span></code> argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">any</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal"><span class="pre">None</span></code></p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a logical OR reduction is performed.
The default (<cite>axis</cite> = <cite>None</cite>) is to perform a logical OR over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of <cite>a</cite>).
See <cite>doc.ufuncs</cite> (Section “Output arguments”) for details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>any</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>any <span class="classifier-delimiter">:</span> <span class="classifier">bool or ndarray</span></dt>
<dd>A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.any : equivalent method</p>
<p>all : Test whether all elements along a given axis evaluate to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">,</span> <span class="n">o</span>
<span class="go">(array([ True]), array([ True]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check now that z is a reference to o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># identity of z and o              </span>
<span class="go">(191614240, 191614240)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">argmax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the indices of the maximum values along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>By default, the index is into the flattened array, otherwise
along the specified axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</dd>
</dl>
<p>ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.</p>
<p>In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<p>Indexes of the maximal elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 5, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">argmin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the indices of the minimum values along an axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>By default, the index is into the flattened array, otherwise
along the specified axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</dd>
</dl>
<p>ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.</p>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
</pre></div>
</div>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 1, 2, 3, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">argpartition</code><span class="sig-paren">(</span><em>a</em>, <em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span></dt>
<dd><p>Perform an indirect partition along the given axis using the
algorithm specified by the <cite>kind</cite> keyword. It returns an array of
indices of the same shape as <cite>a</cite> that index data along the given
axis in partitioned order.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to sort.</dd>
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The k-th element will be in its
final sorted position and all smaller elements will be moved
before it and all larger elements behind it. The order all
elements in the partitions is undefined. If provided with a
sequence of k-th it will partition all of them into their sorted
position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. The default is -1 (the last axis). If
None, the flattened array is used.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc. A single
field can be specified as a string, and not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, int</span></dt>
<dd>Array of indices that partition <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal"><span class="pre">a[index_array]</span></code> yields a partitioned <cite>a</cite>.
More generally, <code class="docutils literal"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the partitioned <cite>a</cite>, irrespective of dimensionality.</dd>
</dl>
<p>partition : Describes partition algorithms used.
ndarray.partition : Inplace partition.
argsort : Full indirect sort</p>
<p>See <cite>partition</cite> for notes on the different selection algorithms.</p>
<p>One dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">argsort</code><span class="sig-paren">(</span><em>a</em>, <em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span></dt>
<dd><p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <cite>kind</cite> keyword. It returns an array of indices of the same shape as
<cite>a</cite> that index data along the given axis in sorted order.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to sort.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, int</span></dt>
<dd>Array of indices that sort <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.
More generally, <code class="docutils literal"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the sorted <cite>a</cite>, irrespective of dimensionality.</dd>
</dl>
<p>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.
argpartition : Indirect partial sort.</p>
<p>See <cite>sort</cite> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <cite>argsort</cite> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>One dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<p>Two-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sorts along first axis (down)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts along last axis (across)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [0, 1]])</span>
</pre></div>
</div>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>  <span class="c1"># same as np.sort(x, axis=None)</span>
<span class="go">array([0, 2, 2, 3])</span>
</pre></div>
</div>
<p>Sorting with keys:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1, 0), (0, 1)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">around</code><span class="sig-paren">(</span><em>a</em>, <em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Evenly round to the given number of decimals.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>decimals <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary. See <cite>doc.ufuncs</cite> (Section
“Output arguments”) for details.</dd>
</dl>
<dl class="docutils">
<dt>rounded_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">An array of the same type as <cite>a</cite>, containing the rounded values.
Unless <cite>out</cite> was specified, a new array is created.  A reference to
the result is returned.</p>
<p class="last">The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
</dd>
</dl>
<p>ndarray.round : equivalent method</p>
<p>ceil, fix, floor, rint, trunc</p>
<p>For values exactly halfway between rounded decimal values, NumPy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
to the inexact representation of decimal fractions in the IEEE
floating point standard <a href="#id92"><span class="problematic" id="id22">[1]_</span></a> and errors introduced when scaling
by powers of ten.</p>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>“Lecture Notes on the Status of  IEEE 754”, William Kahan,
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>“How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?”, William Kahan,
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/Mindless.pdf">http://www.cs.berkeley.edu/~wkahan/Mindless.pdf</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">])</span>
<span class="go">array([ 0.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mf">0.37</span><span class="p">,</span> <span class="mf">1.64</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.4,  1.6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span> <span class="c1"># rounds to nearest even value</span>
<span class="go">array([ 0.,  2.,  2.,  4.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># ndarray of ints is returned</span>
<span class="go">array([ 1,  2,  3, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">decimals</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0,  0,  0, 10])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">choose</code><span class="sig-paren">(</span><em>a</em>, <em>choices</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span></dt>
<dd><p>Construct an array from an index array and a set of arrays to choose from.</p>
<p>First of all, if confused or uncertain, definitely look at the Examples -
in its full generality, this function is less simple than it might
seem from the following code description (below ndi =
<cite>numpy.lib.index_tricks</cite>):</p>
<p><code class="docutils literal"><span class="pre">np.choose(a,c)</span> <span class="pre">==</span> <span class="pre">np.array([c[a[I]][I]</span> <span class="pre">for</span> <span class="pre">I</span> <span class="pre">in</span> <span class="pre">ndi.ndindex(a.shape)])</span></code>.</p>
<p>But this omits some subtleties.  Here is a fully general summary:</p>
<p>Given an “index” array (<cite>a</cite>) of integers and a sequence of <cite>n</cite> arrays
(<cite>choices</cite>), <cite>a</cite> and each choice array are first broadcast, as necessary,
to arrays of a common shape; calling these <em>Ba</em> and <em>Bchoices[i], i =
0,…,n-1</em> we have that, necessarily, <code class="docutils literal"><span class="pre">Ba.shape</span> <span class="pre">==</span> <span class="pre">Bchoices[i].shape</span></code>
for each <cite>i</cite>.  Then, a new array with shape <code class="docutils literal"><span class="pre">Ba.shape</span></code> is created as
follows:</p>
<ul class="simple">
<li>if <code class="docutils literal"><span class="pre">mode=raise</span></code> (the default), then, first of all, each element of
<cite>a</cite> (and thus <cite>Ba</cite>) must be in the range <cite>[0, n-1]</cite>; now, suppose that
<cite>i</cite> (in that range) is the value at the <cite>(j0, j1, …, jm)</cite> position
in <cite>Ba</cite> - then the value at the same position in the new array is the
value in <cite>Bchoices[i]</cite> at that same position;</li>
<li>if <code class="docutils literal"><span class="pre">mode=wrap</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; modular arithmetic is used to map integers outside the range
<cite>[0, n-1]</cite> back into that range; and then the new array is constructed
as above;</li>
<li>if <code class="docutils literal"><span class="pre">mode=clip</span></code>, values in <cite>a</cite> (and thus <cite>Ba</cite>) may be any (signed)
integer; negative integers are mapped to 0; values greater than <cite>n-1</cite>
are mapped to <cite>n-1</cite>; and then the new array is constructed as above.</li>
</ul>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">int array</span></dt>
<dd>This array must contain integers in <cite>[0, n-1]</cite>, where <cite>n</cite> is the number
of choices, unless <code class="docutils literal"><span class="pre">mode=wrap</span></code> or <code class="docutils literal"><span class="pre">mode=clip</span></code>, in which cases any
integers are permissible.</dd>
<dt>choices <span class="classifier-delimiter">:</span> <span class="classifier">sequence of arrays</span></dt>
<dd>Choice arrays. <cite>a</cite> and all of the choices must be broadcastable to the
same shape.  If <cite>choices</cite> is itself an array (not recommended), then
its outermost dimension (i.e., the one corresponding to
<code class="docutils literal"><span class="pre">choices.shape[0]</span></code>) is taken as defining the “sequence”.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’ (default), ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how indices outside <cite>[0, n-1]</cite> will be treated:</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘raise’ : an exception is raised</li>
<li>‘wrap’ : value becomes value mod <cite>n</cite></li>
<li>‘clip’ : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</li>
</ul>
</div></blockquote>
</dd>
</dl>
<dl class="docutils">
<dt>merged_array <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>The merged result.</dd>
</dl>
<dl class="docutils">
<dt>ValueError: shape mismatch</dt>
<dd>If <cite>a</cite> and each choice array are not all broadcastable to the same
shape.</dd>
</dl>
<p>ndarray.choose : equivalent method</p>
<p>To reduce the chance of misinterpretation, even though the following
“abuse” is nominally supported, <cite>choices</cite> should neither be, nor be
thought of as, a single array, i.e., the outermost sequence-like container
should be either a list or a tuple.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
<span class="gp">... </span>  <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span>
<span class="gp">... </span><span class="c1"># the first element of the result will be the first element of the</span>
<span class="gp">... </span><span class="c1"># third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="gp">... </span><span class="c1"># will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="gp">... </span><span class="c1"># 31, etc.</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to 3 (4-1)</span>
<span class="go">array([20, 31, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># because there are 4 choice arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">choices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span> <span class="c1"># 4 goes to (4 mod 4)</span>
<span class="go">array([20,  1, 12,  3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># i.e., 0</span>
</pre></div>
</div>
<p>A couple examples illustrating how choose broadcasts:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">)</span>
<span class="go">array([[ 10, -10,  10],</span>
<span class="go">       [-10,  10, -10],</span>
<span class="go">       [ 10, -10,  10]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># With thanks to Anne Archibald</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">))</span> <span class="c1"># result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span>
<span class="go">array([[[ 1,  1,  1,  1,  1],</span>
<span class="go">        [ 2,  2,  2,  2,  2],</span>
<span class="go">        [ 3,  3,  3,  3,  3]],</span>
<span class="go">       [[-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5],</span>
<span class="go">        [-1, -2, -3, -4, -5]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">clip</code><span class="sig-paren">(</span><em>a</em>, <em>a_min</em>, <em>a_max</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing elements to clip.</dd>
<dt>a_min <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like or <cite>None</cite></span></dt>
<dd>Minimum value. If <cite>None</cite>, clipping is not performed on lower
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
<cite>None</cite>.</dd>
<dt>a_max <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like or <cite>None</cite></span></dt>
<dd>Maximum value. If <cite>None</cite>, clipping is not performed on upper
interval edge. Not more than one of <cite>a_min</cite> and <cite>a_max</cite> may be
<cite>None</cite>. If <cite>a_min</cite> or <cite>a_max</cite> are array_like, then the three
arrays will be broadcasted to match their shapes.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>The results will be placed in this array. It may be the input
array for in-place clipping.  <cite>out</cite> must be of the right shape
to hold the output.  Its type is preserved.</dd>
</dl>
<dl class="docutils">
<dt>clipped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the elements of <cite>a</cite>, but where values
&lt; <cite>a_min</cite> are replaced with <cite>a_min</cite>, and those &gt; <cite>a_max</cite>
with <cite>a_max</cite>.</dd>
</dl>
<p>numpy.doc.ufuncs : Section “Output arguments”</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>condition</em>, <em>a</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return selected slices of an array along given axis.</p>
<p>When working along a given axis, a slice along that axis is returned in
<cite>output</cite> for each index where <cite>condition</cite> evaluates to True. When
working on a 1-D array, <cite>compress</cite> is equivalent to <cite>extract</cite>.</p>
<dl class="docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="classifier">1-D array of bools</span></dt>
<dd>Array that selects which entries to return. If len(condition)
is less than the size of <cite>a</cite> along the given axis, then output is
truncated to the length of the condition array.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array from which to extract a part.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to take slices. If None (default), work on the
flattened array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output array.  Its type is preserved and it must be of the right
shape to hold the output.</dd>
</dl>
<dl class="docutils">
<dt>compressed_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <cite>a</cite> without the slices along axis for which <cite>condition</cite>
is false.</dd>
</dl>
<p>take, choose, diag, diagonal, select
ndarray.compress : Equivalent method in ndarray
np.extract: Equivalent method when working on 1-D arrays
numpy.doc.ufuncs : Section “Output arguments”</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [4],</span>
<span class="go">       [6]])</span>
</pre></div>
</div>
<p>Working on the flattened array does not return slices along an axis but
selects elements.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">cumprod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative product is computed.  By default
the input is flattened.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</dd>
</dl>
<dl class="docutils">
<dt>cumprod <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</dd>
</dl>
<p>numpy.doc.ufuncs : Section “Output arguments”</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2</span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output</span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">cumproduct</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Return the cumulative product over the given axis.</p>
<p>cumprod : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">cumsum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the cumulative sum of the elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <cite>doc.ufuncs</cite>
(Section “Output arguments”) for more details.</dd>
</dl>
<dl class="docutils">
<dt>cumsum_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray.</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to <cite>out</cite> is returned. The
result has the same size as <cite>a</cite>, and the same shape as <cite>a</cite> if
<cite>axis</cite> is not None or <cite>a</cite> is a 1-d array.</dd>
</dl>
<p>sum : Sum array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>diff :  Calculate the n-th discrete difference along given axis.</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>     <span class="c1"># specifies type of output value(s)</span>
<span class="go">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># sum over rows for each of the 3 columns</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [5, 7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># sum over columns for each of the 2 rows</span>
<span class="go">array([[ 1,  3,  6],</span>
<span class="go">       [ 4,  9, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">diagonal</code><span class="sig-paren">(</span><em>a</em>, <em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em><span class="sig-paren">)</span></dt>
<dd><p>Return specified diagonals.</p>
<p>If <cite>a</cite> is 2-D, returns the diagonal of <cite>a</cite> with the given offset,
i.e., the collection of elements of the form <code class="docutils literal"><span class="pre">a[i,</span> <span class="pre">i+offset]</span></code>.  If
<cite>a</cite> has more than two dimensions, then the axes specified by <cite>axis1</cite>
and <cite>axis2</cite> are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing <cite>axis1</cite> and <cite>axis2</cite> and appending an index to the right equal
to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.</p>
<p>If you don’t write to the array returned by this function, then you can
just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use <code class="docutils literal"><span class="pre">np.diagonal(a).copy()</span></code> instead
of just <code class="docutils literal"><span class="pre">np.diagonal(a)</span></code>. This will work with both past and future
versions of NumPy.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal.  Can be positive or
negative.  Defaults to main diagonal (0).</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis to be used as the first axis of the 2-D sub-arrays from which
the diagonals should be taken.  Defaults to first axis (0).</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis to be used as the second axis of the 2-D sub-arrays from
which the diagonals should be taken. Defaults to second axis (1).</dd>
</dl>
<dl class="docutils">
<dt>array_of_diagonals <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">If <cite>a</cite> is 2-D, then a 1-D array containing the diagonal and of the
same type as <cite>a</cite> is returned unless <cite>a</cite> is a <cite>matrix</cite>, in which case
a 1-D array rather than a (2-D) <cite>matrix</cite> is returned in order to
maintain backward compatibility.</p>
<p class="last">If <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, then the dimensions specified by <cite>axis1</cite> and <cite>axis2</cite>
are removed, and a new axis inserted at the end corresponding to the
diagonal.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the dimension of <cite>a</cite> is less than 2.</dd>
</dl>
<p>diag : MATLAB work-a-like for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="go">array([0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<p>A 3-D example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># Main diagonals of two arrays created by skipping</span>
<span class="gp">... </span>           <span class="mi">0</span><span class="p">,</span> <span class="c1"># across the outer(left)-most axis last and</span>
<span class="gp">... </span>           <span class="mi">1</span><span class="p">)</span> <span class="c1"># the &quot;middle&quot; (row) axis first.</span>
<span class="go">array([[0, 6],</span>
<span class="go">       [1, 7]])</span>
</pre></div>
</div>
<p>The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are “packed” in rows.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># main diagonal is [0 6]</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># main diagonal is [1 7]</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for floating point inputs, it is the same as the
input dtype.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.
See <cite>doc.ufuncs</cite> for details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>mean</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</dd>
</dl>
<p>average : Weighted average
std, var, nanmean, nanstd, nanvar</p>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for <cite>float32</cite> (see
example below).  Specifying a higher-precision accumulator using the
<cite>dtype</cite> keyword can alleviate this issue.</p>
<p>By default, <cite>float16</cite> results are computed using <cite>float32</cite> intermediates
for extra precision.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.5,  3.5])</span>
</pre></div>
</div>
<p>In single precision, <cite>mean</cite> can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.54999924</span>
</pre></div>
</div>
<p>Computing the mean in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.55000000074505806</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">ndim</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span></dt>
<dd><p>Return the number of dimensions of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.  If it is not already an ndarray, a conversion is
attempted.</dd>
</dl>
<dl class="docutils">
<dt>number_of_dimensions <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of dimensions in <cite>a</cite>.  Scalars are zero-dimensional.</dd>
</dl>
<p>ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">nonzero</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <cite>a</cite>,
containing the indices of the non-zero elements in that
dimension. The values in <cite>a</cite> are always tested and returned in
row-major, C-style order. The corresponding non-zero
values can be obtained with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
</pre></div>
</div>
<p>To group the indices by element, rather than dimension, use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">transpose</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>The result of this is always a 2-D array, with a row for
each non-zero element.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>tuple_of_arrays <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Indices of elements that are non-zero.</dd>
</dl>
<dl class="docutils">
<dt>flatnonzero :</dt>
<dd>Return indices that are non-zero in the flattened version of the input
array.</dd>
<dt>ndarray.nonzero :</dt>
<dd>Equivalent ndarray method.</dd>
<dt>count_nonzero :</dt>
<dd>Counts the number of non-zero elements in the input array.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 0, 0],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [1, 1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([1, 2, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [2, 1])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">nonzero</span></code> method of the boolean array can also be called.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>a</em>, <em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return a partitioned copy of an array.</p>
<p>Creates a copy of the array with its elements rearranged in such a
way that the value of the element in k-th position is in the
position it would be in a sorted array. All elements smaller than
the k-th element are moved before this element and all equal or
greater are moved behind it. The ordering of the elements in the two
partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The k-th value of the element
will be in its final sorted position and all smaller elements
will be moved before it and all equal or greater elements behind
it. The order of all elements in the partitions is undefined. If
provided with a sequence of k-th it will partition all elements
indexed by k-th  of them into their sorted position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument
specifies which fields to compare first, second, etc.  A single
field can be specified as a string.  Not all fields need be
specified, but unspecified fields will still be used, in the
order in which they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>partitioned_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>ndarray.partition : Method to sort an array in-place.
argpartition : Indirect partition.
sort : Full sorting</p>
<p>The various selection algorithms are characterized by their average
speed, worst case performance, work space size, and whether they are
stable. A stable sort keeps items with the same key in the same
relative order. The available algorithms have the following
properties:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="13%" />
<col width="23%" />
<col width="21%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">kind</th>
<th class="head">speed</th>
<th class="head">worst case</th>
<th class="head">work space</th>
<th class="head">stable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘introselect’</td>
<td>1</td>
<td>O(n)</td>
<td>0</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>All the partition algorithms make temporary copies of the data when
partitioning along any but the last axis.  Consequently,
partitioning along the last axis is faster and uses less space than
partitioning along any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the
real and imaginary parts are non-nan then the order is determined by
the real parts except when they are equal, in which case the order
is determined by the imaginary parts.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a product is performed.  The default,
axis=None, will calculate the product of all the elements in the
input array. If axis is negative it counts from the last to the
first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left in the
result as dimensions with size one. With this option, the result
will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>prod</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">The starting value for this product. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>product_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see <cite>dtype</cite> parameter above.</span></dt>
<dd>An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</dd>
</dl>
<p>ndarray.prod : equivalent method
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">16</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>By default, calculate the product of all elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">product</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>prod : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">ptp</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Range of values (maximum - minimum) along an axis.</p>
<p>The name of the function comes from the acronym for ‘peak to peak’.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis along which to find the peaks.  By default, flatten the
array.  <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>ptp</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ptp <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result, unless <cite>out</cite> was
specified, in which case a reference to <cite>out</cite> is returned.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">put</code><span class="sig-paren">(</span><em>a</em>, <em>ind</em>, <em>v</em>, <em>mode='raise'</em><span class="sig-paren">)</span></dt>
<dd><p>Replaces specified elements of an array with given values.</p>
<p>The indexing works on the flattened target array. <cite>put</cite> is roughly
equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</pre></div>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Target array.</dd>
<dt>ind <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Target indices, interpreted as integers.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to place in <cite>a</cite> at target indices. If <cite>v</cite> is shorter than
<cite>ind</cite> it will be repeated as necessary.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li>‘raise’ – raise an error (default)</li>
<li>‘wrap’ – wrap around</li>
<li>‘clip’ – clip to the range</li>
</ul>
<p class="last">‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
<p>putmask, place
put_along_axis : Put elements by matching the array and the index arrays</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">44</span><span class="p">,</span> <span class="o">-</span><span class="mi">55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([-44,   1, -55,   3,   4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0,  1,  2,  3, -5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">rank</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span></dt>
<dd><p>Return the number of dimensions of an array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is deprecated in NumPy 1.9 to avoid confusion with
<cite>numpy.linalg.matrix_rank</cite>. The <code class="docutils literal"><span class="pre">ndim</span></code> attribute or function
should be used instead.</p>
</div>
<p>ndim : equivalent non-deprecated function</p>
<p>In the old Numeric package, <cite>rank</cite> was the term used for the number of
dimensions, but in NumPy <cite>ndim</cite> is used instead.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">ravel</code><span class="sig-paren">(</span><em>a</em>, <em>order='C'</em><span class="sig-paren">)</span></dt>
<dd><p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.  The elements in <cite>a</cite> are read in the order specified by
<cite>order</cite>, and packed as a 1-D array.</dd>
</dl>
<p>order : {‘C’,’F’, ‘A’, ‘K’}, optional</p>
<blockquote>
<div>The elements of <cite>a</cite> are read using this index order. ‘C’ means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  ‘F’ means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  ‘A’ means to read the elements in
Fortran-like index order if <cite>a</cite> is Fortran <em>contiguous</em> in
memory, C-like order otherwise.  ‘K’ means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, ‘C’
index order is used.</div></blockquote>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>y is an array of the same subtype as <cite>a</cite>, with shape <code class="docutils literal"><span class="pre">(a.size,)</span></code>.
Note that matrices are special cased for backward compatibility, if <cite>a</cite>
is a matrix, then y is a 1-D ndarray.</dd>
</dl>
<p>ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array</p>
<blockquote>
<div>in row-major order.</div></blockquote>
<p>ndarray.reshape : Change the shape of an array without changing its data.</p>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code class="docutils literal"><span class="pre">arr.reshape(-1)</span></code>
may be preferable.</p>
<p>It is equivalent to <code class="docutils literal"><span class="pre">reshape(-1,</span> <span class="pre">order=order)</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">order</span></code> is ‘A’, it will preserve the array’s ‘C’ or ‘F’ ordering:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">order</span></code> is ‘K’, it will preserve orderings that are neither ‘C’
nor ‘F’, but won’t reverse axes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[ 0,  2,  4],</span>
<span class="go">        [ 1,  3,  5]],</span>
<span class="go">       [[ 6,  8, 10],</span>
<span class="go">        [ 7,  9, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>a</em>, <em>repeats</em>, <em>axis=None</em><span class="sig-paren">)</span></dt>
<dd><p>Repeat elements of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>repeats <span class="classifier-delimiter">:</span> <span class="classifier">int or array of ints</span></dt>
<dd>The number of repetitions for each element.  <cite>repeats</cite> is broadcasted
to fit the shape of the given axis.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</dd>
</dl>
<dl class="docutils">
<dt>repeated_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array which has the same shape as <cite>a</cite>, except along
the given axis.</dd>
</dl>
<p>tile : Tile an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">reshape</code><span class="sig-paren">(</span><em>a</em>, <em>newshape</em>, <em>order='C'</em><span class="sig-paren">)</span></dt>
<dd><p>Gives a new shape to an array without changing its data.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be reshaped.</dd>
<dt>newshape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>The new shape should be compatible with the original shape. If
an integer, then the result will be a 1-D array of that length.
One shape dimension can be -1. In this case, the value is
inferred from the length of the array and remaining dimensions.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’}, optional</span></dt>
<dd>Read the elements of <cite>a</cite> using this index order, and place the
elements into the reshaped array using this index order.  ‘C’
means to read / write the elements using C-like index order,
with the last axis index changing fastest, back to the first
axis index changing slowest. ‘F’ means to read / write the
elements using Fortran-like index order, with the first index
changing fastest, and the last index changing slowest. Note that
the ‘C’ and ‘F’ options take no account of the memory layout of
the underlying array, and only refer to the order of indexing.
‘A’ means to read / write the elements in Fortran-like index
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.</dd>
</dl>
<dl class="docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>This will be a new view object if possible; otherwise, it will
be a copy.  Note there is no guarantee of the <em>memory layout</em> (C- or
Fortran- contiguous) of the returned array.</dd>
</dl>
<p>ndarray.reshape : Equivalent method.</p>
<p>It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go"># A transpose makes the array non-contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="go"># Taking a view makes it possible to modify the shape without modifying</span>
<span class="go"># the initial object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">AttributeError: incompatible shape for a non-contiguous array</span>
</pre></div>
</div>
<p>The <cite>order</cite> keyword gives the index ordering both for <em>fetching</em> the values
from <cite>a</cite>, and then <em>placing</em> the values into the output array.
For example, let’s say you have an array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
</pre></div>
</div>
<p>You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># C-like index ordering</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># equivalent to C ravel then C reshape</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1"># Fortran-like index ordering</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>       <span class="c1"># the unspecified value is inferred to be 2</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>a</em>, <em>new_shape</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new
array is filled with repeated copies of <cite>a</cite>.  Note that this behavior
is different from a.resize(new_shape) which fills with zeros instead
of repeated copies of <cite>a</cite>.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be resized.</dd>
<dt>new_shape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span></dt>
<dd>Shape of resized array.</dd>
</dl>
<dl class="docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The new array is formed from the data in the old array, repeated
if necessary to fill out the required number of elements.  The
data are repeated in the order that they are stored in memory.</dd>
</dl>
<p>ndarray.resize : resize an array in-place.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 3],</span>
<span class="go">       [0, 1, 2, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">round_</code><span class="sig-paren">(</span><em>a</em>, <em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>Refer to <cite>around</cite> for full documentation.</p>
<p>around : equivalent function</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">searchsorted</code><span class="sig-paren">(</span><em>a</em>, <em>v</em>, <em>side='left'</em>, <em>sorter=None</em><span class="sig-paren">)</span></dt>
<dd><p>Find indices where elements should be inserted to maintain order.</p>
<p>Find the indices into a sorted array <cite>a</cite> such that, if the
corresponding elements in <cite>v</cite> were inserted before the indices, the
order of <cite>a</cite> would be preserved.</p>
<p>Assuming that <cite>a</cite> is sorted:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>side</cite></th>
<th class="head">returned index <cite>i</cite> satisfies</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>left</td>
<td><code class="docutils literal"><span class="pre">a[i-1]</span> <span class="pre">&lt;</span> <span class="pre">v</span> <span class="pre">&lt;=</span> <span class="pre">a[i]</span></code></td>
</tr>
<tr class="row-odd"><td>right</td>
<td><code class="docutils literal"><span class="pre">a[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">a[i]</span></code></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like</span></dt>
<dd>Input array. If <cite>sorter</cite> is None, then it must be sorted in
ascending order, otherwise <cite>sorter</cite> must be an array of indices
that sort it.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to insert into <cite>a</cite>.</dd>
<dt>side <span class="classifier-delimiter">:</span> <span class="classifier">{‘left’, ‘right’}, optional</span></dt>
<dd>If ‘left’, the index of the first suitable location found is given.
If ‘right’, return the last such index.  If there is no suitable
index, return either 0 or N (where N is the length of <cite>a</cite>).</dd>
<dt>sorter <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like, optional</span></dt>
<dd><p class="first">Optional array of integer indices that sort array a into ascending
order. They are typically the result of argsort.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array of ints</span></dt>
<dd>Array of insertion points with the same shape as <cite>v</cite>.</dd>
</dl>
<p>sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.</p>
<p>Binary search is used to find the required insertion points.</p>
<p>As of NumPy 1.4.0 <cite>searchsorted</cite> works with real/complex arrays containing
<cite>nan</cite> values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p>This function is a faster version of the builtin python <cite>bisect.bisect_left</cite>
(<code class="docutils literal"><span class="pre">side='left'</span></code>) and <cite>bisect.bisect_right</cite> (<code class="docutils literal"><span class="pre">side='right'</span></code>) functions,
which is also vectorized in the <cite>v</cite> argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([0, 5, 1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">shape</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span></dt>
<dd><p>Return the shape of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The elements of the shape tuple give the lengths of the
corresponding array dimensions.</dd>
</dl>
<p>alen
ndarray.shape : Equivalent array method.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(1,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(2,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">size</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the number of elements along a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the elements are counted.  By default, give
the total number of elements.</dd>
</dl>
<dl class="docutils">
<dt>element_count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of elements along the specified axis.</dd>
</dl>
<p>shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">sometrue</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Check whether some values are true.</p>
<p>Refer to <cite>any</cite> for full documentation.</p>
<p>any : equivalent function; see for details.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">sort</code><span class="sig-paren">(</span><em>a</em>, <em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return a sorted copy of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm. Default is ‘quicksort’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<dl class="docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.</p>
<p>The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="14%" />
<col width="25%" />
<col width="24%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">kind</th>
<th class="head">speed</th>
<th class="head">worst case</th>
<th class="head">work space</th>
<th class="head">stable</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘quicksort’</td>
<td>1</td>
<td>O(n^2)</td>
<td>0</td>
<td>no</td>
</tr>
<tr class="row-odd"><td>‘mergesort’</td>
<td>2</td>
<td>O(n*log(n))</td>
<td>~n/2</td>
<td>yes</td>
</tr>
<tr class="row-even"><td>‘heapsort’</td>
<td>3</td>
<td>O(n*log(n))</td>
<td>0</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.</p>
<p>Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:</p>
<blockquote>
<div><ul class="simple">
<li>Real: [R, nan]</li>
<li>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</li>
</ul>
</div></blockquote>
<p>where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>quicksort has been changed to an introsort which will switch
heapsort when it does not make enough progress. This makes its
worst case O(n*log(n)).</p>
<p>‘stable’ automatically choses the best stable sorting algorithm
for the data type being sorted. It is currently mapped to
merge sort.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                <span class="c1"># sort along the last axis</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># sort the flattened array</span>
<span class="go">array([1, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># sort along the first axis</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S10&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Arthur&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Lancelot&#39;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="s1">&#39;Galahad&#39;</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">38</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>       <span class="c1"># create a structured array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>                        
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="go">       (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<p>Sort by age, then height if ages are equal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>               
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="go">       (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">squeeze</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span></dt>
<dd><p>Remove single-dimensional entries from the shape of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>squeezed <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <cite>a</cite> itself
or a view into <cite>a</cite>.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>axis</cite> is not <cite>None</cite>, and an axis being squeezed is not of length 1</dd>
</dl>
<p>expand_dims : The inverse operation, adding singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot select an axis to squeeze out which has size not equal to one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">std</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the standard deviation along the specified axis.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Calculate the standard deviation of these values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the standard deviation is computed. The
default is to compute the standard deviation of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of elements.
By default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>std</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>standard_deviation <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above.</span></dt>
<dd>If <cite>out</cite> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</dd>
</dl>
<p>var, mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <code class="docutils literal"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is specified,
the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard statistical
practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the variance
of the infinite population. <code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the <cite>dtype</cite> keyword can
alleviate this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.1180339887498949</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.5,  0.5])</span>
</pre></div>
</div>
<p>In single precision, std() can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.45000005</span>
</pre></div>
</div>
<p>Computing the standard deviation in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.44999999925494177</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">sum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em>, <em>initial=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Sum of array elements over a given axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Elements to sum.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which a sum is performed.  The default,
axis=None, will sum all of the elements of the input array.  If
axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>sum</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd><p class="first">Starting value for the sum. See <cite>~numpy.ufunc.reduce</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>sum_along_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</dd>
</dl>
<p>ndarray.sum : Equivalent method.</p>
<p>cumsum : Cumulative sum of array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>mean, average</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">swapaxes</code><span class="sig-paren">(</span><em>a</em>, <em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span></dt>
<dd><p>Interchange two axes of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>First axis.</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Second axis.</dd>
</dl>
<dl class="docutils">
<dt>a_swapped <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>For NumPy &gt;= 1.10.0, if <cite>a</cite> is an ndarray, then a view of <cite>a</cite> is
returned; otherwise a new array is created. For earlier NumPy
versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[[0, 4],</span>
<span class="go">        [2, 6]],</span>
<span class="go">       [[1, 5],</span>
<span class="go">        [3, 7]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">take</code><span class="sig-paren">(</span><em>a</em>, <em>indices</em>, <em>axis=None</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span></dt>
<dd><p>Take elements from an array along an axis.</p>
<p>When axis is not None, this function does the same thing as “fancy”
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code class="docutils literal"><span class="pre">np.take(arr,</span> <span class="pre">indices,</span> <span class="pre">axis=3)</span></code> is equivalent to
<code class="docutils literal"><span class="pre">arr[:,:,:,indices,...]</span></code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <cite>ndindex</cite>, which sets each of <code class="docutils literal"><span class="pre">ii</span></code>, <code class="docutils literal"><span class="pre">jj</span></code>, and <code class="docutils literal"><span class="pre">kk</span></code> to a tuple of
indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">Nj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],)</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like (Ni…, M, Nk…)</span></dt>
<dd>The source array.</dd>
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array_like (Nj…)</span></dt>
<dd><p class="first">The indices of the values to extract.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<p class="last">Also allow scalars for indices.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis over which to select values. By default, the flattened
input array is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional (Ni…, Nj…, Nk…)</span></dt>
<dd>If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li>‘raise’ – raise an error (default)</li>
<li>‘wrap’ – wrap around</li>
<li>‘clip’ – clip to the range</li>
</ul>
<p class="last">‘clip’ mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (Ni…, Nj…, Nk…)</span></dt>
<dd>The returned array has the same type as <cite>a</cite>.</dd>
</dl>
<p>compress : Take elements using a boolean mask
ndarray.take : equivalent method
take_along_axis : Take elements by matching the array and the index arrays</p>
<p>By eliminating the inner loop in the description above, and using <cite>s_</cite> to
build simple slice objects, <cite>take</cite> can be expressed  in terms of applying
fancy indexing to each 1-d slice:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
</pre></div>
</div>
<p>For this reason, it is equivalent to (but faster than) the following use
of <cite>apply_along_axis</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a_1d</span><span class="p">:</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>In this example if <cite>a</cite> is an ndarray, “fancy” indexing can be used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>If <cite>indices</cite> is not one dimensional, the output also has these dimensions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>a</em>, <em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>If <cite>a</cite> is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements <code class="docutils literal"><span class="pre">a[i,i+offset]</span></code> for all i.</p>
<p>If <cite>a</cite> has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of <cite>a</cite> with <cite>axis1</cite>
and <cite>axis2</cite> removed.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array, from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to 0.</dd>
<dt>axis1, axis2 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of <cite>a</cite>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and <cite>a</cite> is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of <cite>a</cite>.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Array into which the output is placed. Its type is preserved and
it must be of the right shape to hold the output.</dd>
</dl>
<dl class="docutils">
<dt>sum_along_diagonals <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>If <cite>a</cite> is 2-D, the sum along the diagonal is returned.  If <cite>a</cite> has
larger dimensions, then an array of sums along diagonals is returned.</dd>
</dl>
<p>diag, diagonal, diagflat</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([6, 8])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>a</em>, <em>axes=None</em><span class="sig-paren">)</span></dt>
<dd><p>Permute the dimensions of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">list of ints, optional</span></dt>
<dd>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</dd>
</dl>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>a</cite> with its axes permuted.  A view is returned whenever
possible.</dd>
</dl>
<p>moveaxis
argsort</p>
<p>Use <cite>transpose(a, argsort(axes))</cite> to invert the transposition of tensors
when using the <cite>axes</cite> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 3]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">var</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float32</cite>; for arrays of float types it is the same as
the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of elements. By
default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>var</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>variance <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <code class="docutils literal"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</dd>
</dl>
<p>std , mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.20249999932944759</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.2025</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.record">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">record</code><a class="headerlink" href="#numpy.record" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.void" title="numpy.void"><code class="xref py py-class docutils literal"><span class="pre">numpy.void</span></code></a></p>
<p>A data-type scalar that allows field access as attribute lookup.</p>
<dl class="method">
<dt id="numpy.record.pprint">
<code class="descname">pprint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.record.pprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print all fields.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.recarray">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">recarray</code><a class="headerlink" href="#numpy.recarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a></p>
<p>Construct an ndarray that allows field access using attributes.</p>
<p>Arrays may have a data-types containing fields, analogous
to columns in a spread sheet.  An example is <code class="docutils literal"><span class="pre">[(x,</span> <span class="pre">int),</span> <span class="pre">(y,</span> <span class="pre">float)]</span></code>,
where each entry in the array is a pair of <code class="docutils literal"><span class="pre">(int,</span> <span class="pre">float)</span></code>.  Normally,
these attributes are accessed using dictionary lookups such as <code class="docutils literal"><span class="pre">arr['x']</span></code>
and <code class="docutils literal"><span class="pre">arr['y']</span></code>.  Record arrays allow the fields to be accessed as members
of the array, using <code class="docutils literal"><span class="pre">arr.x</span></code> and <code class="docutils literal"><span class="pre">arr.y</span></code>.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Shape of output array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The desired data-type.  By default, the data-type is determined
from <cite>formats</cite>, <cite>names</cite>, <cite>titles</cite>, <cite>aligned</cite> and <cite>byteorder</cite>.</dd>
<dt>formats <span class="classifier-delimiter">:</span> <span class="classifier">list of data-types, optional</span></dt>
<dd>A list containing the data-types for the different columns, e.g.
<code class="docutils literal"><span class="pre">['i4',</span> <span class="pre">'f8',</span> <span class="pre">'i4']</span></code>.  <cite>formats</cite> does <em>not</em> support the new
convention of using types directly, i.e. <code class="docutils literal"><span class="pre">(int,</span> <span class="pre">float,</span> <span class="pre">int)</span></code>.
Note that <cite>formats</cite> must be a list, not a tuple.
Given that <cite>formats</cite> is somewhat limited, we recommend specifying
<cite>dtype</cite> instead.</dd>
<dt>names <span class="classifier-delimiter">:</span> <span class="classifier">tuple of str, optional</span></dt>
<dd>The name of each column, e.g. <code class="docutils literal"><span class="pre">('x',</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code>.</dd>
<dt>buf <span class="classifier-delimiter">:</span> <span class="classifier">buffer, optional</span></dt>
<dd>By default, a new array is created of the given shape and data-type.
If <cite>buf</cite> is specified and is an object exposing the buffer interface,
the array will use the memory from the existing buffer.  In this case,
the <cite>offset</cite> and <cite>strides</cite> keywords are available.</dd>
</dl>
<dl class="docutils">
<dt>titles <span class="classifier-delimiter">:</span> <span class="classifier">tuple of str, optional</span></dt>
<dd>Aliases for column names.  For example, if <cite>names</cite> were
<code class="docutils literal"><span class="pre">('x',</span> <span class="pre">'y',</span> <span class="pre">'z')</span></code> and <cite>titles</cite> is
<code class="docutils literal"><span class="pre">('x_coordinate',</span> <span class="pre">'y_coordinate',</span> <span class="pre">'z_coordinate')</span></code>, then
<code class="docutils literal"><span class="pre">arr['x']</span></code> is equivalent to both <code class="docutils literal"><span class="pre">arr.x</span></code> and <code class="docutils literal"><span class="pre">arr.x_coordinate</span></code>.</dd>
<dt>byteorder <span class="classifier-delimiter">:</span> <span class="classifier">{‘&lt;’, ‘&gt;’, ‘=’}, optional</span></dt>
<dd>Byte-order for all fields.</dd>
<dt>aligned <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Align the fields in memory as the C-compiler would.</dd>
<dt>strides <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, optional</span></dt>
<dd>Buffer (<cite>buf</cite>) is interpreted according to these strides (strides
define how many bytes each array element, row, column, etc.
occupy in memory).</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Start reading buffer (<cite>buf</cite>) from this offset onwards.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Row-major (C-style) or column-major (Fortran-style) order.</dd>
</dl>
<dl class="docutils">
<dt>rec <span class="classifier-delimiter">:</span> <span class="classifier">recarray</span></dt>
<dd>Empty array of the given shape and type.</dd>
</dl>
<p>rec.fromrecords : Construct a record array from data.
record : fundamental data-type for <cite>recarray</cite>.
format_parser : determine a data-type from formats, names, titles.</p>
<p>This constructor can be compared to <code class="docutils literal"><span class="pre">empty</span></code>: it creates a new record
array but does not fill it with data.  To create a record array from data,
use one of the following methods:</p>
<ol class="arabic simple">
<li>Create a standard ndarray and convert it to a record array,
using <code class="docutils literal"><span class="pre">arr.view(np.recarray)</span></code></li>
<li>Use the <cite>buf</cite> keyword.</li>
<li>Use <cite>np.rec.fromrecords</cite>.</li>
</ol>
<p>Create an array with two fields, <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1.0, 2), (3.0, 4)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;f8&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">array([ 1.,  3.])</span>
</pre></div>
</div>
<p>View the array as a record array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  3.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">y</span>
<span class="go">array([2, 4])</span>
</pre></div>
</div>
<p>Create a new, empty record array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span>
<span class="gp">... </span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span> 
<span class="go">rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),</span>
<span class="go">       (3471280, 1.2134086255804012e-316, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;f8&#39;), (&#39;z&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.recarray.field">
<code class="descname">field</code><span class="sig-paren">(</span><em>attr</em>, <em>val=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recarray.field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.format_parser">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">format_parser</code><span class="sig-paren">(</span><em>formats</em>, <em>names</em>, <em>titles</em>, <em>aligned=False</em>, <em>byteorder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.format_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class to convert formats, names, titles description to a dtype.</p>
<p>After constructing the format_parser object, the dtype attribute is
the converted data-type:
<code class="docutils literal"><span class="pre">dtype</span> <span class="pre">=</span> <span class="pre">format_parser(formats,</span> <span class="pre">names,</span> <span class="pre">titles).dtype</span></code></p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The converted data-type.</dd>
</dl>
<dl class="docutils">
<dt>formats <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str</span></dt>
<dd>The format description, either specified as a string with
comma-separated format descriptions in the form <code class="docutils literal"><span class="pre">'f8,</span> <span class="pre">i4,</span> <span class="pre">a5'</span></code>, or
a list of format description strings  in the form
<code class="docutils literal"><span class="pre">['f8',</span> <span class="pre">'i4',</span> <span class="pre">'a5']</span></code>.</dd>
<dt>names <span class="classifier-delimiter">:</span> <span class="classifier">str or list/tuple of str</span></dt>
<dd>The field names, either specified as a comma-separated string in the
form <code class="docutils literal"><span class="pre">'col1,</span> <span class="pre">col2,</span> <span class="pre">col3'</span></code>, or as a list or tuple of strings in the
form <code class="docutils literal"><span class="pre">['col1',</span> <span class="pre">'col2',</span> <span class="pre">'col3']</span></code>.
An empty list can be used, in that case default field names
(‘f0’, ‘f1’, …) are used.</dd>
<dt>titles <span class="classifier-delimiter">:</span> <span class="classifier">sequence</span></dt>
<dd>Sequence of title strings. An empty list can be used to leave titles
out.</dd>
<dt>aligned <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, align the fields by padding as the C-compiler would.
Default is False.</dd>
<dt>byteorder <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>If specified, all the fields will be changed to the
provided byte-order.  Otherwise, the default byte-order is
used. For all available string specifiers, see <cite>dtype.newbyteorder</cite>.</dd>
</dl>
<p>dtype, typename, sctype2char</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;a5&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="s1">&#39;col3&#39;</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="s1">&#39;T1&#39;</span><span class="p">,</span> <span class="s1">&#39;T2&#39;</span><span class="p">,</span> <span class="s1">&#39;T3&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([((&#39;T1&#39;, &#39;col1&#39;), &#39;&lt;f8&#39;), ((&#39;T2&#39;, &#39;col2&#39;), &#39;&lt;i4&#39;),</span>
<span class="go">       ((&#39;T3&#39;, &#39;col3&#39;), &#39;|S5&#39;)])</span>
</pre></div>
</div>
<p><cite>names</cite> and/or <cite>titles</cite> can be empty lists. If <cite>titles</cite> is an empty list,
titles will simply not appear. If <cite>names</cite> is empty, default field names
will be used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;a5&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;col2&#39;</span><span class="p">,</span> <span class="s1">&#39;col3&#39;</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([(&#39;col1&#39;, &#39;&lt;f8&#39;), (&#39;col2&#39;, &#39;&lt;i4&#39;), (&#39;col3&#39;, &#39;|S5&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">([</span><span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;a5&#39;</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype([(&#39;f0&#39;, &#39;&lt;f8&#39;), (&#39;f1&#39;, &#39;&lt;i4&#39;), (&#39;f2&#39;, &#39;|S5&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.chararray">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">chararray</code><a class="headerlink" href="#numpy.chararray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a></p>
<dl class="docutils">
<dt>chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,</dt>
<dd>strides=None, order=None)</dd>
</dl>
<p>Provides a convenient view on arrays of string and unicode values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>chararray</cite> class exists for backwards compatibility with
Numarray, it is not recommended for new development. Starting from numpy
1.4, if one needs arrays of strings, it is recommended to use arrays of
<cite>dtype</cite> <cite>object_</cite>, <cite>string_</cite> or <cite>unicode_</cite>, and use the free functions
in the <cite>numpy.char</cite> module for fast vectorized string operations.</p>
</div>
<p>Versus a regular NumPy array of type <cite>str</cite> or <cite>unicode</cite>, this
class adds the following functionality:</p>
<blockquote>
<div><ol class="arabic simple">
<li>values automatically have whitespace removed from the end
when indexed</li>
<li>comparison operators automatically remove whitespace from the
end when comparing values</li>
<li>vectorized string operations are provided as methods
(e.g. <cite>.endswith</cite>) and infix operators (e.g. <code class="docutils literal"><span class="pre">&quot;+&quot;,</span> <span class="pre">&quot;*&quot;,</span> <span class="pre">&quot;%&quot;</span></code>)</li>
</ol>
</div></blockquote>
<p>chararrays should be created using <cite>numpy.char.array</cite> or
<cite>numpy.char.asarray</cite>, rather than this constructor directly.</p>
<p>This constructor creates the array, using <cite>buffer</cite> (with <cite>offset</cite>
and <cite>strides</cite>) if it is not <code class="docutils literal"><span class="pre">None</span></code>. If <cite>buffer</cite> is <code class="docutils literal"><span class="pre">None</span></code>, then
constructs a new array with <cite>strides</cite> in “C order”, unless both
<code class="docutils literal"><span class="pre">len(shape)</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> and <code class="docutils literal"><span class="pre">order='Fortran'</span></code>, in which case <cite>strides</cite>
is in “Fortran order”.</p>
<p>astype
argsort
copy
count
decode
dump
dumps
encode
endswith
expandtabs
fill
find
flatten
getfield
index
isalnum
isalpha
isdecimal
isdigit
islower
isnumeric
isspace
istitle
isupper
item
join
ljust
lower
lstrip
nonzero
put
ravel
repeat
replace
reshape
resize
rfind
rindex
rjust
rsplit
rstrip
searchsorted
setfield
setflags
sort
split
splitlines
squeeze
startswith
strip
swapaxes
swapcase
take
title
tofile
tolist
tostring
translate
transpose
upper
view
zfill</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Shape of the array.</dd>
<dt>itemsize <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Length of each array element, in number of characters. Default is 1.</dd>
<dt>unicode <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Are the array elements of type unicode (True) or string (False).
Default is False.</dd>
<dt>buffer <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Memory address of the start of the array data.  Default is None,
in which case a new array is created.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Fixed stride displacement from the beginning of an axis?
Default is 0. Needs to be &gt;=0.</dd>
<dt>strides <span class="classifier-delimiter">:</span> <span class="classifier">array_like of ints, optional</span></dt>
<dd>Strides for the array (see <cite>ndarray.strides</cite> for full description).
Default is None.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>The order in which the array data is stored in memory: ‘C’ -&gt;
“row major” order (the default), ‘F’ -&gt; “column major”
(Fortran) order.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">chararray</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span><span class="p">[:]</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span>
<span class="go">chararray([[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;],</span>
<span class="go">       [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;],</span>
<span class="go">       [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]],</span>
<span class="go">      dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">chararray</span><span class="p">(</span><span class="n">charar</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span><span class="p">[:]</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">charar</span>
<span class="go">chararray([[&#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;],</span>
<span class="go">       [&#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;],</span>
<span class="go">       [&#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;]],</span>
<span class="go">      dtype=&#39;|S5&#39;)</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.chararray.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.argsort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="numpy.chararray.capitalize">
<code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.capitalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <cite>self</cite> with only the first character of each element
capitalized.</p>
<p>char.capitalize</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>width</em>, <em>fillchar=' '</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <cite>self</cite> with its elements centered in a
string of length <cite>width</cite>.</p>
<p>center</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>sub</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with the number of non-overlapping occurrences of
substring <cite>sub</cite> in the range [<cite>start</cite>, <cite>end</cite>].</p>
<p>char.count</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <cite>str.decode</cite> element-wise.</p>
<p>char.decode</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.encode">
<code class="descname">encode</code><span class="sig-paren">(</span><em>encoding=None</em>, <em>errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <cite>str.encode</cite> element-wise.</p>
<p>char.encode</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.endswith">
<code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.endswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array which is <cite>True</cite> where the string element
in <cite>self</cite> ends with <cite>suffix</cite>, otherwise <cite>False</cite>.</p>
<p>char.endswith</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.expandtabs">
<code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.expandtabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of each string element where all tab characters are
replaced by one or more spaces.</p>
<p>char.expandtabs</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>sub</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.find" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element, return the lowest index in the string where
substring <cite>sub</cite> is found.</p>
<p>char.find</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>sub</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>find</cite>, but raises <cite>ValueError</cite> when the substring is not found.</p>
<p>char.index</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isalnum">
<code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isalnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string
are alphanumeric and there is at least one character, false
otherwise.</p>
<p>char.isalnum</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isalpha">
<code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string
are alphabetic and there is at least one character, false
otherwise.</p>
<p>char.isalpha</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isdecimal">
<code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isdecimal" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return True if there are only
decimal characters in the element.</p>
<p>char.isdecimal</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isdigit">
<code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isdigit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all characters in the string are
digits and there is at least one character, false otherwise.</p>
<p>char.isdigit</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.islower">
<code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.islower" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all cased characters in the
string are lowercase and there is at least one cased character,
false otherwise.</p>
<p>char.islower</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isnumeric">
<code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isnumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return True if there are only
numeric characters in the element.</p>
<p>char.isnumeric</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isspace">
<code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if there are only whitespace
characters in the string and there is at least one character,
false otherwise.</p>
<p>char.isspace</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.istitle">
<code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.istitle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if the element is a titlecased
string and there is at least one character, false otherwise.</p>
<p>char.istitle</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.isupper">
<code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.isupper" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true for each element if all cased characters in the
string are uppercase and there is at least one character, false
otherwise.</p>
<p>char.isupper</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string which is the concatenation of the strings in the
sequence <cite>seq</cite>.</p>
<p>char.join</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.ljust">
<code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em>, <em>fillchar=' '</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.ljust" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> left-justified in a
string of length <cite>width</cite>.</p>
<p>char.ljust</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.lower">
<code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> converted to
lowercase.</p>
<p>char.lower</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.lstrip">
<code class="descname">lstrip</code><span class="sig-paren">(</span><em>chars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the leading characters
removed.</p>
<p>char.lstrip</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.partition">
<code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition each element in <cite>self</cite> around <cite>sep</cite>.</p>
<p>partition</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em>, <em>count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string with all
occurrences of substring <cite>old</cite> replaced by <cite>new</cite>.</p>
<p>char.replace</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rfind">
<code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return the highest index in the string
where substring <cite>sub</cite> is found, such that <cite>sub</cite> is contained
within [<cite>start</cite>, <cite>end</cite>].</p>
<p>char.rfind</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rindex">
<code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>rfind</cite>, but raises <cite>ValueError</cite> when the substring <cite>sub</cite> is
not found.</p>
<p>char.rindex</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rjust">
<code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em>, <em>fillchar=' '</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite>
right-justified in a string of length <cite>width</cite>.</p>
<p>char.rjust</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rpartition">
<code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition each element in <cite>self</cite> around <cite>sep</cite>.</p>
<p>rpartition</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rsplit">
<code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the words in
the string, using <cite>sep</cite> as the delimiter string.</p>
<p>char.rsplit</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.rstrip">
<code class="descname">rstrip</code><span class="sig-paren">(</span><em>chars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the trailing
characters removed.</p>
<p>char.rstrip</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.split" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the words in the
string, using <cite>sep</cite> as the delimiter string.</p>
<p>char.split</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.splitlines">
<code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.splitlines" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a list of the lines in the
element, breaking at line boundaries.</p>
<p>char.splitlines</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.startswith">
<code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em>, <em>start=0</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array which is <cite>True</cite> where the string element
in <cite>self</cite> starts with <cite>prefix</cite>, otherwise <cite>False</cite>.</p>
<p>char.startswith</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.strip">
<code class="descname">strip</code><span class="sig-paren">(</span><em>chars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy with the leading and
trailing characters removed.</p>
<p>char.strip</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.swapcase">
<code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.swapcase" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string with
uppercase characters converted to lowercase and vice versa.</p>
<p>char.swapcase</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.title">
<code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.title" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a titlecased version of the
string: words start with uppercase characters, all remaining cased
characters are lowercase.</p>
<p>char.title</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>deletechars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>For each element in <cite>self</cite>, return a copy of the string where
all characters occurring in the optional argument
<cite>deletechars</cite> are removed, and the remaining characters have
been mapped through the given translation table.</p>
<p>char.translate</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.upper">
<code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array with the elements of <cite>self</cite> converted to
uppercase.</p>
<p>char.upper</p>
</dd></dl>

<dl class="method">
<dt id="numpy.chararray.zfill">
<code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.chararray.zfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the numeric string left-filled with zeros in a string of
length <cite>width</cite>.</p>
<p>char.zfill</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.logspace">
<code class="descclassname">numpy.</code><code class="descname">logspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>endpoint=True</em>, <em>base=10.0</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.logspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale.</p>
<p>In linear space, the sequence starts at <code class="docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></code>
(<cite>base</cite> to the power of <cite>start</cite>) and ends with <code class="docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></code>
(see <cite>endpoint</cite> below).</p>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><code class="docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></code> is the starting value of the sequence.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><code class="docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></code> is the final value of the sequence, unless <cite>endpoint</cite>
is False.  In that case, <code class="docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <cite>num</cite>) are returned.</dd>
<dt>num <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd>Number of samples to generate.  Default is 50.</dd>
<dt>endpoint <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If true, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</dd>
<dt>base <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>The base of the log space. The step size between the elements in
<code class="docutils literal"><span class="pre">ln(samples)</span> <span class="pre">/</span> <span class="pre">ln(base)</span></code> (or <code class="docutils literal"><span class="pre">log_base(samples)</span></code>) is uniform.
Default is 10.0.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>num</cite> samples, equally spaced on a log scale.</dd>
</dl>
<dl class="docutils">
<dt>arange <span class="classifier-delimiter">:</span> <span class="classifier">Similar to linspace, with the step size specified instead of the</span></dt>
<dd>number of samples. Note that, when used with a float endpoint, the
endpoint may or may not be included.</dd>
<dt>linspace <span class="classifier-delimiter">:</span> <span class="classifier">Similar to logspace, but with the samples uniformly distributed</span></dt>
<dd>in linear space, instead of log space.</dd>
</dl>
<p>geomspace : Similar to logspace, but with endpoints specified directly.</p>
<p>Logspace is equivalent to the code</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">)</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([  100.        ,   215.443469  ,   464.15888336,  1000.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ])</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.linspace">
<code class="descclassname">numpy.</code><code class="descname">linspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>endpoint=True</em>, <em>retstep=False</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <cite>num</cite> evenly spaced samples, calculated over the
interval [<cite>start</cite>, <cite>stop</cite>].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The starting value of the sequence.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The end value of the sequence, unless <cite>endpoint</cite> is set to False.
In that case, the sequence consists of all but the last of <code class="docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code>
evenly spaced samples, so that <cite>stop</cite> is excluded.  Note that the step
size changes when <cite>endpoint</cite> is False.</dd>
<dt>num <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of samples to generate. Default is 50. Must be non-negative.</dd>
<dt>endpoint <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</dd>
<dt>retstep <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, return (<cite>samples</cite>, <cite>step</cite>), where <cite>step</cite> is the spacing
between samples.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd><p class="first">The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>There are <cite>num</cite> equally spaced samples in the closed interval
<code class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop]</span></code> or the half-open interval <code class="docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(depending on whether <cite>endpoint</cite> is True or False).</dd>
<dt>step <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first">Only returned if <cite>retstep</cite> is True</p>
<p class="last">Size of spacing between samples.</p>
</dd>
</dl>
<dl class="docutils">
<dt>arange <span class="classifier-delimiter">:</span> <span class="classifier">Similar to <cite>linspace</cite>, but uses a step size (instead of the</span></dt>
<dd>number of samples).</dd>
</dl>
<p>logspace : Samples uniformly distributed in log space.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 2. ,  2.2,  2.4,  2.6,  2.8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.geomspace">
<code class="descclassname">numpy.</code><code class="descname">geomspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>endpoint=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.geomspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale (a geometric progression).</p>
<p>This is similar to <cite>logspace</cite>, but with endpoints specified directly.
Each output sample is a constant multiple of the previous.</p>
<dl class="docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The starting value of the sequence.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The final value of the sequence, unless <cite>endpoint</cite> is False.
In that case, <code class="docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></code> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <cite>num</cite>) are returned.</dd>
<dt>num <span class="classifier-delimiter">:</span> <span class="classifier">integer, optional</span></dt>
<dd>Number of samples to generate.  Default is 50.</dd>
<dt>endpoint <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If true, <cite>stop</cite> is the last sample. Otherwise, it is not included.
Default is True.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd>The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</dd>
</dl>
<dl class="docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>num</cite> samples, equally spaced on a log scale.</dd>
</dl>
<dl class="docutils">
<dt>logspace <span class="classifier-delimiter">:</span> <span class="classifier">Similar to geomspace, but with endpoints specified using log</span></dt>
<dd>and base.</dd>
<dt>linspace <span class="classifier-delimiter">:</span> <span class="classifier">Similar to geomspace, but with arithmetic instead of geometric</span></dt>
<dd>progression.</dd>
<dt>arange <span class="classifier-delimiter">:</span> <span class="classifier">Similar to linspace, with the step size specified instead of the</span></dt>
<dd>number of samples.</dd>
</dl>
<p>If the inputs or dtype are complex, the output will follow a logarithmic
spiral in the complex plane.  (There are an infinite number of spirals
passing through two points; the output will follow the shortest such path.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([    1.,    10.,   100.,  1000.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.,   10.,  100.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="go">array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])</span>
</pre></div>
</div>
<p>Note that the above may not produce exact integers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   7,  16,  32,  63, 127, 256])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   8,  16,  32,  64, 128, 256])</span>
</pre></div>
</div>
<p>Negative, decreasing, and complex inputs are allowed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([ 1000.,   100.,    10.,     1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([-1000.,  -100.,   -10.,    -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1000</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Straight line</span>
<span class="go">array([ 0.   +1.j,  0.  +10.j,  0. +100.j,  0.+1000.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Circle</span>
<span class="go">array([-1.00000000+0.j        , -0.70710678+0.70710678j,</span>
<span class="go">        0.00000000+1.j        ,  0.70710678+0.70710678j,</span>
<span class="go">        1.00000000+0.j        ])</span>
</pre></div>
</div>
<p>Graphical illustration of <code class="docutils literal"><span class="pre">endpoint</span></code> parameter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;0.7&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.MachAr">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">MachAr</code><span class="sig-paren">(</span><em>float_conv=&lt;class 'float'&gt;</em>, <em>int_conv=&lt;class 'int'&gt;</em>, <em>float_to_float=&lt;class 'float'&gt;</em>, <em>float_to_str=&lt;function MachAr.&lt;lambda&gt;&gt;</em>, <em>title='Python floating point number'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.MachAr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Diagnosing machine parameters.</p>
<dl class="docutils">
<dt>ibeta <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Radix in which numbers are represented.</dd>
<dt>it <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of base-<cite>ibeta</cite> digits in the floating point mantissa M.</dd>
<dt>machep <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Exponent of the smallest (most negative) power of <cite>ibeta</cite> that,
added to 1.0, gives something different from 1.0</dd>
<dt>eps <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Floating-point number <code class="docutils literal"><span class="pre">beta**machep</span></code> (floating point precision)</dd>
<dt>negep <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Exponent of the smallest power of <cite>ibeta</cite> that, subtracted
from 1.0, gives something different from 1.0.</dd>
<dt>epsneg <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Floating-point number <code class="docutils literal"><span class="pre">beta**negep</span></code>.</dd>
<dt>iexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of bits in the exponent (including its sign and bias).</dd>
<dt>minexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Smallest (most negative) power of <cite>ibeta</cite> consistent with there
being no leading zeros in the mantissa.</dd>
<dt>xmin <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Floating point number <code class="docutils literal"><span class="pre">beta**minexp</span></code> (the smallest [in
magnitude] usable floating value).</dd>
<dt>maxexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Smallest (positive) power of <cite>ibeta</cite> that causes overflow.</dd>
<dt>xmax <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><code class="docutils literal"><span class="pre">(1-epsneg)</span> <span class="pre">*</span> <span class="pre">beta**maxexp</span></code> (the largest [in magnitude]
usable floating value).</dd>
<dt>irnd <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>In <code class="docutils literal"><span class="pre">range(6)</span></code>, information on what kind of rounding is done
in addition, and on how underflow is handled.</dd>
<dt>ngrd <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of ‘guard digits’ used when truncating the product
of two mantissas to fit the representation.</dd>
<dt>epsilon <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Same as <cite>eps</cite>.</dd>
<dt>tiny <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Same as <cite>xmin</cite>.</dd>
<dt>huge <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Same as <cite>xmax</cite>.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><code class="docutils literal"><span class="pre">-</span> <span class="pre">int(-log10(eps))</span></code></dd>
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><code class="docutils literal"><span class="pre">-</span> <span class="pre">10**(-precision)</span></code></dd>
</dl>
<dl class="docutils">
<dt>float_conv <span class="classifier-delimiter">:</span> <span class="classifier">function, optional</span></dt>
<dd>Function that converts an integer or integer array to a float
or float array. Default is <cite>float</cite>.</dd>
<dt>int_conv <span class="classifier-delimiter">:</span> <span class="classifier">function, optional</span></dt>
<dd>Function that converts a float or float array to an integer or
integer array. Default is <cite>int</cite>.</dd>
<dt>float_to_float <span class="classifier-delimiter">:</span> <span class="classifier">function, optional</span></dt>
<dd>Function that converts a float array to float. Default is <cite>float</cite>.
Note that this does not seem to do anything useful in the current
implementation.</dd>
<dt>float_to_str <span class="classifier-delimiter">:</span> <span class="classifier">function, optional</span></dt>
<dd>Function that converts a single float to a string. Default is
<code class="docutils literal"><span class="pre">lambda</span> <span class="pre">v:'%24.16e'</span> <span class="pre">%v</span></code>.</dd>
<dt>title <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Title that is printed in the string representation of <cite>MachAr</cite>.</dd>
</dl>
<p>finfo : Machine limits for floating point types.
iinfo : Machine limits for integer types.</p>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Press, Teukolsky, Vetterling and Flannery,
“Numerical Recipes in C++,” 2nd ed,
Cambridge University Press, 2002, p. 31.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="numpy.finfo">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">finfo</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.finfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Machine limits for floating point types.</p>
<dl class="docutils">
<dt>bits <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of bits occupied by the type.</dd>
<dt>eps <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The smallest representable positive number such that
<code class="docutils literal"><span class="pre">1.0</span> <span class="pre">+</span> <span class="pre">eps</span> <span class="pre">!=</span> <span class="pre">1.0</span></code>.  Type of <cite>eps</cite> is an appropriate floating
point type.</dd>
<dt>epsneg <span class="classifier-delimiter">:</span> <span class="classifier">floating point number of the appropriate type</span></dt>
<dd>The smallest representable positive number such that
<code class="docutils literal"><span class="pre">1.0</span> <span class="pre">-</span> <span class="pre">epsneg</span> <span class="pre">!=</span> <span class="pre">1.0</span></code>.</dd>
<dt>iexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of bits in the exponent portion of the floating point
representation.</dd>
<dt>machar <span class="classifier-delimiter">:</span> <span class="classifier">MachAr</span></dt>
<dd>The object which calculated these parameters and holds more
detailed information.</dd>
<dt>machep <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The exponent that yields <cite>eps</cite>.</dd>
<dt>max <span class="classifier-delimiter">:</span> <span class="classifier">floating point number of the appropriate type</span></dt>
<dd>The largest representable number.</dd>
<dt>maxexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The smallest positive power of the base (2) that causes overflow.</dd>
<dt>min <span class="classifier-delimiter">:</span> <span class="classifier">floating point number of the appropriate type</span></dt>
<dd>The smallest representable number, typically <code class="docutils literal"><span class="pre">-max</span></code>.</dd>
<dt>minexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The most negative power of the base (2) consistent with there
being no leading 0’s in the mantissa.</dd>
<dt>negep <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The exponent that yields <cite>epsneg</cite>.</dd>
<dt>nexp <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of bits in the exponent including its sign and bias.</dd>
<dt>nmant <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of bits in the mantissa.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The approximate number of decimal digits to which this kind of
float is precise.</dd>
<dt>resolution <span class="classifier-delimiter">:</span> <span class="classifier">floating point number of the appropriate type</span></dt>
<dd>The approximate decimal resolution of this type, i.e.,
<code class="docutils literal"><span class="pre">10**-precision</span></code>.</dd>
<dt>tiny <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The smallest positive usable number.  Type of <cite>tiny</cite> is an
appropriate floating point type.</dd>
</dl>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">float, dtype, or instance</span></dt>
<dd>Kind of floating point data-type about which to get information.</dd>
</dl>
<p>MachAr : The implementation of the tests that produce this information.
iinfo : The equivalent for integer data types.</p>
<p>For developers of NumPy: do not instantiate this at the module level.
The initial calculation of these parameters is expensive and negatively
impacts import times.  These objects are cached, so calling <code class="docutils literal"><span class="pre">finfo()</span></code>
repeatedly inside your functions is not a problem.</p>
</dd></dl>

<dl class="class">
<dt id="numpy.iinfo">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">iinfo</code><span class="sig-paren">(</span><em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Machine limits for integer types.</p>
<dl class="docutils">
<dt>bits <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of bits occupied by the type.</dd>
<dt>min <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The smallest integer expressible by the type.</dd>
<dt>max <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The largest integer expressible by the type.</dd>
</dl>
<dl class="docutils">
<dt>int_type <span class="classifier-delimiter">:</span> <span class="classifier">integer type, dtype, or instance</span></dt>
<dd>The kind of integer data type to get information about.</dd>
</dl>
<p>finfo : The equivalent for floating point data types.</p>
<p>With types:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span><span class="o">.</span><span class="n">min</span>
<span class="go">-32768</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii16</span><span class="o">.</span><span class="n">max</span>
<span class="go">32767</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">min</span>
<span class="go">-2147483648</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">max</span>
<span class="go">2147483647</span>
</pre></div>
</div>
<p>With instances:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">min</span>
<span class="go">-2147483648</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii32</span><span class="o">.</span><span class="n">max</span>
<span class="go">2147483647</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.iinfo.max">
<code class="descname">max</code><a class="headerlink" href="#numpy.iinfo.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum value of given dtype.</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.iinfo.min">
<code class="descname">min</code><a class="headerlink" href="#numpy.iinfo.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum value of given dtype.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.atleast_1d">
<code class="descclassname">numpy.</code><code class="descname">atleast_1d</code><span class="sig-paren">(</span><em>*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
<dl class="docutils">
<dt>arys1, arys2, … <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>One or more input arrays.</dd>
</dl>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array, or list of arrays, each with <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>.
Copies are made only if necessary.</dd>
</dl>
<p>atleast_2d, atleast_3d</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">array([ 1.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.],</span>
<span class="go">       [ 6.,  7.,  8.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[array([1]), array([3, 4])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.atleast_2d">
<code class="descclassname">numpy.</code><code class="descname">atleast_2d</code><span class="sig-paren">(</span><em>*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least two dimensions.</p>
<dl class="docutils">
<dt>arys1, arys2, … <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>One or more array-like sequences.  Non-array inputs are converted
to arrays.  Arrays that already have two or more dimensions are
preserved.</dd>
</dl>
<dl class="docutils">
<dt>res, res2, … <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array, or list of arrays, each with <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</dd>
</dl>
<p>atleast_1d, atleast_3d</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[ 3.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">[array([[1]]), array([[1, 2]]), array([[1, 2]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.atleast_3d">
<code class="descclassname">numpy.</code><code class="descname">atleast_3d</code><span class="sig-paren">(</span><em>*arys</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.atleast_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least three dimensions.</p>
<dl class="docutils">
<dt>arys1, arys2, … <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>One or more array-like sequences.  Non-array inputs are converted to
arrays.  Arrays that already have three or more dimensions are
preserved.</dd>
</dl>
<dl class="docutils">
<dt>res1, res2, … <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array, or list of arrays, each with <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape <code class="docutils literal"><span class="pre">(N,)</span></code> becomes a view
of shape <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>, and a 2-D array of shape <code class="docutils literal"><span class="pre">(M,</span> <span class="pre">N)</span></code> becomes a
view of shape <code class="docutils literal"><span class="pre">(M,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>.</dd>
</dl>
<p>atleast_1d, atleast_2d</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[[ 3.]]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span>  <span class="c1"># x is a reshape, so not base itself</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1 2]]] (1, 1, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.block">
<code class="descclassname">numpy.</code><code class="descname">block</code><span class="sig-paren">(</span><em>arrays</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble an nd-array from nested lists of blocks.</p>
<p>Blocks in the innermost lists are concatenated (see <cite>concatenate</cite>) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.</p>
<p>Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make <code class="docutils literal"><span class="pre">block.ndim</span></code>
the same for all blocks. This is primarily useful for working with scalars,
and means that code like <code class="docutils literal"><span class="pre">np.block([v,</span> <span class="pre">1])</span></code> is valid, where
<code class="docutils literal"><span class="pre">v.ndim</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>When the nested list is two levels deep, this allows block matrices to be
constructed from their components.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.13.0.</span></p>
</div>
<dl class="docutils">
<dt>arrays <span class="classifier-delimiter">:</span> <span class="classifier">nested list of array_like or scalars (but not tuples)</span></dt>
<dd><p class="first">If passed a single ndarray or scalar (a nested list of depth 0), this
is returned unmodified (and not copied).</p>
<p class="last">Elements shapes must match along the appropriate axes (without
broadcasting), but leading 1s will be prepended to the shape as
necessary to make the dimensions match.</p>
</dd>
</dl>
<dl class="docutils">
<dt>block_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">The array assembled from the given blocks.</p>
<p class="last">The dimensionality of the output is equal to the greatest of:
* the dimensionality of all the inputs
* the depth to which the input list is nested</p>
</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd><ul class="first last simple">
<li>If list depths are mismatched - for instance, <code class="docutils literal"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">c]</span></code> is
illegal, and should be spelt <code class="docutils literal"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[c]]</span></code></li>
<li>If lists are empty - for instance, <code class="docutils literal"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[]]</span></code></li>
</ul>
</dd>
</dl>
<p>concatenate : Join a sequence of arrays together.
stack : Stack arrays in sequence along a new dimension.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
vsplit : Split array into a list of multiple sub-arrays vertically.</p>
<p>When called with only scalars, <code class="docutils literal"><span class="pre">np.block</span></code> is equivalent to an ndarray
call. So <code class="docutils literal"><span class="pre">np.block([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code> is equivalent to
<code class="docutils literal"><span class="pre">np.array([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code>.</p>
<p>This function does not enforce that the blocks lie on a fixed grid.
<code class="docutils literal"><span class="pre">np.block([[a,</span> <span class="pre">b],</span> <span class="pre">[c,</span> <span class="pre">d]])</span></code> is not restricted to arrays of the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>But is also allowed to produce, for some <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cDDDD</span>
</pre></div>
</div>
<p>Since concatenation happens along the last axis first, <cite>block</cite> is _not_
capable of producing the following directly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">cccbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>Matlab’s “square bracket stacking”, <code class="docutils literal"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">...;</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...]</span></code>, is
equivalent to <code class="docutils literal"><span class="pre">np.block([[A,</span> <span class="pre">B,</span> <span class="pre">...],</span> <span class="pre">[p,</span> <span class="pre">q,</span> <span class="pre">...]])</span></code>.</p>
<p>The most common use of this function is to build a block matrix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">A</span><span class="p">,</span>               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">B</span>               <span class="p">]</span>
<span class="gp">... </span><span class="p">])</span>
<span class="go">array([[ 2.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  3.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  3.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.,  3.]])</span>
</pre></div>
</div>
<p>With a list of depth 1, <cite>block</cite> can be used as <cite>hstack</cite></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>              <span class="c1"># hstack([1, 2, 3])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>             <span class="c1"># hstack([a, b, 10])</span>
<span class="go">array([1, 2, 3, 2, 3, 4, 10])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">])</span>                 <span class="c1"># hstack([A, B])</span>
<span class="go">array([[1, 1, 2, 2],</span>
<span class="go">       [1, 1, 2, 2]])</span>
</pre></div>
</div>
<p>With a list of depth 2, <cite>block</cite> can be used in place of <cite>vstack</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">]])</span>             <span class="c1"># vstack([a, b])</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">]])</span>             <span class="c1"># vstack([A, B])</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>It can also be used in places of <cite>atleast_1d</cite> and <cite>atleast_2d</cite></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">])</span>                    <span class="c1"># atleast_1d(a)</span>
<span class="go">array([0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>                    <span class="c1"># atleast_1d(b)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(a)</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">b</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(b)</span>
<span class="go">array([[1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.hstack">
<code class="descclassname">numpy.</code><code class="descname">hstack</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence horizontally (column wise).</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by <cite>hsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="docutils">
<dt>tup <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ndarrays</span></dt>
<dd>The arrays must have the same shape along all but the second axis,
except 1-D arrays which can be any length.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array formed by stacking the given arrays.</dd>
</dl>
<p>stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
concatenate : Join a sequence of arrays along an existing axis.
hsplit : Split array along second axis.
block : Assemble arrays from blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.stack">
<code class="descclassname">numpy.</code><code class="descname">stack</code><span class="sig-paren">(</span><em>arrays</em>, <em>axis=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along a new axis.</p>
<p>The <cite>axis</cite> parameter specifies the index of the new axis in the dimensions
of the result. For example, if <code class="docutils literal"><span class="pre">axis=0</span></code> it will be the first dimension
and if <code class="docutils literal"><span class="pre">axis=-1</span></code> it will be the last dimension.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<dl class="docutils">
<dt>arrays <span class="classifier-delimiter">:</span> <span class="classifier">sequence of array_like</span></dt>
<dd>Each array must have the same shape.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis in the result array along which the input arrays are stacked.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>If provided, the destination to place the result. The shape must be
correct, matching that of what stack would have returned if no
out argument were specified.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The stacked array has one more dimension than the input arrays.</dd>
</dl>
<p>concatenate : Join a sequence of arrays along an existing axis.
split : Split array into a list of multiple sub-arrays of equal size.
block : Assemble arrays from blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3, 4)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 10, 4)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4, 10)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.vstack">
<code class="descclassname">numpy.</code><code class="descname">vstack</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="docutils">
<dt>tup <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ndarrays</span></dt>
<dd>The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array formed by stacking the given arrays, will be at least 2-D.</dd>
</dl>
<p>stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.
block : Assemble arrays from blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.einsum">
<code class="descclassname">numpy.</code><code class="descname">einsum</code><span class="sig-paren">(</span><em>*operands</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.einsum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>einsum(subscripts, <a href="#id26"><span class="problematic" id="id27">*</span></a>operands, out=None, dtype=None, order=’K’,</dt>
<dd>casting=’safe’, optimize=False)</dd>
</dl>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional
array operations can be represented in a simple fashion.  This function
provides a way to compute such summations. The best way to understand this
function is to try the examples below, which show how many common NumPy
functions can be implemented as calls to <cite>einsum</cite>.</p>
<dl class="docutils">
<dt>subscripts <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Specifies the subscripts for summation.</dd>
<dt>operands <span class="classifier-delimiter">:</span> <span class="classifier">list of array_like</span></dt>
<dd>These are the arrays for the operation.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">{ndarray, None}, optional</span></dt>
<dd>If provided, the calculation is done into this array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">{data-type, None}, optional</span></dt>
<dd>If provided, forces the calculation to use the data type specified.
Note that you may have to also give a more liberal <cite>casting</cite>
parameter to allow the conversions. Default is None.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout of the output. ‘C’ means it should
be C contiguous. ‘F’ means it should be Fortran contiguous,
‘A’ means it should be ‘F’ if the inputs are all ‘F’, ‘C’ otherwise.
‘K’ means it should be as close to the layout as the inputs as
is possible, including arbitrarily permuted axes.
Default is ‘K’.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur.  Setting this to
‘unsafe’ is not recommended, as it can adversely affect accumulations.</p>
<blockquote>
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
<p class="last">Default is ‘safe’.</p>
</dd>
<dt>optimize <span class="classifier-delimiter">:</span> <span class="classifier">{False, True, ‘greedy’, ‘optimal’}, optional</span></dt>
<dd>Controls if intermediate optimization should occur. No optimization
will occur if False and True will default to the ‘greedy’ algorithm.
Also accepts an explicit contraction list from the <code class="docutils literal"><span class="pre">np.einsum_path</span></code>
function. See <code class="docutils literal"><span class="pre">np.einsum_path</span></code> for more details. Default is True.</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The calculation based on the Einstein summation convention.</dd>
</dl>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Repeated subscripts labels in one operand take the diagonal.  For example,
<code class="docutils literal"><span class="pre">np.einsum('ii',</span> <span class="pre">a)</span></code> is equivalent to <code class="docutils literal"><span class="pre">np.trace(a)</span></code>.</p>
<p>Whenever a label is repeated, it is summed, so <code class="docutils literal"><span class="pre">np.einsum('i,i',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
is equivalent to <code class="docutils literal"><span class="pre">np.inner(a,b)</span></code>.  If a label appears only once,
it is not summed, so <code class="docutils literal"><span class="pre">np.einsum('i',</span> <span class="pre">a)</span></code> produces a view of <code class="docutils literal"><span class="pre">a</span></code>
with no changes.</p>
<p>The order of labels in the output is by default alphabetical.  This
means that <code class="docutils literal"><span class="pre">np.einsum('ij',</span> <span class="pre">a)</span></code> doesn’t affect a 2D array, while
<code class="docutils literal"><span class="pre">np.einsum('ji',</span> <span class="pre">a)</span></code> takes its transpose.</p>
<p>The output can be controlled by specifying output subscript labels
as well.  This specifies the label order, and allows summing to
be disallowed or forced when desired.  The call <code class="docutils literal"><span class="pre">np.einsum('i-&gt;',</span> <span class="pre">a)</span></code>
is like <code class="docutils literal"><span class="pre">np.sum(a,</span> <span class="pre">axis=-1)</span></code>, and <code class="docutils literal"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
is like <code class="docutils literal"><span class="pre">np.diag(a)</span></code>.  The difference is that <cite>einsum</cite> does not
allow broadcasting by default.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code class="docutils literal"><span class="pre">np.einsum('...ii-&gt;...i',</span> <span class="pre">a)</span></code>.
To take the trace along the first and last axes,
you can do <code class="docutils literal"><span class="pre">np.einsum('i...i',</span> <span class="pre">a)</span></code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, you can do
<code class="docutils literal"><span class="pre">np.einsum('ij...,jk...-&gt;ik...',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code class="docutils literal"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
produces a view.</p>
<p>An alternative way to provide the subscripts and operands is as
<code class="docutils literal"><span class="pre">einsum(op0,</span> <span class="pre">sublist0,</span> <span class="pre">op1,</span> <span class="pre">sublist1,</span> <span class="pre">...,</span> <span class="pre">[sublistout])</span></code>. The examples
below have corresponding <cite>einsum</cite> calls with the two parameter methods.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code class="docutils literal"><span class="pre">np.einsum('ijk...-&gt;kji...',</span> <span class="pre">a)</span></code> will now
have the same effect as <code class="docutils literal"><span class="pre">np.swapaxes(a,</span> <span class="pre">0,</span> <span class="pre">2)</span></code> and
<code class="docutils literal"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> will return a writeable view of the diagonal
of a 2D array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<p>Added the <code class="docutils literal"><span class="pre">optimize</span></code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>See <code class="docutils literal"><span class="pre">np.einsum_path</span></code> for more details.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;..., ...&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;,ij&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i...-&gt;...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jil-&gt;kl&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,jk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,...k-&gt;i...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;k...,jk&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># since version 1.10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)[:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.einsum_path">
<code class="descclassname">numpy.</code><code class="descname">einsum_path</code><span class="sig-paren">(</span><em>subscripts</em>, <em>*operands</em>, <em>optimize='greedy'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.einsum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.</p>
<dl class="docutils">
<dt>subscripts <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Specifies the subscripts for summation.</dd>
<dt><a href="#id28"><span class="problematic" id="id29">*</span></a>operands <span class="classifier-delimiter">:</span> <span class="classifier">list of array_like</span></dt>
<dd>These are the arrays for the operation.</dd>
<dt>optimize <span class="classifier-delimiter">:</span> <span class="classifier">{bool, list, tuple, ‘greedy’, ‘optimal’}</span></dt>
<dd><p class="first">Choose the type of path. If a tuple is provided, the second argument is
assumed to be the maximum intermediate size created. If only a single
argument is provided the largest input or output array size is used
as a maximum intermediate size.</p>
<ul class="simple">
<li>if a list is given that starts with <code class="docutils literal"><span class="pre">einsum_path</span></code>, uses this as the
contraction path</li>
<li>if False no optimization is taken</li>
<li>if True defaults to the ‘greedy’ algorithm</li>
<li>‘optimal’ An algorithm that combinatorially explores all possible
ways of contracting the listed tensors and choosest the least costly
path. Scales exponentially with the number of terms in the
contraction.</li>
<li>‘greedy’ An algorithm that chooses the best pair contraction
at each step. Effectively, this algorithm searches the largest inner,
Hadamard, and then outer products at each step. Scales cubically with
the number of terms in the contraction. Equivalent to the ‘optimal’
path for most contractions.</li>
</ul>
<p class="last">Default is ‘greedy’.</p>
</dd>
</dl>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>A list representation of the einsum path.</dd>
<dt>string_repr <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A printable representation of the einsum path.</dd>
</dl>
<p>The resulting path indicates which terms of the input contraction should be
contracted first, the result of this contraction is then appended to the
end of the contraction list. This list can then be iterated over until all
intermediate contractions are complete.</p>
<p>einsum, linalg.multi_dot</p>
<p>We can begin with a chain dot example. In this case, it is optimal to
contract the <code class="docutils literal"><span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">c</span></code> tensors first as represented by the first
element of the path <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2)</span></code>. The resulting tensor is added to the end
of the contraction and the remaining contraction <code class="docutils literal"><span class="pre">(0,</span> <span class="pre">1)</span></code> is then
completed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ij,jk,kl-&gt;il&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;einsum_path&#39;, (1, 2), (0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">  Complete contraction:  ij,jk,kl-&gt;il</span>
<span class="go">         Naive scaling:  4</span>
<span class="go">     Optimized scaling:  3</span>
<span class="go">      Naive FLOP count:  1.600e+02</span>
<span class="go">  Optimized FLOP count:  5.600e+01</span>
<span class="go">   Theoretical speedup:  2.857</span>
<span class="go">  Largest intermediate:  4.000e+00 elements</span>
<span class="go">-------------------------------------------------------------------------</span>
<span class="go">scaling                  current                                remaining</span>
<span class="go">-------------------------------------------------------------------------</span>
<span class="go">   3                   kl,jk-&gt;jl                                ij,jl-&gt;il</span>
<span class="go">   3                   jl,ij-&gt;il                                   il-&gt;il</span>
</pre></div>
</div>
<p>A more complex index transformation example.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">(</span><span class="s1">&#39;ea,fb,abcd,gc,hd-&gt;efgh&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
<span class="go">                               optimize=&#39;greedy&#39;)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;einsum_path&#39;, (0, 2), (0, 3), (0, 2), (0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh</span>
<span class="go">         Naive scaling:  8</span>
<span class="go">     Optimized scaling:  5</span>
<span class="go">      Naive FLOP count:  8.000e+08</span>
<span class="go">  Optimized FLOP count:  8.000e+05</span>
<span class="go">   Theoretical speedup:  1000.000</span>
<span class="go">  Largest intermediate:  1.000e+04 elements</span>
<span class="go">--------------------------------------------------------------------------</span>
<span class="go">scaling                  current                                remaining</span>
<span class="go">--------------------------------------------------------------------------</span>
<span class="go">   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh</span>
<span class="go">   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh</span>
<span class="go">   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh</span>
<span class="go">   5               defg,hd-&gt;efgh                               efgh-&gt;efgh</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.matrix">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">matrix</code><span class="sig-paren">(</span><em>data</em>, <em>dtype=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is no longer recommended to use this class, even for linear
algebra. Instead use regular arrays. The class may be removed
in the future.</p>
</div>
<p>Returns a matrix from an array-like object, or from a string of data.
A matrix is a specialized 2-D array that retains its 2-D nature
through operations.  It has certain special operators, such as <code class="docutils literal"><span class="pre">*</span></code>
(matrix multiplication) and <code class="docutils literal"><span class="pre">**</span></code> (matrix power).</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">array_like or string</span></dt>
<dd>If <cite>data</cite> is a string, it is interpreted as a matrix with commas
or spaces separating columns, and semicolons separating rows.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>Data-type of the output matrix.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If <cite>data</cite> is already an <cite>ndarray</cite>, then this flag determines
whether the data is copied (the default), or whether a view is
constructed.</dd>
</dl>
<p>array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;1 2; 3 4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[[1 2]</span>
<span class="go"> [3 4]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.matrix.A">
<code class="descname">A</code><a class="headerlink" href="#numpy.matrix.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as an <cite>ndarray</cite> object.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.asarray(self)</span></code>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>self</cite> as an <cite>ndarray</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA</span><span class="p">()</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.matrix.A1">
<code class="descname">A1</code><a class="headerlink" href="#numpy.matrix.A1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as a flattened <cite>ndarray</cite>.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.asarray(x).ravel()</span></code></p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>self</cite>, 1-D, as an <cite>ndarray</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA1</span><span class="p">()</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.matrix.H">
<code class="descname">H</code><a class="headerlink" href="#numpy.matrix.H" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) conjugate transpose of <cite>self</cite>.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.transpose(self)</span></code> if <cite>self</cite> is real-valued.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>complex conjugate transpose of <cite>self</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="n">z</span>
<span class="go">matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],</span>
<span class="go">        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],</span>
<span class="go">        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span>
<span class="go">matrix([[  0. +0.j,   4. +4.j,   8. +8.j],</span>
<span class="go">        [  1. +1.j,   5. +5.j,   9. +9.j],</span>
<span class="go">        [  2. +2.j,   6. +6.j,  10.+10.j],</span>
<span class="go">        [  3. +3.j,   7. +7.j,  11.+11.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.matrix.I">
<code class="descname">I</code><a class="headerlink" href="#numpy.matrix.I" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (multiplicative) inverse of invertible <cite>self</cite>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>If <cite>self</cite> is non-singular, <cite>ret</cite> is such that <code class="docutils literal"><span class="pre">ret</span> <span class="pre">*</span> <span class="pre">self</span></code> ==
<code class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">ret</span></code> == <code class="docutils literal"><span class="pre">np.matrix(np.eye(self[0,:].size)</span></code> all return
<code class="docutils literal"><span class="pre">True</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>numpy.linalg.LinAlgError: Singular matrix</dt>
<dd>If <cite>self</cite> is singular.</dd>
</dl>
<p>linalg.inv</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">);</span> <span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span> <span class="o">*</span> <span class="n">m</span>
<span class="go">matrix([[ 1.,  0.],</span>
<span class="go">        [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="numpy.matrix.T">
<code class="descname">T</code><a class="headerlink" href="#numpy.matrix.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code class="docutils literal"><span class="pre">.H</span></code>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>The (non-conjugated) transpose of the matrix.</dd>
</dl>
<p>transpose, getH</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getT</span><span class="p">()</span>
<span class="go">matrix([[1, 3],</span>
<span class="go">        [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.all">
<code class="descname">all</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all matrix elements along a given axis evaluate to True.</p>
<p>See <cite>numpy.all</cite> for complete descriptions</p>
<p>numpy.all</p>
<p>This is the same as <cite>ndarray.all</cite>, but it returns a <cite>matrix</cite> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">y</span>
<span class="go">matrix([[0, 1, 2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
<span class="go">matrix([[ True,  True,  True,  True],</span>
<span class="go">        [False, False, False, False],</span>
<span class="go">        [False, False, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[False, False, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ True],</span>
<span class="go">        [False],</span>
<span class="go">        [False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.any">
<code class="descname">any</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which logical OR is performed</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output to existing array instead of creating new one, must have
same shape as expected output</dd>
</dl>
<blockquote>
<div><dl class="docutils">
<dt>any <span class="classifier-delimiter">:</span> <span class="classifier">bool, ndarray</span></dt>
<dd>Returns a single bool if <cite>axis</cite> is <code class="docutils literal"><span class="pre">None</span></code>; otherwise,
returns <cite>ndarray</cite></dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexes of the maximum values along an axis.</p>
<p>Return the indexes of the first occurrences of the maximum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<p>See <cite>numpy.argmax</cite> for complete descriptions</p>
<p>numpy.argmax</p>
<p>This is the same as <cite>ndarray.argmax</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.argmax</cite> would return an <cite>ndarray</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[2, 2, 2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexes of the minimum values along an axis.</p>
<p>Return the indexes of the first occurrences of the minimum values
along the specified axis.  If axis is None, the index is for the
flattened matrix.</p>
<p>See <cite>numpy.argmin</cite> for complete descriptions.</p>
<p>numpy.argmin</p>
<p>This is the same as <cite>ndarray.argmin</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.argmin</cite> would return an <cite>ndarray</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[  0,  -1,  -2,  -3],</span>
<span class="go">        [ -4,  -5,  -6,  -7],</span>
<span class="go">        [ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[2, 2, 2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened copy of the matrix.</p>
<p>All <cite>N</cite> elements of the matrix are placed into a single row.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>‘C’ means to flatten in row-major (C-style) order. ‘F’ means to
flatten in column-major (Fortran-style) order. ‘A’ means to
flatten in column-major order if <cite>m</cite> is Fortran <em>contiguous</em> in
memory, row-major order otherwise. ‘K’ means to flatten <cite>m</cite> in
the order the elements occur in memory. The default is ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd>A copy of the matrix, flattened to a <cite>(1, N)</cite> matrix where <cite>N</cite>
is the number of elements in the original matrix.</dd>
</dl>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the matrix.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="go">matrix([[1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">matrix([[1, 3, 2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.getA">
<code class="descname">getA</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getA" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as an <cite>ndarray</cite> object.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.asarray(self)</span></code>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>self</cite> as an <cite>ndarray</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA</span><span class="p">()</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.getA1">
<code class="descname">getA1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getA1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>self</cite> as a flattened <cite>ndarray</cite>.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.asarray(x).ravel()</span></code></p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>self</cite>, 1-D, as an <cite>ndarray</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getA1</span><span class="p">()</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.getH">
<code class="descname">getH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getH" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (complex) conjugate transpose of <cite>self</cite>.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">np.transpose(self)</span></code> if <cite>self</cite> is real-valued.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>complex conjugate transpose of <cite>self</cite></dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="n">z</span>
<span class="go">matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],</span>
<span class="go">        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],</span>
<span class="go">        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">getH</span><span class="p">()</span>
<span class="go">matrix([[  0. +0.j,   4. +4.j,   8. +8.j],</span>
<span class="go">        [  1. +1.j,   5. +5.j,   9. +9.j],</span>
<span class="go">        [  2. +2.j,   6. +6.j,  10.+10.j],</span>
<span class="go">        [  3. +3.j,   7. +7.j,  11.+11.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.getI">
<code class="descname">getI</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getI" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (multiplicative) inverse of invertible <cite>self</cite>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>If <cite>self</cite> is non-singular, <cite>ret</cite> is such that <code class="docutils literal"><span class="pre">ret</span> <span class="pre">*</span> <span class="pre">self</span></code> ==
<code class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">ret</span></code> == <code class="docutils literal"><span class="pre">np.matrix(np.eye(self[0,:].size)</span></code> all return
<code class="docutils literal"><span class="pre">True</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>numpy.linalg.LinAlgError: Singular matrix</dt>
<dd>If <cite>self</cite> is singular.</dd>
</dl>
<p>linalg.inv</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">);</span> <span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span>
<span class="go">matrix([[-2. ,  1. ],</span>
<span class="go">        [ 1.5, -0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getI</span><span class="p">()</span> <span class="o">*</span> <span class="n">m</span>
<span class="go">matrix([[ 1.,  0.],</span>
<span class="go">        [ 0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.getT">
<code class="descname">getT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.getT" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transpose of the matrix.</p>
<p>Does <em>not</em> conjugate!  For the complex conjugate transpose, use <code class="docutils literal"><span class="pre">.H</span></code>.</p>
<p>None</p>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix object</span></dt>
<dd>The (non-conjugated) transpose of the matrix.</dd>
</dl>
<p>transpose, getH</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="s1">&#39;[1, 2; 3, 4]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getT</span><span class="p">()</span>
<span class="go">matrix([[1, 3],</span>
<span class="go">        [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum value along an axis.</p>
<p>See <cite>amax</cite> for complete descriptions</p>
<p>amax, ndarray.max</p>
<p>This is the same as <cite>ndarray.max</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.max</cite> would return an ndarray.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 3],</span>
<span class="go">        [ 7],</span>
<span class="go">        [11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the matrix elements along the given axis.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<p>numpy.mean</p>
<p>Same as <cite>ndarray.mean</cite> except that, where that returns an <cite>ndarray</cite>,
this returns a <cite>matrix</cite> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">5.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 4.,  5.,  6.,  7.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 1.5],</span>
<span class="go">        [ 5.5],</span>
<span class="go">        [ 9.5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum value along an axis.</p>
<p>See <cite>amin</cite> for complete descriptions.</p>
<p>amin, ndarray.min</p>
<p>This is the same as <cite>ndarray.min</cite>, but returns a <cite>matrix</cite> object
where <cite>ndarray.min</cite> would return an ndarray.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[  0,  -1,  -2,  -3],</span>
<span class="go">        [ -4,  -5,  -6,  -7],</span>
<span class="go">        [ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">-11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ -8,  -9, -10, -11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ -3],</span>
<span class="go">        [ -7],</span>
<span class="go">        [-11]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.prod">
<code class="descname">prod</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis.</p>
<p>Refer to <cite>prod</cite> for full documentation.</p>
<p>prod, ndarray.prod</p>
<p>Same as <cite>ndarray.prod</cite>, except, where that returns an <cite>ndarray</cite>, this
returns a <cite>matrix</cite> object instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[  0,  45, 120, 231]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[   0],</span>
<span class="go">        [ 840],</span>
<span class="go">        [7920]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.ptp">
<code class="descname">ptp</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak-to-peak (maximum - minimum) value along the given axis.</p>
<p>Refer to <cite>numpy.ptp</cite> for full documentation.</p>
<p>numpy.ptp</p>
<p>Same as <cite>ndarray.ptp</cite>, except, where that would return an <cite>ndarray</cite> object,
this returns a <cite>matrix</cite> object.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[8, 8, 8, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [3],</span>
<span class="go">        [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.ravel">
<code class="descname">ravel</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flattened matrix.</p>
<p>Refer to <cite>numpy.ravel</cite> for more documentation.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>The elements of <cite>m</cite> are read using this index order. ‘C’ means to
index the elements in C-like order, with the last axis index
changing fastest, back to the first axis index changing slowest.
‘F’ means to index the elements in Fortran-like index order, with
the first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of the
memory layout of the underlying array, and only refer to the order
of axis indexing.  ‘A’ means to read the elements in Fortran-like
index order if <cite>m</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.  ‘K’ means to read the elements in the order they occur
in memory, except for reversing the data when strides are negative.
By default, ‘C’ index order is used.</dd>
</dl>
<dl class="docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd>Return the matrix flattened to shape <cite>(1, N)</cite> where <cite>N</cite>
is the number of elements in the original matrix.
A copy is made only if necessary.</dd>
</dl>
<p>matrix.flatten : returns a similar output matrix but always a copy
matrix.flat : a flat iterator on the array.
numpy.ravel : related function which returns an ndarray</p>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a possibly reshaped matrix.</p>
<p>Refer to <cite>numpy.squeeze</cite> for more documentation.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd>Selects a subset of the single-dimensional entries in the shape.
If an axis is selected with shape entry greater than one,
an error is raised.</dd>
</dl>
<dl class="docutils">
<dt>squeezed <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd>The matrix, but as a (1, N) matrix if it had shape (N, 1).</dd>
</dl>
<p>numpy.squeeze : related function</p>
<p>If <cite>m</cite> has a single column then that column is returned
as the single row of a matrix.  Otherwise <cite>m</cite> is returned.
The returned matrix is always either <cite>m</cite> itself or a view into <cite>m</cite>.
Supplying an axis keyword argument will not affect the returned matrix
but it may cause an error to be raised.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">matrix([[1],</span>
<span class="go">        [2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">matrix([[1, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the standard deviation of the array elements along the given axis.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<p>numpy.std</p>
<p>This is the same as <cite>ndarray.std</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="go">3.4520525295346629</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 1.11803399],</span>
<span class="go">        [ 1.11803399],</span>
<span class="go">        [ 1.11803399]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the matrix elements, along the given axis.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<p>numpy.sum</p>
<p>This is the same as <cite>ndarray.sum</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[3],</span>
<span class="go">        [7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="go">matrix([[ 3.],</span>
<span class="go">        [ 7.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">matrix([[ 3.],</span>
<span class="go">        [ 7.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix as a (possibly nested) list.</p>
<p>See <cite>ndarray.tolist</cite> for full documentation.</p>
<p>ndarray.tolist</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)));</span> <span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.matrix.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.matrix.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variance of the matrix elements, along the given axis.</p>
<p>Refer to <cite>numpy.var</cite> for full documentation.</p>
<p>numpy.var</p>
<p>This is the same as <cite>ndarray.var</cite>, except that where an <cite>ndarray</cite> would
be returned, a <cite>matrix</cite> object is returned instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">matrix([[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
<span class="go">11.916666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">matrix([[ 1.25],</span>
<span class="go">        [ 1.25],</span>
<span class="go">        [ 1.25]])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.bmat">
<code class="descclassname">numpy.</code><code class="descname">bmat</code><span class="sig-paren">(</span><em>obj</em>, <em>ldict=None</em>, <em>gdict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a matrix object from a string, nested sequence, or array.</p>
<dl class="docutils">
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">str or array_like</span></dt>
<dd>Input data. If a string, variables in the current scope may be
referenced by name.</dd>
<dt>ldict <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>A dictionary that replaces local operands in current frame.
Ignored if <cite>obj</cite> is not a string or <cite>gdict</cite> is <cite>None</cite>.</dd>
<dt>gdict <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>A dictionary that replaces global operands in current frame.
Ignored if <cite>obj</cite> is not a string.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd>Returns a matrix object, which is a specialized 2-D array.</dd>
</dl>
<dl class="docutils">
<dt>block :</dt>
<dd>A generalization of this function for N-d arrays, that returns normal
ndarrays.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 1; 1 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;2 2; 2 2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;3 4; 5 6&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;7 8; 9 0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>All the following expressions construct the same block matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]])</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]])</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="s1">&#39;A,B; C,D&#39;</span><span class="p">)</span>
<span class="go">matrix([[1, 1, 2, 2],</span>
<span class="go">        [1, 1, 2, 2],</span>
<span class="go">        [3, 4, 7, 8],</span>
<span class="go">        [5, 6, 9, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.mat">
<code class="descclassname">numpy.</code><code class="descname">mat</code><span class="sig-paren">(</span><em>data</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the input as a matrix.</p>
<p>Unlike <cite>matrix</cite>, <cite>asmatrix</cite> does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to <code class="docutils literal"><span class="pre">matrix(data,</span> <span class="pre">copy=False)</span></code>.</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>Data-type of the output matrix.</dd>
</dl>
<dl class="docutils">
<dt>mat <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><cite>data</cite> interpreted as a matrix.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[5, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asmatrix">
<code class="descclassname">numpy.</code><code class="descname">asmatrix</code><span class="sig-paren">(</span><em>data</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the input as a matrix.</p>
<p>Unlike <cite>matrix</cite>, <cite>asmatrix</cite> does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to <code class="docutils literal"><span class="pre">matrix(data,</span> <span class="pre">copy=False)</span></code>.</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type</span></dt>
<dd>Data-type of the output matrix.</dd>
</dl>
<dl class="docutils">
<dt>mat <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><cite>data</cite> interpreted as a matrix.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">matrix([[5, 2],</span>
<span class="go">        [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.iscomplexobj">
<code class="descclassname">numpy.</code><code class="descname">iscomplexobj</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iscomplexobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, <cite>iscomplexobj</cite> evaluates to True.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>The input can be of any type and shape.</dd>
</dl>
<dl class="docutils">
<dt>iscomplexobj <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>The return value, True if <cite>x</cite> is of a complex type or has at least
one complex element.</dd>
</dl>
<p>isrealobj, iscomplex</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isrealobj">
<code class="descclassname">numpy.</code><code class="descname">isrealobj</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isrealobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if x is a not complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, <cite>isrealobj</cite> evaluates to False
if the data type is complex.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>The input can be of any type and shape.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>The return value, False if <cite>x</cite> is of a complex type.</dd>
</dl>
<p>iscomplexobj, isreal</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.imag">
<code class="descclassname">numpy.</code><code class="descname">imag</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the complex argument.</p>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>The imaginary component of the complex argument. If <cite>val</cite> is real,
the type of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex
elements, the returned type is float.</dd>
</dl>
<p>real, angle, real_if_close</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span>
<span class="go">array([ 2.,  4.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 1. +8.j,  3.+10.j,  5.+12.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.iscomplex">
<code class="descclassname">numpy.</code><code class="descname">iscomplex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iscomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is complex.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bools</span></dt>
<dd>Output array.</dd>
</dl>
<p>isreal
iscomplexobj : Return True if x is a complex type or an array of complex</p>
<blockquote>
<div>numbers.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([ True, False, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isreal">
<code class="descclassname">numpy.</code><code class="descname">isreal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is real.</p>
<p>If element has complex type with zero complex part, the return value
for that element is True.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, bool</span></dt>
<dd>Boolean array of same shape as <cite>x</cite>.</dd>
</dl>
<p>iscomplex
isrealobj : Return True if x is not a complex type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([False,  True,  True,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nan_to_num">
<code class="descclassname">numpy.</code><code class="descname">nan_to_num</code><span class="sig-paren">(</span><em>x</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nan_to_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace NaN with zero and infinity with large finite numbers.</p>
<p>If <cite>x</cite> is inexact, NaN is replaced by zero, and infinity and -infinity
replaced by the respectively largest and most negative finite floating
point values representable by <code class="docutils literal"><span class="pre">x.dtype</span></code>.</p>
<p>For complex dtypes, the above is applied to each of the real and
imaginary components of <cite>x</cite> separately.</p>
<p>If <cite>x</cite> is not inexact, then no replacements are made.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like</span></dt>
<dd>Input data.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">Whether to create a copy of <cite>x</cite> (True) or to replace values
in-place (False). The in-place operation only occurs if
casting to an array does not require a copy.
Default is True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.13.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><cite>x</cite>, with the non-finite values replaced. If <cite>copy</cite> is False, this may
be <cite>x</cite> itself.</dd>
</dl>
<p>isinf : Shows which elements are positive or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,</span>
<span class="go">        -1.28000000e+002,   1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([  1.79769313e+308 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +1.79769313e+308j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.real">
<code class="descclassname">numpy.</code><code class="descname">real</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the complex argument.</p>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>The real component of the complex argument. If <cite>val</cite> is real, the type
of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex elements, the
returned type is float.</dd>
</dl>
<p>real_if_close, imag, angle</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([ 1.,  3.,  5.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 9.+2.j,  9.+4.j,  9.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 9.+2.j,  8.+4.j,  7.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.real_if_close">
<code class="descclassname">numpy.</code><code class="descname">real_if_close</code><span class="sig-paren">(</span><em>a</em>, <em>tol=100</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.real_if_close" title="Permalink to this definition">¶</a></dt>
<dd><p>If complex input returns a real array if complex parts are close to zero.</p>
<p>“Close to zero” is defined as <cite>tol</cite> * (machine epsilon of the type for
<cite>a</cite>).</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Tolerance in machine epsilons for the complex part of the elements
in the array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>If <cite>a</cite> is real, the type of <cite>a</cite> is used for the output.  If <cite>a</cite>
has complex elements, the returned type is float.</dd>
</dl>
<p>real, imag, angle</p>
<p>Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
out the machine epsilon for floats.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
<span class="go">2.2204460492503131e-16</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">([</span><span class="mf">2.1</span> <span class="o">+</span> <span class="mf">4e-14j</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">array([ 2.1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">([</span><span class="mf">2.1</span> <span class="o">+</span> <span class="mf">4e-13j</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">array([ 2.1 +4.00000000e-13j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.typename">
<code class="descclassname">numpy.</code><code class="descname">typename</code><span class="sig-paren">(</span><em>char</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.typename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a description for the given data type code.</p>
<dl class="docutils">
<dt>char <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Data type code.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Description of the input data type code.</dd>
</dl>
<p>dtype, typecodes</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">typechars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">typechar</span> <span class="ow">in</span> <span class="n">typechars</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">typechar</span><span class="p">,</span> <span class="s1">&#39; : &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">typename</span><span class="p">(</span><span class="n">typechar</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">S1  :  character</span>
<span class="go">?  :  bool</span>
<span class="go">B  :  unsigned char</span>
<span class="go">D  :  complex double precision</span>
<span class="go">G  :  complex long double precision</span>
<span class="go">F  :  complex single precision</span>
<span class="go">I  :  unsigned integer</span>
<span class="go">H  :  unsigned short</span>
<span class="go">L  :  unsigned long integer</span>
<span class="go">O  :  object</span>
<span class="go">Q  :  unsigned long long integer</span>
<span class="go">S  :  string</span>
<span class="go">U  :  unicode</span>
<span class="go">V  :  void</span>
<span class="go">b  :  signed char</span>
<span class="go">d  :  double precision</span>
<span class="go">g  :  long precision</span>
<span class="go">f  :  single precision</span>
<span class="go">i  :  integer</span>
<span class="go">h  :  short</span>
<span class="go">l  :  long integer</span>
<span class="go">q  :  long long integer</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asfarray">
<code class="descclassname">numpy.</code><code class="descname">asfarray</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asfarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array converted to a float type.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The input array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype object, optional</span></dt>
<dd>Float type code to coerce input array <cite>a</cite>.  If <cite>dtype</cite> is one of the
‘int’ dtypes, it is replaced with float64.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The input <cite>a</cite> as a float ndarray.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([ 2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.mintypecode">
<code class="descclassname">numpy.</code><code class="descname">mintypecode</code><span class="sig-paren">(</span><em>typechars</em>, <em>typeset='GDFgdf'</em>, <em>default='d'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mintypecode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the character for the minimum-size type to which given types can
be safely cast.</p>
<p>The returned type character must represent the smallest size dtype such
that an array of the returned type can handle the data from an array of
all types in <cite>typechars</cite> (or if <cite>typechars</cite> is an array, then its
dtype.char).</p>
<dl class="docutils">
<dt>typechars <span class="classifier-delimiter">:</span> <span class="classifier">list of str or array_like</span></dt>
<dd>If a list of strings, each string should represent a dtype.
If array_like, the character representation of the array dtype is used.</dd>
<dt>typeset <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>The set of characters that the returned character is chosen from.
The default set is ‘GDFgdf’.</dd>
<dt>default <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The default character, this is returned if none of the characters in
<cite>typechars</cite> matches a character in <cite>typeset</cite>.</dd>
</dl>
<dl class="docutils">
<dt>typechar <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>The character representing the minimum-size type that was found.</dd>
</dl>
<p>dtype, sctype2char, maximum_sctype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">([</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">])</span>
<span class="go">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mf">3.</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">&#39;D&#39;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mintypecode</span><span class="p">(</span><span class="s1">&#39;abceh&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
<span class="go">&#39;G&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.asscalar">
<code class="descclassname">numpy.</code><code class="descname">asscalar</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of size 1 to its scalar equivalent.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array of size 1.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Scalar representation of <cite>a</cite>. The output data type is the same type
returned by the input’s <cite>item</cite> method.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">24</span><span class="p">]))</span>
<span class="go">24</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.common_type">
<code class="descclassname">numpy.</code><code class="descname">common_type</code><span class="sig-paren">(</span><em>*arrays</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.common_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scalar type which is common to the input arrays.</p>
<p>The return type will always be an inexact (i.e. floating point) scalar
type, even if all the arrays are integer arrays. If one of the inputs is
an integer array, the minimum precision type that is returned is a
64-bit floating point dtype.</p>
<p>All input arrays except int64 and uint64 can be safely cast to the
returned dtype without loss of information.</p>
<dl class="docutils">
<dt>array1, array2, … <span class="classifier-delimiter">:</span> <span class="classifier">ndarrays</span></dt>
<dd>Input arrays.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">data type code</span></dt>
<dd>Data type code.</dd>
</dl>
<p>dtype, mintypecode</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="go">&lt;type &#39;numpy.float32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">&lt;type &#39;numpy.float64&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">45</span><span class="p">,</span> <span class="mf">6.</span><span class="n">j</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">45.0</span><span class="p">]))</span>
<span class="go">&lt;type &#39;numpy.complex128&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ravel_multi_index">
<code class="descclassname">numpy.</code><code class="descname">ravel_multi_index</code><span class="sig-paren">(</span><em>multi_index</em>, <em>dims</em>, <em>mode='raise'</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ravel_multi_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a tuple of index arrays into an array of flat
indices, applying boundary modes to the multi-index.</p>
<dl class="docutils">
<dt>multi_index <span class="classifier-delimiter">:</span> <span class="classifier">tuple of array_like</span></dt>
<dd>A tuple of integer arrays, one array for each dimension.</dd>
<dt>dims <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The shape of array into which the indices from <code class="docutils literal"><span class="pre">multi_index</span></code> apply.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd><p class="first">Specifies how out-of-bounds indices are handled.  Can specify
either one mode or a tuple of modes, one mode per index.</p>
<ul class="simple">
<li>‘raise’ – raise an error (default)</li>
<li>‘wrap’ – wrap around</li>
<li>‘clip’ – clip to the range</li>
</ul>
<p class="last">In ‘clip’ mode, a negative index which would normally
wrap will clip to 0 instead.</p>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Determines whether the multi-index should be viewed as
indexing in row-major (C-style) or column-major
(Fortran-style) order.</dd>
</dl>
<dl class="docutils">
<dt>raveled_indices <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array of indices into the flattened version of an array
of dimensions <code class="docutils literal"><span class="pre">dims</span></code>.</dd>
</dl>
<p>unravel_index</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">array([22, 41, 37])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([31, 41, 13])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="go">array([22, 23, 19])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;clip&#39;</span><span class="p">,</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
<span class="go">array([12, 13, 13])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="go">1621</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.unravel_index">
<code class="descclassname">numpy.</code><code class="descname">unravel_index</code><span class="sig-paren">(</span><em>indices</em>, <em>dims</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a flat index or array of flat indices into a tuple
of coordinate arrays.</p>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An integer array whose elements are indices into the flattened
version of an array of dimensions <code class="docutils literal"><span class="pre">dims</span></code>. Before version 1.6.0,
this function accepted just one index value.</dd>
<dt>dims <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The shape of the array to use for unraveling <code class="docutils literal"><span class="pre">indices</span></code>.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd><p class="first">Determines whether the indices should be viewed as indexing in
row-major (C-style) or column-major (Fortran-style) order.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>unraveled_coords <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ndarray</span></dt>
<dd>Each array in the tuple has the same shape as the <code class="docutils literal"><span class="pre">indices</span></code>
array.</dd>
</dl>
<p>ravel_multi_index</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">22</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">37</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">(array([3, 6, 6]), array([4, 5, 1]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">1621</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="go">(3, 1, 4, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ix_">
<code class="descclassname">numpy.</code><code class="descname">ix_</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ix_" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an open mesh from multiple sequences.</p>
<p>This function takes N 1-D sequences and returns N outputs with N
dimensions each, such that the shape is 1 in all but one dimension
and the dimension with the non-unit shape value cycles through all
N dimensions.</p>
<p>Using <cite>ix_</cite> one can quickly construct index arrays that will index
the cross product. <code class="docutils literal"><span class="pre">a[np.ix_([1,3],[2,5])]</span></code> returns the array
<code class="docutils literal"><span class="pre">[[a[1,2]</span> <span class="pre">a[1,5]],</span> <span class="pre">[a[3,2]</span> <span class="pre">a[3,5]]]</span></code>.</p>
<dl class="docutils">
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">1-D sequences</span></dt>
<dd>Each sequence should be of integer or boolean type.
Boolean sequences will be interpreted as boolean masks for the
corresponding dimension (equivalent to passing in
<code class="docutils literal"><span class="pre">np.nonzero(boolean_sequence)</span></code>).</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ndarrays</span></dt>
<dd>N arrays with N dimensions each, with N the number of input
sequences. Together these arrays form an open mesh.</dd>
</dl>
<p>ogrid, mgrid, meshgrid</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span>
<span class="go">(array([[0],</span>
<span class="go">       [1]]), array([[2, 4]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ixgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((2, 1), (1, 2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.ndenumerate">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">ndenumerate</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndenumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Multidimensional index iterator.</p>
<p>Return an iterator yielding pairs of array coordinates and values.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array.</dd>
</dl>
<p>ndindex, flatiter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(0, 0) 1</span>
<span class="go">(0, 1) 2</span>
<span class="go">(1, 0) 3</span>
<span class="go">(1, 1) 4</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.ndenumerate.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndenumerate.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard iterator method, returns the index tuple and array value.</p>
<dl class="docutils">
<dt>coords <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>The indices of the current iteration.</dd>
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The array element of the current iteration.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="numpy.ndindex">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">ndindex</code><span class="sig-paren">(</span><em>*shape</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over
the N-dimensional index of the array. At each iteration a tuple
of indices is returned, the last dimension is iterated over first.</p>
<dl class="docutils">
<dt><cite>*args</cite> <span class="classifier-delimiter">:</span> <span class="classifier">ints</span></dt>
<dd>The size of each dimension of the array.</dd>
</dl>
<p>ndenumerate, flatiter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
<span class="go">(0, 1, 0)</span>
<span class="go">(1, 0, 0)</span>
<span class="go">(1, 1, 0)</span>
<span class="go">(2, 0, 0)</span>
<span class="go">(2, 1, 0)</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.ndindex.ndincr">
<code class="descname">ndincr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndindex.ndincr" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the multi-dimensional index by one.</p>
<p>This method is for backward compatibility only: do not use.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.ndindex.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndindex.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard iterator method, updates the index and returns the index
tuple.</p>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints</span></dt>
<dd>Returns a tuple containing the indices of the current
iteration.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.fill_diagonal">
<code class="descclassname">numpy.</code><code class="descname">fill_diagonal</code><span class="sig-paren">(</span><em>a</em>, <em>val</em>, <em>wrap=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fill_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the main diagonal of the given array of any dimensionality.</p>
<p>For an array <cite>a</cite> with <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>, the diagonal is the list of
locations with indices <code class="docutils literal"><span class="pre">a[i,</span> <span class="pre">...,</span> <span class="pre">i]</span></code> all identical. This function
modifies the input array in-place, it does not return a value.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array, at least 2-D.</span></dt>
<dd>Array whose diagonal is to be filled, it gets modified in-place.</dd>
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Value to be written on the diagonal, its type must be compatible with
that of the array a.</dd>
<dt>wrap <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>For tall matrices in NumPy version up to 1.6.2, the
diagonal “wrapped” after N columns. You can have this behavior
with this option. This affects only tall matrices.</dd>
</dl>
<p>diag_indices, diag_indices_from</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<p>This functionality can be obtained via <cite>diag_indices</cite>, but internally
this version uses a much faster implementation that never constructs the
indices and uses simple slicing.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[5, 0, 0],</span>
<span class="go">       [0, 5, 0],</span>
<span class="go">       [0, 0, 5]])</span>
</pre></div>
</div>
<p>The same function can operate on a 4-D array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>We only show a few blocks for clarity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 4]])</span>
</pre></div>
</div>
<p>The wrap option affects only tall matrices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># tall matrices no wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 4],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># tall matrices wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 4],</span>
<span class="go">       [0, 0, 0],</span>
<span class="go">       [4, 0, 0]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># wide matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[4, 0, 0, 0, 0],</span>
<span class="go">       [0, 4, 0, 0, 0],</span>
<span class="go">       [0, 0, 4, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.diag_indices">
<code class="descclassname">numpy.</code><code class="descname">diag_indices</code><span class="sig-paren">(</span><em>n</em>, <em>ndim=2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access the main diagonal of an array.</p>
<p>This returns a tuple of indices that can be used to access the main
diagonal of an array <cite>a</cite> with <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> dimensions and shape
(n, n, …, n). For <code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">=</span> <span class="pre">2</span></code> this is the usual diagonal, for
<code class="docutils literal"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code> this is the set of indices to access <code class="docutils literal"><span class="pre">a[i,</span> <span class="pre">i,</span> <span class="pre">...,</span> <span class="pre">i]</span></code>
for <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0..n-1]</span></code>.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The size, along each dimension, of the arrays for which the returned
indices can be used.</dd>
<dt>ndim <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of dimensions.</dd>
</dl>
<p>diag_indices_from</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<p>Create a set of indices to access the diagonal of a (4, 4) array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">di</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">di</span>
<span class="go">(array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[100,   1,   2,   3],</span>
<span class="go">       [  4, 100,   6,   7],</span>
<span class="go">       [  8,   9, 100,  11],</span>
<span class="go">       [ 12,  13,  14, 100]])</span>
</pre></div>
</div>
<p>Now, we create indices to manipulate a 3-D array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d3</span>
<span class="go">(array([0, 1]), array([0, 1]), array([0, 1]))</span>
</pre></div>
</div>
<p>And use it to set the diagonal of an array of zeros to 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">d3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[1, 0],</span>
<span class="go">        [0, 0]],</span>
<span class="go">       [[0, 0],</span>
<span class="go">        [0, 1]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.diag_indices_from">
<code class="descclassname">numpy.</code><code class="descname">diag_indices_from</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access the main diagonal of an n-dimensional array.</p>
<p>See <cite>diag_indices</cite> for full details.</p>
<p>arr : array, at least 2-D</p>
<p>diag_indices</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.select">
<code class="descclassname">numpy.</code><code class="descname">select</code><span class="sig-paren">(</span><em>condlist</em>, <em>choicelist</em>, <em>default=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array drawn from elements in choicelist, depending on conditions.</p>
<dl class="docutils">
<dt>condlist <span class="classifier-delimiter">:</span> <span class="classifier">list of bool ndarrays</span></dt>
<dd>The list of conditions which determine from which array in <cite>choicelist</cite>
the output elements are taken. When multiple conditions are satisfied,
the first one encountered in <cite>condlist</cite> is used.</dd>
<dt>choicelist <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarrays</span></dt>
<dd>The list of arrays from which the output elements are taken. It has
to be of the same length as <cite>condlist</cite>.</dd>
<dt>default <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>The element inserted in <cite>output</cite> when all conditions evaluate to False.</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The output at position m is the m-th element of the array in
<cite>choicelist</cite> where the m-th element of the corresponding array in
<cite>condlist</cite> is True.</dd>
</dl>
<p>where : Return elements from one of two arrays depending on condition.
take, choose, compress, diag, diagonal</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choicelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.piecewise">
<code class="descclassname">numpy.</code><code class="descname">piecewise</code><span class="sig-paren">(</span><em>x</em>, <em>condlist</em>, <em>funclist</em>, <em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a piecewise-defined function.</p>
<p>Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>The input domain.</dd>
<dt>condlist <span class="classifier-delimiter">:</span> <span class="classifier">list of bool arrays or bool scalars</span></dt>
<dd><p class="first">Each boolean array corresponds to a function in <cite>funclist</cite>.  Wherever
<cite>condlist[i]</cite> is True, <cite>funclist[i](x)</cite> is used as the output value.</p>
<p>Each boolean array in <cite>condlist</cite> selects a piece of <cite>x</cite>,
and should therefore be of the same shape as <cite>x</cite>.</p>
<p class="last">The length of <cite>condlist</cite> must correspond to that of <cite>funclist</cite>.
If one extra function is given, i.e. if
<code class="docutils literal"><span class="pre">len(funclist)</span> <span class="pre">==</span> <span class="pre">len(condlist)</span> <span class="pre">+</span> <span class="pre">1</span></code>, then that extra function
is the default value, used wherever all conditions are false.</p>
</dd>
<dt>funclist <span class="classifier-delimiter">:</span> <span class="classifier">list of callables, f(x,*args,**kw), or scalars</span></dt>
<dd>Each function is evaluated over <cite>x</cite> wherever its corresponding
condition is True.  It should take a 1d array as input and give an 1d
array or a scalar value as output.  If, instead of a callable,
a scalar is provided then a constant function (<code class="docutils literal"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">scalar</span></code>) is
assumed.</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd>Any further arguments given to <cite>piecewise</cite> are passed to the functions
upon execution, i.e., if called <code class="docutils literal"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>, then
each function is called as <code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">1,</span> <span class="pre">'a')</span></code>.</dd>
<dt>kw <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>Keyword arguments used in calling <cite>piecewise</cite> are passed to the
functions upon execution, i.e., if called
<code class="docutils literal"><span class="pre">piecewise(...,</span> <span class="pre">...,</span> <span class="pre">alpha=1)</span></code>, then each function is called as
<code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">alpha=1)</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The output is the same shape and type as x and is found by
calling the functions in <cite>funclist</cite> on the appropriate portions of <cite>x</cite>,
as defined by the boolean arrays in <cite>condlist</cite>.  Portions not covered
by any condition have a default value of 0.</dd>
</dl>
<p>choose, select, where</p>
<p>This is similar to choose or select, except that functions are
evaluated on elements of <cite>x</cite> that satisfy the corresponding condition from
<cite>condlist</cite>.</p>
<p>The result is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="o">|--</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">out</span> <span class="o">=</span> <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
      <span class="o">|...</span>
      <span class="o">|</span><span class="n">funclist</span><span class="p">[</span><span class="n">n2</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">n2</span><span class="p">]])</span>
      <span class="o">|--</span>
</pre></div>
</div>
<p>Define the sigma function, which is -1 for <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> and +1 for <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([-1., -1., -1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<p>Define the absolute value, which is <code class="docutils literal"><span class="pre">-x</span></code> for <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;0</span></code> and <code class="docutils literal"><span class="pre">x</span></code> for
<code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>
<span class="go">array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>
</pre></div>
</div>
<p>Apply the same function to a scalar value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">])</span>
<span class="go">array(2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.trim_zeros">
<code class="descclassname">numpy.</code><code class="descname">trim_zeros</code><span class="sig-paren">(</span><em>filt</em>, <em>trim='fb'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trim_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p>
<dl class="docutils">
<dt>filt <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd>Input array.</dd>
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>A string with ‘f’ representing trim from front and ‘b’ to trim from
back. Default is ‘fb’, trim zeros from both front and back of the
array.</dd>
</dl>
<dl class="docutils">
<dt>trimmed <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd>The result of trimming the input. The input data type is preserved.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 0, 2, 1])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 1, 2, 3, 0, 2, 1])</span>
</pre></div>
</div>
<p>The input data type is preserved, list/tuple in means list/tuple out.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.copy">
<code class="descclassname">numpy.</code><code class="descname">copy</code><span class="sig-paren">(</span><em>a</em>, <em>order='K'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array copy of the given object.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout of the copy. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible. (Note that this function and <a class="reference internal" href="#numpy.ndarray.copy" title="numpy.ndarray.copy"><code class="xref py py-meth docutils literal"><span class="pre">ndarray.copy()</span></code></a> are very
similar, but have different default values for their order=
arguments.)</dd>
</dl>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array interpretation of <cite>a</cite>.</dd>
</dl>
<p>This is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
</pre></div>
</div>
<p>Create an array x, with a reference y and a copy z:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, when we modify x, y changes, but not z:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.iterable">
<code class="descclassname">numpy.</code><code class="descname">iterable</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether or not an object can be iterated over.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>Input object.</dd>
</dl>
<dl class="docutils">
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Return <code class="docutils literal"><span class="pre">True</span></code> if the object has an iterator method or is a
sequence and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.percentile">
<code class="descclassname">numpy.</code><code class="descname">percentile</code><span class="sig-paren">(</span><em>a</em>, <em>q</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>interpolation='linear'</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth percentile of the data along the specified axis.</p>
<p>Returns the qth percentile(s) of the array elements.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">array_like of float</span></dt>
<dd>Percentile or sequence of percentiles to compute, which must be between
0 and 100 inclusive.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd><p class="first">Axis or axes along which the percentiles are computed. The
default is to compute the percentile(s) along a flattened
version of the array.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.9.0: </span>A tuple of axes is supported</p>
</div>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</dd>
<dt>interpolation <span class="classifier-delimiter">:</span> <span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first">This optional parameter specifies the interpolation method to
use when the desired percentile lies between two data points
<code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<ul class="simple">
<li>‘linear’: <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal"><span class="pre">i</span></code>
and <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>‘lower’: <code class="docutils literal"><span class="pre">i</span></code>.</li>
<li>‘higher’: <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>‘nearest’: <code class="docutils literal"><span class="pre">i</span></code> or <code class="docutils literal"><span class="pre">j</span></code>, whichever is nearest.</li>
<li>‘midpoint’: <code class="docutils literal"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</li>
</ul>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>percentile <span class="classifier-delimiter">:</span> <span class="classifier">scalar or ndarray</span></dt>
<dd>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple percentiles are given, first axis of
the result corresponds to the percentiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>mean
median : equivalent to <code class="docutils literal"><span class="pre">percentile(...,</span> <span class="pre">50)</span></code>
nanpercentile
quantile : equivalent to percentile, except with q in the range [0, 1].</p>
<p>Given a vector <code class="docutils literal"><span class="pre">V</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the <code class="docutils literal"><span class="pre">q</span></code>-th percentile of
<code class="docutils literal"><span class="pre">V</span></code> is the value <code class="docutils literal"><span class="pre">q/100</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the percentile if the normalized ranking does not
match the location of <code class="docutils literal"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal"><span class="pre">q=50</span></code>, the same as the minimum if <code class="docutils literal"><span class="pre">q=0</span></code> and the
same as the maximum if <code class="docutils literal"><span class="pre">q=100</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The different types of interpolation can be visualized graphically:</p>
</dd></dl>

<dl class="function">
<dt id="numpy.diff">
<code class="descclassname">numpy.</code><code class="descname">diff</code><span class="sig-paren">(</span><em>a</em>, <em>n=1</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the n-th discrete difference along the given axis.</p>
<p>The first difference is given by <code class="docutils literal"><span class="pre">out[n]</span> <span class="pre">=</span> <span class="pre">a[n+1]</span> <span class="pre">-</span> <span class="pre">a[n]</span></code> along
the given axis, higher differences are calculated by using <cite>diff</cite>
recursively.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of times values are differenced. If zero, the input
is returned as-is.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which the difference is taken, default is the
last axis.</dd>
</dl>
<dl class="docutils">
<dt>diff <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The n-th differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>. The
type of the output is the same as the type of the difference
between any two elements of <cite>a</cite>. This is the same as the type of
<cite>a</cite> in most cases. A notable exception is <cite>datetime64</cite>, which
results in a <cite>timedelta64</cite> output array.</dd>
</dl>
<p>gradient, ediff1d, cumsum</p>
<p>Type is preserved for boolean arrays, so the result will contain
<cite>False</cite> when consecutive elements are the same and <cite>True</cite> when they
differ.</p>
<p>For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u8_arr</span><span class="p">)</span>
<span class="go">array([255], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u8_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">u8_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="go">array(255, np.uint8)</span>
</pre></div>
</div>
<p>If this is not desirable, then the array should be cast to a larger
integer type first:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i16_arr</span> <span class="o">=</span> <span class="n">u8_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i16_arr</span><span class="p">)</span>
<span class="go">array([-1], dtype=int16)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([  1,   1, -10])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[2, 3, 4],</span>
<span class="go">       [5, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-1,  2,  0, -2]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="s1">&#39;1066-10-13&#39;</span><span class="p">,</span> <span class="s1">&#39;1066-10-16&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.gradient">
<code class="descclassname">numpy.</code><code class="descname">gradient</code><span class="sig-paren">(</span><em>f</em>, <em>*varargs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gradient of an N-dimensional array.</p>
<p>The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.</p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An N-dimensional array containing samples of a scalar function.</dd>
<dt>varargs <span class="classifier-delimiter">:</span> <span class="classifier">list of scalar or array, optional</span></dt>
<dd><p class="first">Spacing between f values. Default unitary spacing for all dimensions.
Spacing can be specified using:</p>
<ol class="arabic simple">
<li>single scalar to specify a sample distance for all dimensions.</li>
<li>N scalars to specify a constant sample distance for each dimension.
i.e. <cite>dx</cite>, <cite>dy</cite>, <cite>dz</cite>, …</li>
<li>N arrays to specify the coordinates of the values along each
dimension of F. The length of the array must match the size of
the corresponding dimension</li>
<li>Any combination of N scalars/arrays with the meaning of 2. and 3.</li>
</ol>
<p class="last">If <cite>axis</cite> is given, the number of varargs must equal the number of axes.
Default: 1.</p>
</dd>
<dt>edge_order <span class="classifier-delimiter">:</span> <span class="classifier">{1, 2}, optional</span></dt>
<dd><p class="first">Gradient is calculated using N-th order accurate differences
at the boundaries. Default: 1.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.1.</span></p>
</div>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Gradient is calculated only along the given axis or axes
The default (axis = None) is to calculate the gradient for all the axes
of the input array. axis may be negative, in which case it counts from
the last to the first axis.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>gradient <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarray</span></dt>
<dd>A set of ndarrays (or a single ndarray if there is only one dimension)
corresponding to the derivatives of f with respect to each dimension.
Each derivative has the same shape as f.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>
</pre></div>
</div>
<p>Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
</pre></div>
</div>
<p>Or a non uniform one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>
</pre></div>
</div>
<p>For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
<span class="go">[array([[ 2.,  2., -1.],</span>
<span class="go">        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],</span>
<span class="go">        [ 1. ,  1. ,  1. ]])]</span>
</pre></div>
</div>
<p>In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[array([[ 1. ,  1. , -0.5],</span>
<span class="go">        [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],</span>
<span class="go">        [ 2. ,  1.7,  0.5]])]</span>
</pre></div>
</div>
<p>It is possible to specify how boundaries are treated using <cite>edge_order</cite></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  2.,  4.,  6.,  7.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([-0.,  2.,  4.,  6.,  8.])</span>
</pre></div>
</div>
<p>The <cite>axis</cite> keyword can be used to specify a subset of axes of which the
gradient is calculated</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]])</span>
</pre></div>
</div>
<p>Assuming that <span class="math">\(f\in C^{3}\)</span> (i.e., <span class="math">\(f\)</span> has at least 3 continuous
derivatives) and let <span class="math">\(h_{*}\)</span> be a non-homogeneous stepsize, we
minimize the “consistency error” <span class="math">\(\eta_{i}\)</span> between the true gradient
and its estimate from a linear combination of the neighboring grid-points:</p>
<div class="math">
\[\eta_{i} = f_{i}^{\left(1\right)} -
            \left[ \alpha f\left(x_{i}\right) +
                    \beta f\left(x_{i} + h_{d}\right) +
                    \gamma f\left(x_{i}-h_{s}\right)
            \right]\]</div>
<p>By substituting <span class="math">\(f(x_{i} + h_{d})\)</span> and <span class="math">\(f(x_{i} - h_{s})\)</span>
with their Taylor series expansion, this translates into solving
the following the linear system:</p>
<div class="math">
\[\begin{split}\left\{
    \begin{array}{r}
        \alpha+\beta+\gamma=0 \\
        \beta h_{d}-\gamma h_{s}=1 \\
        \beta h_{d}^{2}+\gamma h_{s}^{2}=0
    \end{array}
\right.\end{split}\]</div>
<p>The resulting approximation of <span class="math">\(f_{i}^{(1)}\)</span> is the following:</p>
<div class="math">
\[\hat f_{i}^{(1)} =
    \frac{
        h_{s}^{2}f\left(x_{i} + h_{d}\right)
        + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
        - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
        { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
    + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                        + h_{s}h_{d}^{2}}{h_{d}
                        + h_{s}}\right)\]</div>
<p>It is worth noting that if <span class="math">\(h_{s}=h_{d}\)</span>
(i.e., data are evenly spaced)
we find the standard second order approximation:</p>
<div class="math">
\[\hat f_{i}^{(1)}=
    \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
    + \mathcal{O}\left(h^{2}\right)\]</div>
<p>With a similar procedure the forward/backward approximations used for
boundaries can be derived.</p>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
(Texts in Applied Mathematics). New York: Springer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Durran D. R. (1999) Numerical Methods for Wave Equations
in Geophysical Fluid Dynamics. New York: Springer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Fornberg B. (1988) Generation of Finite Difference Formulas on
Arbitrarily Spaced Grids,
Mathematics of Computation 51, no. 184 : 699-706.
<a class="reference external" href="http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf">PDF</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="numpy.angle">
<code class="descclassname">numpy.</code><code class="descname">angle</code><span class="sig-paren">(</span><em>z</em>, <em>deg=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle of the complex argument.</p>
<dl class="docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A complex number or sequence of complex numbers.</dd>
<dt>deg <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Return angle in degrees if True, radians if False (default).</dd>
</dl>
<dl class="docutils">
<dt>angle <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>The counterclockwise angle from the positive real axis on
the complex plane, with dtype as numpy.float64.</dd>
</dl>
<p>arctan2
absolute</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>               <span class="c1"># in radians</span>
<span class="go">array([ 0.        ,  1.57079633,  0.78539816])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                  <span class="c1"># in degrees</span>
<span class="go">45.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.unwrap">
<code class="descclassname">numpy.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><em>p</em>, <em>discont=3.141592653589793</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap by changing deltas between values to 2*pi complement.</p>
<p>Unwrap radian phase <cite>p</cite> by changing absolute jumps greater than
<cite>discont</cite> to their 2*pi complement along the given axis.</p>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>discont <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Maximum discontinuity between values, default is <code class="docutils literal"><span class="pre">pi</span></code>.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which unwrap will operate, default is the last axis.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array.</dd>
</dl>
<p>rad2deg, deg2rad</p>
<p>If the discontinuity in <cite>p</cite> is smaller than <code class="docutils literal"><span class="pre">pi</span></code>, but larger than
<cite>discont</cite>, no unwrapping is done because taking the 2*pi complement
would only make the discontinuity larger.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phase</span>
<span class="go">array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
<span class="go">array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.sort_complex">
<code class="descclassname">numpy.</code><code class="descname">sort_complex</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sort_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort a complex array using the real part first, then the imaginary part.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">complex ndarray</span></dt>
<dd>Always returns a sorted complex array.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.disp">
<code class="descclassname">numpy.</code><code class="descname">disp</code><span class="sig-paren">(</span><em>mesg</em>, <em>device=None</em>, <em>linefeed=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.disp" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a message on a device.</p>
<dl class="docutils">
<dt>mesg <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Message to display.</dd>
<dt>device <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>Device to write message. If None, defaults to <code class="docutils literal"><span class="pre">sys.stdout</span></code> which is
very similar to <code class="docutils literal"><span class="pre">print</span></code>. <cite>device</cite> needs to have <code class="docutils literal"><span class="pre">write()</span></code> and
<code class="docutils literal"><span class="pre">flush()</span></code> methods.</dd>
<dt>linefeed <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Option whether to print a line feed or not. Defaults to True.</dd>
</dl>
<dl class="docutils">
<dt>AttributeError</dt>
<dd>If <cite>device</cite> does not have a <code class="docutils literal"><span class="pre">write()</span></code> or <code class="docutils literal"><span class="pre">flush()</span></code> method.</dd>
</dl>
<p>Besides <code class="docutils literal"><span class="pre">sys.stdout</span></code>, a file-like object can also be used as it has
both required methods:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">disp</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;&quot;Display&quot; in a file&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;&quot;Display&quot; in a file\n&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.flip">
<code class="descclassname">numpy.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>m</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of elements in an array along the given axis.</p>
<p>The shape of the array is preserved, but the elements are reordered.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to flip over. The default,
axis=None, will flip over all of the axes of the input array.
If axis is negative it counts from the last to the first axis.</p>
<p>If axis is a tuple of ints, flipping is performed on all of the axes
specified in the tuple.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.15.0: </span>None and tuples of axes are supported</p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A view of <cite>m</cite> with the entries of axis reversed.  Since a view is
returned, this operation is done in constant time.</dd>
</dl>
<p>flipud : Flip an array vertically (axis=0).
fliplr : Flip an array horizontally (axis=1).</p>
<p>flip(m, 0) is equivalent to flipud(m).</p>
<p>flip(m, 1) is equivalent to fliplr(m).</p>
<p>flip(m, n) corresponds to <code class="docutils literal"><span class="pre">m[...,::-1,...]</span></code> with <code class="docutils literal"><span class="pre">::-1</span></code> at position n.</p>
<p>flip(m) corresponds to <code class="docutils literal"><span class="pre">m[::-1,::-1,...,::-1]</span></code> with <code class="docutils literal"><span class="pre">::-1</span></code> at all
positions.</p>
<p>flip(m, (0, 1)) corresponds to <code class="docutils literal"><span class="pre">m[::-1,::-1,...]</span></code> with <code class="docutils literal"><span class="pre">::-1</span></code> at
position 0 and position 1.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[[4, 5],</span>
<span class="go">        [6, 7]],</span>
<span class="go">       [[0, 1],</span>
<span class="go">        [2, 3]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[[2, 3],</span>
<span class="go">        [0, 1]],</span>
<span class="go">       [[6, 7],</span>
<span class="go">        [4, 5]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[[7, 6],</span>
<span class="go">        [5, 4]],</span>
<span class="go">       [[3, 2],</span>
<span class="go">        [1, 0]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[5, 4],</span>
<span class="go">        [7, 6]],</span>
<span class="go">       [[1, 0],</span>
<span class="go">        [3, 2]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.rot90">
<code class="descclassname">numpy.</code><code class="descname">rot90</code><span class="sig-paren">(</span><em>m</em>, <em>k=1</em>, <em>axes=(0</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rot90" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an array by 90 degrees in the plane specified by axes.</p>
<p>Rotation direction is from the first towards the second axis.</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array of two or more dimensions.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>Number of times the array is rotated by 90 degrees.</dd>
<dt>axes: (2,) array_like</dt>
<dd><p class="first">The array is rotated in the plane defined by the axes.
Axes must be different.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A rotated view of <cite>m</cite>.</dd>
</dl>
<p>flip : Reverse the order of elements in an array along the given axis.
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.</p>
<p>rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[1, 3],</span>
<span class="go">        [0, 2]],</span>
<span class="go">       [[5, 7],</span>
<span class="go">        [4, 6]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.extract">
<code class="descclassname">numpy.</code><code class="descname">extract</code><span class="sig-paren">(</span><em>condition</em>, <em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elements of an array that satisfy some condition.</p>
<p>This is equivalent to <code class="docutils literal"><span class="pre">np.compress(ravel(condition),</span> <span class="pre">ravel(arr))</span></code>.  If
<cite>condition</cite> is boolean <code class="docutils literal"><span class="pre">np.extract</span></code> is equivalent to <code class="docutils literal"><span class="pre">arr[condition]</span></code>.</p>
<p>Note that <cite>place</cite> does the exact opposite of <cite>extract</cite>.</p>
<dl class="docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An array whose nonzero or True entries indicate the elements of <cite>arr</cite>
to extract.</dd>
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array of the same size as <cite>condition</cite>.</dd>
</dl>
<dl class="docutils">
<dt>extract <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Rank 1 array of values from <cite>arr</cite> where <cite>condition</cite> is True.</dd>
</dl>
<p>take, put, copyto, compress, place</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">condition</span>
<span class="go">array([[ True, False, False,  True],</span>
<span class="go">       [False, False,  True, False],</span>
<span class="go">       [False,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
<span class="go">array([0, 3, 6, 9])</span>
</pre></div>
</div>
<p>If <cite>condition</cite> is boolean:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
<span class="go">array([0, 3, 6, 9])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.place">
<code class="descclassname">numpy.</code><code class="descname">place</code><span class="sig-paren">(</span><em>arr</em>, <em>mask</em>, <em>vals</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.place" title="Permalink to this definition">¶</a></dt>
<dd><p>Change elements of an array based on conditional and input values.</p>
<p>Similar to <code class="docutils literal"><span class="pre">np.copyto(arr,</span> <span class="pre">vals,</span> <span class="pre">where=mask)</span></code>, the difference is that
<cite>place</cite> uses the first N elements of <cite>vals</cite>, where N is the number of
True values in <cite>mask</cite>, while <cite>copyto</cite> uses the elements where <cite>mask</cite>
is True.</p>
<p>Note that <cite>extract</cite> does the exact opposite of <cite>place</cite>.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array to put data into.</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Boolean mask array. Must have the same size as <cite>a</cite>.</dd>
<dt>vals <span class="classifier-delimiter">:</span> <span class="classifier">1-D sequence</span></dt>
<dd>Values to put into <cite>a</cite>. Only the first N elements are used, where
N is the number of True values in <cite>mask</cite>. If <cite>vals</cite> is smaller
than N, it will be repeated, and if elements of <cite>a</cite> are to be masked,
this sequence must be non-empty.</dd>
</dl>
<p>copyto, put, take, extract</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 0,  1,  2],</span>
<span class="go">       [44, 55, 44]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.vectorize">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">vectorize</code><span class="sig-paren">(</span><em>pyfunc</em>, <em>otypes=None</em>, <em>doc=None</em>, <em>excluded=None</em>, <em>cache=False</em>, <em>signature=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="docutils">
<dt>vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,</dt>
<dd>signature=None)</dd>
</dl>
<p>Generalized function class.</p>
<p>Define a vectorized function which takes a nested sequence of objects or
numpy arrays as inputs and returns an single or tuple of numpy array as
output. The vectorized function evaluates <cite>pyfunc</cite> over successive tuples
of the input arrays like the python map function, except it uses the
broadcasting rules of numpy.</p>
<p>The data type of the output of <cite>vectorized</cite> is determined by calling
the function with the first element of the input.  This can be avoided
by specifying the <cite>otypes</cite> argument.</p>
<dl class="docutils">
<dt>pyfunc <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>A python function or method.</dd>
<dt>otypes <span class="classifier-delimiter">:</span> <span class="classifier">str or list of dtypes, optional</span></dt>
<dd>The output data type. It must be specified as either a string of
typecode characters or a list of data type specifiers. There should
be one data type specifier for each output.</dd>
<dt>doc <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The docstring for the function. If <cite>None</cite>, the docstring will be the
<code class="docutils literal"><span class="pre">pyfunc.__doc__</span></code>.</dd>
<dt>excluded <span class="classifier-delimiter">:</span> <span class="classifier">set, optional</span></dt>
<dd><p class="first">Set of strings or integers representing the positional or keyword
arguments for which the function will not be vectorized.  These will be
passed directly to <cite>pyfunc</cite> unmodified.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>cache <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If <cite>True</cite>, then cache the first function call that determines the number
of outputs if <cite>otypes</cite> is not provided.</p>
<blockquote class="last">
<div><div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</div></blockquote>
</dd>
<dt>signature <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first">Generalized universal function signature, e.g., <code class="docutils literal"><span class="pre">(m,n),(n)-&gt;(m)</span></code> for
vectorized matrix-vector multiplication. If provided, <code class="docutils literal"><span class="pre">pyfunc</span></code> will
be called with (and expected to return) arrays with shapes given by the
size of corresponding core dimensions. By default, <code class="docutils literal"><span class="pre">pyfunc</span></code> is
assumed to take scalars as input and output.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>vectorized <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>Vectorized function.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([3, 4, 1, 2])</span>
</pre></div>
</div>
<p>The docstring is taken from the input function to <cite>vectorize</cite> unless it
is specified:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;Return a-b if a&gt;b, otherwise return a+b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Vectorized `myfunc`&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;Vectorized `myfunc`&#39;</span>
</pre></div>
</div>
<p>The output type is determined by evaluating the first element of the input,
unless it is specified:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;numpy.int32&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">vfunc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;type &#39;numpy.float64&#39;&gt;</span>
</pre></div>
</div>
<p>The <cite>excluded</cite> argument can be used to prevent vectorizing over certain
arguments.  This can be useful for array-like arguments of a fixed length
such as the coefficients for a polynomial as in <cite>polyval</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mypolyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">_p</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">_p</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">_p</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">mypolyval</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>Positional arguments may also be excluded by specifying their position:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="o">.</span><span class="n">excluded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpolyval</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([3, 6])</span>
</pre></div>
</div>
<p>The <cite>signature</cite> argument allows for vectorizing functions that act on
non-scalar arrays of fixed length. For example, you can use it for a
vectorized calculation of Pearson correlation coefficient and its p-value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pearsonr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;(n),(n)-&gt;(),()&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pearsonr</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">(array([ 1., -1.]), array([ 0.,  0.]))</span>
</pre></div>
</div>
<p>Or for a vectorized convolution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">convolve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;(n),(m)-&gt;(k)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([[ 1.,  2.,  1.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  2.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  2.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  1.,  2.,  1.]])</span>
</pre></div>
</div>
<p>frompyfunc : Takes an arbitrary Python function and returns a ufunc</p>
<p>The <cite>vectorize</cite> function is provided primarily for convenience, not for
performance. The implementation is essentially a for loop.</p>
<p>If <cite>otypes</cite> is not specified, then a call to the function with the
first argument will be used to determine the number of outputs.  The
results of this call will be cached if <cite>cache</cite> is <cite>True</cite> to prevent
calling the function twice.  However, to implement the cache, the
original function must be wrapped which will slow down subsequent
calls, so only do this if your function is expensive.</p>
<p>The new keyword argument interface and <cite>excluded</cite> argument support
further degrades performance.</p>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>NumPy Reference, section <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html">Generalized Universal Function API</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="numpy.asarray_chkfinite">
<code class="descclassname">numpy.</code><code class="descname">asarray_chkfinite</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.asarray_chkfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an array, checking for NaNs or Infs.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data, in any form that can be converted to an array.  This
includes lists, lists of tuples, tuples, tuples of tuples, tuples
of lists and ndarrays.  Success requires no NaNs or Infs.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>By default, the data-type is inferred from the input data.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Whether to use row-major (C-style) or
column-major (Fortran-style) memory representation.
Defaults to ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array interpretation of <cite>a</cite>.  No copy is performed if the input
is already an ndarray.  If <cite>a</cite> is a subclass of ndarray, a base
class ndarray is returned.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>Raises ValueError if <cite>a</cite> contains NaN (Not a Number) or Inf (Infinity).</dd>
</dl>
<p>asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major</p>
<blockquote>
<div>memory order.</div></blockquote>
<p>fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid</p>
<blockquote>
<div>positions.</div></blockquote>
<p>Convert a list into an array.  If all elements are finite
<code class="docutils literal"><span class="pre">asarray_chkfinite</span></code> is identical to <code class="docutils literal"><span class="pre">asarray</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="go">array([1., 2.])</span>
</pre></div>
</div>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">ValueError</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.average">
<code class="descclassname">numpy.</code><code class="descname">average</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>weights=None</em>, <em>returned=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted average along the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing data to be averaged. If <cite>a</cite> is not an array, a
conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which to average <cite>a</cite>.  The default,
axis=None, will average over all of the elements of the input array.
If axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If axis is a tuple of ints, averaging is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>An array of weights associated with the values in <cite>a</cite>. Each value in
<cite>a</cite> contributes to the average according to its associated weight.
The weights array can either be 1-D (in which case its length must be
the size of <cite>a</cite> along the given axis) or of the same shape as <cite>a</cite>.
If <cite>weights=None</cite>, then all data in <cite>a</cite> are assumed to have a
weight equal to one.</dd>
<dt>returned <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Default is <cite>False</cite>. If <cite>True</cite>, the tuple (<cite>average</cite>, <cite>sum_of_weights</cite>)
is returned, otherwise only the average is returned.
If <cite>weights=None</cite>, <cite>sum_of_weights</cite> is equivalent to the number of
elements over which the average is taken.</dd>
</dl>
<dl class="docutils">
<dt>average, [sum_of_weights] <span class="classifier-delimiter">:</span> <span class="classifier">array_type or double</span></dt>
<dd>Return the average along the specified axis. When returned is <cite>True</cite>,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is <cite>Float</cite>
if <cite>a</cite> is of integer type, otherwise it is of the same type as <cite>a</cite>.
<cite>sum_of_weights</cite> is of the same type as <cite>average</cite>.</dd>
</dl>
<dl class="docutils">
<dt>ZeroDivisionError</dt>
<dd>When all weights along axis are zero. See <cite>numpy.ma.average</cite> for a
version robust to this type of error.</dd>
<dt>TypeError</dt>
<dd>When the length of 1D <cite>weights</cite> is not the same as the shape of <cite>a</cite>
along axis.</dd>
</dl>
<p>mean</p>
<dl class="docutils">
<dt>ma.average <span class="classifier-delimiter">:</span> <span class="classifier">average for masked arrays – useful if your data contains</span></dt>
<dd>“missing” values</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">4.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>
<span class="go">array([ 0.75,  2.75,  4.75])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Axis must be specified when shapes of a and weights differ.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.bincount">
<code class="descclassname">numpy.</code><code class="descname">bincount</code><span class="sig-paren">(</span><em>x</em>, <em>weights=None</em>, <em>minlength=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bincount" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of occurrences of each value in array of non-negative ints.</p>
<p>The number of bins (of size 1) is one larger than the largest value in
<cite>x</cite>. If <cite>minlength</cite> is specified, there will be at least this number
of bins in the output array (though it will be longer if necessary,
depending on the contents of <cite>x</cite>).
Each bin gives the number of occurrences of its index value in <cite>x</cite>.
If <cite>weights</cite> is specified the input array is weighted by it, i.e. if a
value <code class="docutils literal"><span class="pre">n</span></code> is found at position <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">weight[i]</span></code> instead
of <code class="docutils literal"><span class="pre">out[n]</span> <span class="pre">+=</span> <span class="pre">1</span></code>.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like, 1 dimension, nonnegative ints</span></dt>
<dd>Input array.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Weights, array of the same shape as <cite>x</cite>.</dd>
<dt>minlength <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">A minimum number of bins for the output array.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>The result of binning the input array.
The length of <cite>out</cite> is equal to <code class="docutils literal"><span class="pre">np.amax(x)+1</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the input is not 1-dimensional, or contains elements with negative
values, or if <cite>minlength</cite> is negative.</dd>
<dt>TypeError</dt>
<dd>If the type of the input is float or complex.</dd>
</dl>
<p>histogram, digitize, unique</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([1, 3, 1, 1, 0, 0, 0, 1])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">23</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The input array needs to be of integer dtype, otherwise a
TypeError is raised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">array cannot be safely cast to required type</span>
</pre></div>
</div>
<p>A possible use of <code class="docutils literal"><span class="pre">bincount</span></code> is to perform sums over
variable-size chunks of an array, using the <code class="docutils literal"><span class="pre">weights</span></code> keyword.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6</span><span class="p">])</span> <span class="c1"># weights</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>  <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="go">array([ 0.3,  0.7,  1.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.digitize">
<code class="descclassname">numpy.</code><code class="descname">digitize</code><span class="sig-paren">(</span><em>x</em>, <em>bins</em>, <em>right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in input array belongs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="26%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>right</cite></th>
<th class="head">order of bins</th>
<th class="head">returned index <cite>i</cite> satisfies</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">False</span></code></td>
<td>increasing</td>
<td><code class="docutils literal"><span class="pre">bins[i-1]</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">bins[i]</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">True</span></code></td>
<td>increasing</td>
<td><code class="docutils literal"><span class="pre">bins[i-1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">bins[i]</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">False</span></code></td>
<td>decreasing</td>
<td><code class="docutils literal"><span class="pre">bins[i-1]</span> <span class="pre">&gt;</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">bins[i]</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">True</span></code></td>
<td>decreasing</td>
<td><code class="docutils literal"><span class="pre">bins[i-1]</span> <span class="pre">&gt;=</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">bins[i]</span></code></td>
</tr>
</tbody>
</table>
<p>If values in <cite>x</cite> are beyond the bounds of <cite>bins</cite>, 0 or <code class="docutils literal"><span class="pre">len(bins)</span></code> is
returned as appropriate.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array to be binned. Prior to NumPy 1.10.0, this array had to
be 1-dimensional, but can now have any shape.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array of bins. It has to be 1-dimensional and monotonic.</dd>
<dt>right <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Indicating whether the intervals include the right or the left bin
edge. Default behavior is (right==False) indicating that the interval
does not include the right edge. The left bin end is open in this
case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
monotonically increasing bins.</dd>
</dl>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of ints</span></dt>
<dd>Output array of indices, of same shape as <cite>x</cite>.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>bins</cite> is not monotonic.</dd>
<dt>TypeError</dt>
<dd>If the type of the input is complex.</dd>
</dl>
<p>bincount, histogram, unique, searchsorted</p>
<p>If values in <cite>x</cite> are such that they fall outside the bin range,
attempting to index <cite>bins</cite> with the indices that <cite>digitize</cite> returns
will result in an IndexError.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<p><cite>np.digitize</cite> is  implemented in terms of <cite>np.searchsorted</cite>. This means
that a binary search is used to bin the values, which scales much better
for larger number of bins than the previous linear search. It also removes
the requirement for the input array to be 1-dimensional.</p>
<p>For monotonically _increasing_ <cite>bins</cite>, the following are equivalent:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that as the order of the arguments are reversed, the side must be too.
The <cite>searchsorted</cite> call is marginally faster, as it does not do any
monotonicity checks. Perhaps more importantly, it supports all dtypes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">6.4</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span>
<span class="go">array([1, 4, 3, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
<span class="gp">... </span>  <span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="go">0.0 &lt;= 0.2 &lt; 1.0</span>
<span class="go">4.0 &lt;= 6.4 &lt; 10.0</span>
<span class="go">2.5 &lt;= 3.0 &lt; 4.0</span>
<span class="go">1.0 &lt;= 1.6 &lt; 2.5</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">12.4</span><span class="p">,</span> <span class="mf">15.5</span><span class="p">,</span> <span class="mf">20.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([1, 3, 3, 4, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.cov">
<code class="descclassname">numpy.</code><code class="descname">cov</code><span class="sig-paren">(</span><em>m</em>, <em>y=None</em>, <em>rowvar=True</em>, <em>bias=False</em>, <em>ddof=None</em>, <em>fweights=None</em>, <em>aweights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a covariance matrix, given data and weights.</p>
<p>Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, <span class="math">\(X = [x_1, x_2, ... x_N]^T\)</span>,
then the covariance matrix element <span class="math">\(C_{ij}\)</span> is the covariance of
<span class="math">\(x_i\)</span> and <span class="math">\(x_j\)</span>. The element <span class="math">\(C_{ii}\)</span> is the variance
of <span class="math">\(x_i\)</span>.</p>
<p>See the notes for an outline of the algorithm.</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>m</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>An additional set of variables and observations. <cite>y</cite> has the same form
as that of <cite>m</cite>.</dd>
<dt>rowvar <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</dd>
<dt>bias <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Default normalization (False) is by <code class="docutils literal"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> is the
number of observations given (unbiased estimate). If <cite>bias</cite> is True,
then normalization is by <code class="docutils literal"><span class="pre">N</span></code>. These values can be overridden by using
the keyword <code class="docutils literal"><span class="pre">ddof</span></code> in numpy versions &gt;= 1.5.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">If not <code class="docutils literal"><span class="pre">None</span></code> the default value implied by <cite>bias</cite> is overridden.
Note that <code class="docutils literal"><span class="pre">ddof=1</span></code> will return the unbiased estimate, even if both
<cite>fweights</cite> and <cite>aweights</cite> are specified, and <code class="docutils literal"><span class="pre">ddof=0</span></code> will return
the simple average. See the notes for the details. The default value
is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.5.</span></p>
</div>
</dd>
<dt>fweights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, int, optional</span></dt>
<dd><p class="first">1-D array of integer frequency weights; the number of times each
observation vector should be repeated.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.</span></p>
</div>
</dd>
<dt>aweights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd><p class="first">1-D array of observation vector weights. These relative weights are
typically large for observations considered “important” and smaller for
observations considered less “important”. If <code class="docutils literal"><span class="pre">ddof=0</span></code> the array of
weights can be used to assign probabilities to observation vectors.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The covariance matrix of the variables.</dd>
</dl>
<p>corrcoef : Normalized covariance matrix</p>
<p>Assume that the observations are in the columns of the observation
array <cite>m</cite> and let <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">fweights</span></code> and <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">aweights</span></code> for brevity. The
steps to compute the weighted covariance are as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">/</span> <span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">1</span></code>, the normalization factor
<code class="docutils literal"><span class="pre">v1</span> <span class="pre">/</span> <span class="pre">(v1**2</span> <span class="pre">-</span> <span class="pre">ddof</span> <span class="pre">*</span> <span class="pre">v2)</span></code> goes over to <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(np.sum(f)</span> <span class="pre">-</span> <span class="pre">ddof)</span></code>
as it should.</p>
<p>Consider two variables, <span class="math">\(x_0\)</span> and <span class="math">\(x_1\)</span>, which
correlate perfectly, but in opposite directions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [2, 1, 0]])</span>
</pre></div>
</div>
<p>Note how <span class="math">\(x_0\)</span> increases while <span class="math">\(x_1\)</span> decreases. The covariance
matrix shows this clearly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1., -1.],</span>
<span class="go">       [-1.,  1.]])</span>
</pre></div>
</div>
<p>Note that element <span class="math">\(C_{0,1}\)</span>, which shows the correlation between
<span class="math">\(x_0\)</span> and <span class="math">\(x_1\)</span>, is negative.</p>
<p>Further, note how <cite>x</cite> and <cite>y</cite> are combined:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">4.3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">0.12</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">[[ 11.71        -4.286     ]</span>
<span class="go"> [ -4.286        2.14413333]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">[[ 11.71        -4.286     ]</span>
<span class="go"> [ -4.286        2.14413333]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">11.71</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.corrcoef">
<code class="descclassname">numpy.</code><code class="descname">corrcoef</code><span class="sig-paren">(</span><em>x</em>, <em>y=None</em>, <em>rowvar=True</em>, <em>bias=&lt;no value&gt;</em>, <em>ddof=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.corrcoef" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Pearson product-moment correlation coefficients.</p>
<p>Please refer to the documentation for <cite>cov</cite> for more detail.  The
relationship between the correlation coefficient matrix, <cite>R</cite>, and the
covariance matrix, <cite>C</cite>, is</p>
<div class="math">
\[R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }\]</div>
<p>The values of <cite>R</cite> are between -1 and 1, inclusive.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>x</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>An additional set of variables and observations. <cite>y</cite> has the same
shape as <cite>x</cite>.</dd>
<dt>rowvar <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</dd>
<dt>bias <span class="classifier-delimiter">:</span> <span class="classifier">_NoValue, optional</span></dt>
<dd><p class="first">Has no effect, do not use.</p>
<div class="last deprecated">
<p><span class="versionmodified">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">_NoValue, optional</span></dt>
<dd><p class="first">Has no effect, do not use.</p>
<div class="last deprecated">
<p><span class="versionmodified">Deprecated since version 1.10.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The correlation coefficient matrix of the variables.</dd>
</dl>
<p>cov : Covariance matrix</p>
<p>Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.</p>
<p>This function accepts but discards arguments <cite>bias</cite> and <cite>ddof</cite>.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.msort">
<code class="descclassname">numpy.</code><code class="descname">msort</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.msort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of an array sorted along the first axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
</dl>
<dl class="docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>sort</p>
<p><code class="docutils literal"><span class="pre">np.msort(a)</span></code> is equivalent to  <code class="docutils literal"><span class="pre">np.sort(a,</span> <span class="pre">axis=0)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.median">
<code class="descclassname">numpy.</code><code class="descname">median</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis.</p>
<p>Returns the median of the array elements.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, sequence of int, None}, optional</span></dt>
<dd>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>arr</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>median <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>mean, percentile</p>
<p>Given a vector <code class="docutils literal"><span class="pre">V</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the median of <code class="docutils literal"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">V_sorted</span></code> - i
e., <code class="docutils literal"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal"><span class="pre">N</span></code> is odd, and the average of the
two middle values of <code class="docutils literal"><span class="pre">V_sorted</span></code> when <code class="docutils literal"><span class="pre">N</span></code> is even.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.sinc">
<code class="descclassname">numpy.</code><code class="descname">sinc</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sinc function.</p>
<p>The sinc function is <span class="math">\(\sin(\pi x)/(\pi x)\)</span>.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array (possibly multi-dimensional) of values for which to to
calculate <code class="docutils literal"><span class="pre">sinc(x)</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><code class="docutils literal"><span class="pre">sinc(x)</span></code>, which has the same shape as the input.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">sinc(0)</span></code> is the limit value 1.</p>
<p>The name sinc is short for “sine cardinal” or “sinus cardinalis”.</p>
<p>The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.</p>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Weisstein, Eric W. “Sinc Function.” From MathWorld–A Wolfram Web
Resource. <a class="reference external" href="http://mathworld.wolfram.com/SincFunction.html">http://mathworld.wolfram.com/SincFunction.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Wikipedia, “Sinc function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Sinc_function">http://en.wikipedia.org/wiki/Sinc_function</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,</span>
<span class="go">        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="go">         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="go">         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="go">        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="go">         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="go">         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="go">         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="go">         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="go">        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="go">        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="go">         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="go">        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="go">        -4.92362781e-02,  -3.89804309e-17])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Sinc Function&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It works in 2-D as well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">401</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x...&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.hamming">
<code class="descclassname">numpy.</code><code class="descname">hamming</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hamming" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hamming window.</p>
<p>The Hamming window is a taper formed by using a weighted cosine.</p>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points in the output window. If zero or less, an
empty array is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The window, with the maximum value normalized to one (the value
one appears only if the number of samples is odd).</dd>
</dl>
<p>bartlett, blackman, hanning, kaiser</p>
<p>The Hamming window is defined as</p>
<div class="math">
\[w(n) = 0.54 - 0.46cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
and is described in Blackman and Tukey. It was recommended for
smoothing the truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”, The
University of Alberta Press, 1975, pp. 109-110.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Wikipedia, “Window function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Window_function">http://en.wikipedia.org/wiki/Window_function</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 425.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,</span>
<span class="go">        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span>
<span class="go">        0.15302337,  0.08      ])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Hamming window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Hamming window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.hanning">
<code class="descclassname">numpy.</code><code class="descname">hanning</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hanning window.</p>
<p>The Hanning window is a taper formed by using a weighted cosine.</p>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points in the output window. If zero or less, an
empty array is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(M,)</span></dt>
<dd>The window, with the maximum value normalized to one (the value
one appears only if <cite>M</cite> is odd).</dd>
</dl>
<p>bartlett, blackman, hamming, kaiser</p>
<p>The Hanning window is defined as</p>
<div class="math">
\[w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)
\qquad 0 \leq n \leq M-1\]</div>
<p>The Hanning was named for Julius von Hann, an Austrian meteorologist.
It is also known as the Cosine Bell. Some authors prefer that it be
called a Hann window, to help avoid confusion with the very similar
Hamming window.</p>
<p>Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
spectra, Dover Publications, New York.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”,
The University of Alberta Press, 1975, pp. 106-108.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Wikipedia, “Window function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Window_function">http://en.wikipedia.org/wiki/Window_function</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 425.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,</span>
<span class="go">        0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,</span>
<span class="go">        0.07937323,  0.        ])</span>
</pre></div>
</div>
<p>Plot the window and its frequency response:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Hann window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of the Hann window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.bartlett">
<code class="descclassname">numpy.</code><code class="descname">bartlett</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.bartlett" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.</p>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points in the output window. If zero or less, an
empty array is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>The triangular window, with the maximum value normalized to one
(the value one appears only if the number of samples is odd), with
the first and last samples equal to zero.</dd>
</dl>
<p>blackman, hamming, hanning, kaiser</p>
<p>The Bartlett window is defined as</p>
<div class="math">
\[w(n) = \frac{2}{M-1} \left(
\frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
\right)\]</div>
<p>Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means”removing the foot”, i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich.</p>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>M.S. Bartlett, “Periodogram Analysis and Continuous Spectra”,
Biometrika 37, 1-16, 1950.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”,
The University of Alberta Press, 1975, pp. 109-110.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id46" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>A.V. Oppenheim and R.W. Schafer, “Discrete-Time Signal
Processing”, Prentice-Hall, 1999, pp. 468-471.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Wikipedia, “Window function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Window_function">http://en.wikipedia.org/wiki/Window_function</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
“Numerical Recipes”, Cambridge University Press, 1986, page 429.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,</span>
<span class="go">        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span>
<span class="go">        0.18181818,  0.        ])</span>
</pre></div>
</div>
<p>Plot the window and its frequency response (requires SciPy and matplotlib):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Bartlett window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Bartlett window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.blackman">
<code class="descclassname">numpy.</code><code class="descname">blackman</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.blackman" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three
terms of a summation of cosines. It was designed to have close to the
minimal leakage possible.  It is close to optimal, only slightly worse
than a Kaiser window.</p>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points in the output window. If zero or less, an empty
array is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The window, with the maximum value normalized to one (the value one
appears only if the number of samples is odd).</dd>
</dl>
<p>bartlett, hamming, hanning, kaiser</p>
<p>The Blackman window is defined as</p>
<div class="math">
\[w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)\]</div>
<p>Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
“near optimal” tapering function, almost as good (by some measures)
as the kaiser window.</p>
<p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
Dover Publications, New York.</p>
<p>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,</span>
<span class="go">         4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span>
<span class="go">         9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span>
<span class="go">         1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">51</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Blackman window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Blackman window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.kaiser">
<code class="descclassname">numpy.</code><code class="descname">kaiser</code><span class="sig-paren">(</span><em>M</em>, <em>beta</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.kaiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<dl class="docutils">
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of points in the output window. If zero or less, an
empty array is returned.</dd>
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Shape parameter for window.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>The window, with the maximum value normalized to one (the value
one appears only if the number of samples is odd).</dd>
</dl>
<p>bartlett, blackman, hamming, hanning</p>
<p>The Kaiser window is defined as</p>
<div class="math">
\[w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
\right)/I_0(\beta)\]</div>
<p>with</p>
<div class="math">
\[\quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},\]</div>
<p>where <span class="math">\(I_0\)</span> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple
approximation to the DPSS window based on Bessel functions.  The Kaiser
window is a very good approximation to the Digital Prolate Spheroidal
Sequence, or Slepian window, which is the transform which maximizes the
energy in the main lobe of the window relative to total energy.</p>
<p>The Kaiser can approximate many other windows by varying the beta
parameter.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">beta</th>
<th class="head">Window shape</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Rectangular</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>Similar to a Hamming</td>
</tr>
<tr class="row-even"><td>6</td>
<td>Similar to a Hanning</td>
</tr>
<tr class="row-odd"><td>8.6</td>
<td>Similar to a Blackman</td>
</tr>
</tbody>
</table>
<p>A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise NaNs will
get returned.</p>
<p>Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
“removing the foot”, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.</p>
<table class="docutils footnote" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>J. F. Kaiser, “Digital Filters” - Ch 7 in “Systems analysis by
digital computer”, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
John Wiley and Sons, New York, (1966).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>E.R. Kanasewich, “Time Sequence Analysis in Geophysics”, The
University of Alberta Press, 1975, pp. 177-178.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id51" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Wikipedia, “Window function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Window_function">http://en.wikipedia.org/wiki/Window_function</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="go">array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,</span>
<span class="go">         2.29737120e-01,   5.99885316e-01,   9.45674898e-01,</span>
<span class="go">         9.45674898e-01,   5.99885316e-01,   2.29737120e-01,</span>
<span class="go">         4.65200189e-02,   3.46009194e-03,   7.72686684e-06])</span>
</pre></div>
</div>
<p>Plot the window and the frequency response:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="k">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Kaiser window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="mf">25.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Frequency response of Kaiser window&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Magnitude [dB]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Normalized frequency [cycles per sample]&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="go">(-0.5, 0.5, -100.0, ...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.trapz">
<code class="descclassname">numpy.</code><code class="descname">trapz</code><span class="sig-paren">(</span><em>y</em>, <em>x=None</em>, <em>dx=1.0</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.trapz" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate along the given axis using the composite trapezoidal rule.</p>
<p>Integrate <cite>y</cite> (<cite>x</cite>) along given axis.</p>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array to integrate.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>The sample points corresponding to the <cite>y</cite> values. If <cite>x</cite> is None,
the sample points are assumed to be evenly spaced <cite>dx</cite> apart. The
default is None.</dd>
<dt>dx <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>The spacing between sample points when <cite>x</cite> is None. The default is 1.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to integrate.</dd>
</dl>
<dl class="docutils">
<dt>trapz <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Definite integral as approximated by trapezoidal rule.</dd>
</dl>
<p>sum, cumsum</p>
<p>Image <a href="#id93"><span class="problematic" id="id52">[2]_</span></a> illustrates trapezoidal rule – y-axis locations of points
will be taken from <cite>y</cite> array, by default x-axis distances between
points will be 1.0, alternatively they can be provided with <cite>x</cite> array
or with <cite>dx</cite> scalar.  Return value will be equal to combined area under
the red lines.</p>
<table class="docutils footnote" frame="void" id="id53" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Wikipedia page: <a class="reference external" href="http://en.wikipedia.org/wiki/Trapezoidal_rule">http://en.wikipedia.org/wiki/Trapezoidal_rule</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id54" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Illustration image:
<a class="reference external" href="http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png">http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="go">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.5,  2.5,  3.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 2.,  8.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.i0">
<code class="descclassname">numpy.</code><code class="descname">i0</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.i0" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified Bessel function of the first kind, order 0.</p>
<p>Usually denoted <span class="math">\(I_0\)</span>.  This function does broadcast, but will <em>not</em>
“up-cast” int dtype arguments unless accompanied by at least one float or
complex dtype argument (see Raises below).</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like, dtype float or complex</span></dt>
<dd>Argument of the Bessel function.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape = x.shape, dtype = x.dtype</span></dt>
<dd>The modified Bessel function evaluated at each of the elements of <cite>x</cite>.</dd>
</dl>
<dl class="docutils">
<dt>TypeError: array cannot be safely cast to required type</dt>
<dd>If argument consists exclusively of int dtypes.</dd>
</dl>
<p>scipy.special.iv, scipy.special.ive</p>
<p>We use the algorithm published by Clenshaw <a href="#id94"><span class="problematic" id="id55">[1]_</span></a> and referenced by
Abramowitz and Stegun <a href="#id95"><span class="problematic" id="id56">[2]_</span></a>, for which the function domain is
partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
polynomial expansions are employed in each interval. Relative error on
the domain [0,30] using IEEE arithmetic is documented <a href="#id96"><span class="problematic" id="id57">[3]_</span></a> as having a
peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</p>
<table class="docutils footnote" frame="void" id="id58" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>C. W. Clenshaw, “Chebyshev series for mathematical functions”, in
<em>National Physical Laboratory Mathematical Tables</em>, vol. 5, London:
Her Majesty’s Stationery Office, 1962.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>M. Abramowitz and I. A. Stegun, <em>Handbook of Mathematical
Functions</em>, 10th printing, New York: Dover, 1964, pp. 379.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_379.htm">http://www.math.sfu.ca/~cbm/aands/page_379.htm</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id60" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html">http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">array(1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.add_newdoc">
<code class="descclassname">numpy.</code><code class="descname">add_newdoc</code><span class="sig-paren">(</span><em>place</em>, <em>obj</em>, <em>doc</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_newdoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds documentation to obj which is in module place.</p>
<p>If doc is a string add it to obj as a docstring</p>
<dl class="docutils">
<dt>If doc is a tuple, then the first element is interpreted as</dt>
<dd><dl class="first last docutils">
<dt>an attribute of obj and the second as the docstring</dt>
<dd>(method, docstring)</dd>
</dl>
</dd>
<dt>If doc is a list, then each element of the list should be a</dt>
<dd>sequence of length two –&gt; [(method1, docstring1),
(method2, docstring2), …]</dd>
</dl>
<p>This routine never raises an error.</p>
<p>This routine cannot modify read-only docstrings, as appear
in new-style classes or built-in functions. Because this
routine never raises an error the caller must check manually
that the docstrings were changed.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.add_docstring">
<code class="descclassname">numpy.</code><code class="descname">add_docstring</code><span class="sig-paren">(</span><em>obj</em>, <em>docstring</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_docstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a docstring to a built-in obj if possible.
If the obj already has a docstring raise a RuntimeError
If this routine does not know how to add a docstring to the object
raise a TypeError</p>
</dd></dl>

<dl class="function">
<dt id="numpy.meshgrid">
<code class="descclassname">numpy.</code><code class="descname">meshgrid</code><span class="sig-paren">(</span><em>*xi</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return coordinate matrices from coordinate vectors.</p>
<p>Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,…, xn.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9: </span>1-D and 0-D cases are allowed.</p>
</div>
<dl class="docutils">
<dt>x1, x2,…, xn <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>1-D arrays representing the coordinates of a grid.</dd>
<dt>indexing <span class="classifier-delimiter">:</span> <span class="classifier">{‘xy’, ‘ij’}, optional</span></dt>
<dd><p class="first">Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output.
See Notes for more details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>sparse <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True a sparse grid is returned in order to conserve memory.
Default is False.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If False, a view into the original arrays are returned in order to
conserve memory.  Default is True.  Please note that
<code class="docutils literal"><span class="pre">sparse=False,</span> <span class="pre">copy=False</span></code> will likely return non-contiguous
arrays.  Furthermore, more than one element of a broadcast array
may refer to a single memory location.  If you need to write to the
arrays, make copies first.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>X1, X2,…, XN <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>For vectors <cite>x1</cite>, <cite>x2</cite>,…, ‘xn’ with lengths <code class="docutils literal"><span class="pre">Ni=len(xi)</span></code> ,
return <code class="docutils literal"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’ij’
or <code class="docutils literal"><span class="pre">(N2,</span> <span class="pre">N1,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’xy’
with the elements of <cite>xi</cite> repeated to fill the matrix along
the first dimension for <cite>x1</cite>, the second for <cite>x2</cite> and so on.</dd>
</dl>
<p>This function supports both indexing conventions through the indexing
keyword argument.  Giving the string ‘ij’ returns a meshgrid with
matrix indexing, while ‘xy’ returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for ‘xy’ indexing and (M, N) for ‘ij’ indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
‘xy’ indexing and (M, N, P) for ‘ij’ indexing.  The difference is
illustrated by the following code snippet:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[i,j], yv[i,j]</span>

<span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[j,i], yv[j,i]</span>
</pre></div>
</div>
<p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p>
<dl class="docutils">
<dt>index_tricks.mgrid <span class="classifier-delimiter">:</span> <span class="classifier">Construct a multi-dimensional “meshgrid”</span></dt>
<dd>using indexing notation.</dd>
<dt>index_tricks.ogrid <span class="classifier-delimiter">:</span> <span class="classifier">Construct an open multi-dimensional “meshgrid”</span></dt>
<dd>using indexing notation.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># make sparse output arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<p><cite>meshgrid</cite> is very useful to evaluate functions on a grid.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.delete">
<code class="descclassname">numpy.</code><code class="descname">delete</code><span class="sig-paren">(</span><em>arr</em>, <em>obj</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with sub-arrays along an axis deleted. For a one
dimensional array, this returns those entries not returned by
<cite>arr[obj]</cite>.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">slice, int or array of ints</span></dt>
<dd>Indicate which sub-arrays to remove.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to delete the subarray defined by <cite>obj</cite>.
If <cite>axis</cite> is None, <cite>obj</cite> is applied to the flattened array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <cite>arr</cite> with the elements specified by <cite>obj</cite> removed. Note
that <cite>delete</cite> does not occur in-place. If <cite>axis</cite> is None, <cite>out</cite> is
a flattened array.</dd>
</dl>
<p>insert : Insert elements into an array.
append : Append elements at the end of an array.</p>
<p>Often it is preferable to use a boolean mask. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Is equivalent to <cite>np.delete(arr, [0,2,4], axis=0)</cite>, but allows further
use of <cite>mask</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([[ 1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8],</span>
<span class="go">       [ 9, 10, 11, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3,  4],</span>
<span class="go">       [ 9, 10, 11, 12]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 2,  4],</span>
<span class="go">       [ 6,  8],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.insert">
<code class="descclassname">numpy.</code><code class="descname">insert</code><span class="sig-paren">(</span><em>arr</em>, <em>obj</em>, <em>values</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert values along the given axis before the given indices.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">int, slice or sequence of ints</span></dt>
<dd><p class="first">Object that defines the index or indices before which <cite>values</cite> is
inserted.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<p class="last">Support for multiple insertions when <cite>obj</cite> is a single scalar or a
sequence with one element (similar to calling insert multiple
times).</p>
</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to insert into <cite>arr</cite>. If the type of <cite>values</cite> is different
from that of <cite>arr</cite>, <cite>values</cite> is converted to the type of <cite>arr</cite>.
<cite>values</cite> should be shaped so that <code class="docutils literal"><span class="pre">arr[...,obj,...]</span> <span class="pre">=</span> <span class="pre">values</span></code>
is legal.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to insert <cite>values</cite>.  If <cite>axis</cite> is None then <cite>arr</cite>
is flattened first.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <cite>arr</cite> with <cite>values</cite> inserted.  Note that <cite>insert</cite>
does not occur in-place: a new array is returned. If
<cite>axis</cite> is None, <cite>out</cite> is a flattened array.</dd>
</dl>
<p>append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.</p>
<p>Note that for higher dimensional inserts <cite>obj=0</cite> behaves very different
from <cite>obj=[0]</cite> just like <cite>arr[:,0,:] = values</cite> is different from
<cite>arr[:,[0],:] = values</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([1, 5, 1, 2, 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 5, 1],</span>
<span class="go">       [2, 5, 2],</span>
<span class="go">       [3, 5, 3]])</span>
</pre></div>
</div>
<p>Difference between sequence and scalars:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [2, 2, 2],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>               <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([1, 1, 2, 2, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([1, 1, 5, 6, 2, 2, 3, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">array([1, 1, 5, 2, 6, 2, 3, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">7.13</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span> <span class="c1"># type casting</span>
<span class="go">array([1, 1, 7, 0, 2, 2, 3, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  0, 999,   1,   2, 999,   3],</span>
<span class="go">       [  4, 999,   5,   6, 999,   7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.append">
<code class="descclassname">numpy.</code><code class="descname">append</code><span class="sig-paren">(</span><em>arr</em>, <em>values</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values to the end of an array.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values are appended to a copy of this array.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>These values are appended to a copy of <cite>arr</cite>.  It must be of the
correct shape (the same shape as <cite>arr</cite>, excluding <cite>axis</cite>).  If
<cite>axis</cite> is not specified, <cite>values</cite> can be any shape and will be
flattened before use.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which <cite>values</cite> are appended.  If <cite>axis</cite> is not
given, both <cite>arr</cite> and <cite>values</cite> are flattened before use.</dd>
</dl>
<dl class="docutils">
<dt>append <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <cite>arr</cite> with <cite>values</cite> appended to <cite>axis</cite>.  Note that
<cite>append</cite> does not occur in-place: a new array is allocated and
filled.  If <cite>axis</cite> is None, <cite>out</cite> is a flattened array.</dd>
</dl>
<p>insert : Insert elements into an array.
delete : Delete elements from an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p>When <cite>axis</cite> is specified, <cite>values</cite> must have the correct shape.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">arrays must have same number of dimensions</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.interp">
<code class="descclassname">numpy.</code><code class="descname">interp</code><span class="sig-paren">(</span><em>x</em>, <em>xp</em>, <em>fp</em>, <em>left=None</em>, <em>right=None</em>, <em>period=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.interp" title="Permalink to this definition">¶</a></dt>
<dd><p>One-dimensional linear interpolation.</p>
<p>Returns the one-dimensional piecewise linear interpolant to a function
with given discrete data points (<cite>xp</cite>, <cite>fp</cite>), evaluated at <cite>x</cite>.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The x-coordinates at which to evaluate the interpolated values.</dd>
<dt>xp <span class="classifier-delimiter">:</span> <span class="classifier">1-D sequence of floats</span></dt>
<dd>The x-coordinates of the data points, must be increasing if argument
<cite>period</cite> is not specified. Otherwise, <cite>xp</cite> is internally sorted after
normalizing the periodic boundaries with <code class="docutils literal"><span class="pre">xp</span> <span class="pre">=</span> <span class="pre">xp</span> <span class="pre">%</span> <span class="pre">period</span></code>.</dd>
<dt>fp <span class="classifier-delimiter">:</span> <span class="classifier">1-D sequence of float or complex</span></dt>
<dd>The y-coordinates of the data points, same length as <cite>xp</cite>.</dd>
<dt>left <span class="classifier-delimiter">:</span> <span class="classifier">optional float or complex corresponding to fp</span></dt>
<dd>Value to return for <cite>x &lt; xp[0]</cite>, default is <cite>fp[0]</cite>.</dd>
<dt>right <span class="classifier-delimiter">:</span> <span class="classifier">optional float or complex corresponding to fp</span></dt>
<dd>Value to return for <cite>x &gt; xp[-1]</cite>, default is <cite>fp[-1]</cite>.</dd>
<dt>period <span class="classifier-delimiter">:</span> <span class="classifier">None or float, optional</span></dt>
<dd><p class="first">A period for the x-coordinates. This parameter allows the proper
interpolation of angular x-coordinates. Parameters <cite>left</cite> and <cite>right</cite>
are ignored if <cite>period</cite> is specified.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">float or complex (corresponding to fp) or ndarray</span></dt>
<dd>The interpolated values, same shape as <cite>x</cite>.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>xp</cite> and <cite>fp</cite> have different length
If <cite>xp</cite> or <cite>fp</cite> are not 1-D sequences
If <cite>period == 0</cite></dd>
</dl>
<p>Does not check that the x-coordinate sequence <cite>xp</cite> is increasing.
If <cite>xp</cite> is not increasing, the results are nonsense.
A simple check for increasing is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.72</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">],</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">UNDEF</span> <span class="o">=</span> <span class="o">-</span><span class="mf">99.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">UNDEF</span><span class="p">)</span>
<span class="go">-99.0</span>
</pre></div>
</div>
<p>Plot an interpolant to the sine function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="s1">&#39;-x&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Interpolation with periodic x-coordinates:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="o">-</span><span class="mi">170</span><span class="p">,</span> <span class="o">-</span><span class="mi">185</span><span class="p">,</span> <span class="mi">185</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">365</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">190</span><span class="p">,</span> <span class="o">-</span><span class="mi">190</span><span class="p">,</span> <span class="mi">350</span><span class="p">,</span> <span class="o">-</span><span class="mi">350</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">360</span><span class="p">)</span>
<span class="go">array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])</span>
</pre></div>
</div>
<p>Complex interpolation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
<span class="go">array([ 0.+1.j ,  1.+1.5j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.add_newdoc_ufunc">
<code class="descclassname">numpy.</code><code class="descname">add_newdoc_ufunc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.add_newdoc_ufunc" title="Permalink to this definition">¶</a></dt>
<dd><p>add_ufunc_docstring(ufunc, new_docstring)</p>
<p>Replace the docstring for a ufunc with new_docstring.
This method will only work if the current docstring for
the ufunc is NULL. (At the C level, i.e. when ufunc-&gt;doc is NULL.)</p>
<dl class="docutils">
<dt>ufunc <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ufunc</span></dt>
<dd>A ufunc whose current doc is NULL.</dd>
<dt>new_docstring <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The new docstring for the ufunc.</dd>
</dl>
<p>This method allocates memory for new_docstring on
the heap. Technically this creates a mempory leak, since this
memory will not be reclaimed until the end of the program
even if the ufunc itself is removed. However this will only
be a problem if the user is repeatedly creating ufuncs with
no documentation, adding documentation via add_newdoc_ufunc,
and then throwing away the ufunc.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.quantile">
<code class="descclassname">numpy.</code><code class="descname">quantile</code><span class="sig-paren">(</span><em>a</em>, <em>q</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>interpolation='linear'</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <a href="#id61"><span class="problematic" id="id62">`</span></a>q`th quantile of the data along the specified axis.
..versionadded:: 1.15.0</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">array_like of float</span></dt>
<dd>Quantile or sequence of quantiles to compute, which must be between
0 and 1 inclusive.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the quantiles are computed. The
default is to compute the quantile(s) along a flattened
version of the array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</dd>
<dt>interpolation <span class="classifier-delimiter">:</span> <span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first">This optional parameter specifies the interpolation method to
use when the desired quantile lies between two data points
<code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<blockquote class="last">
<div><ul class="simple">
<li>linear: <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal"><span class="pre">i</span></code>
and <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>lower: <code class="docutils literal"><span class="pre">i</span></code>.</li>
<li>higher: <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>nearest: <code class="docutils literal"><span class="pre">i</span></code> or <code class="docutils literal"><span class="pre">j</span></code>, whichever is nearest.</li>
<li>midpoint: <code class="docutils literal"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</li>
</ul>
</div></blockquote>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</dd>
</dl>
<dl class="docutils">
<dt>quantile <span class="classifier-delimiter">:</span> <span class="classifier">scalar or ndarray</span></dt>
<dd>If <cite>q</cite> is a single quantile and <cite>axis=None</cite>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>mean
percentile : equivalent to quantile, but with q in the range [0, 100].
median : equivalent to <code class="docutils literal"><span class="pre">quantile(...,</span> <span class="pre">0.5)</span></code>
nanquantile</p>
<p>Given a vector <code class="docutils literal"><span class="pre">V</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the <code class="docutils literal"><span class="pre">q</span></code>-th quantile of
<code class="docutils literal"><span class="pre">V</span></code> is the value <code class="docutils literal"><span class="pre">q</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the quantile if the normalized ranking does not
match the location of <code class="docutils literal"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal"><span class="pre">q=0.5</span></code>, the same as the minimum if <code class="docutils literal"><span class="pre">q=0.0</span></code> and the
same as the maximum if <code class="docutils literal"><span class="pre">q=1.0</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.column_stack">
<code class="descclassname">numpy.</code><code class="descname">column_stack</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.column_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack 1-D arrays as columns into a 2-D array.</p>
<p>Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with <cite>hstack</cite>.  1-D arrays are turned into 2-D columns
first.</p>
<dl class="docutils">
<dt>tup <span class="classifier-delimiter">:</span> <span class="classifier">sequence of 1-D or 2-D arrays.</span></dt>
<dd>Arrays to stack. All of them must have the same first dimension.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">2-D array</span></dt>
<dd>The array formed by stacking the given arrays.</dd>
</dl>
<p>stack, hstack, vstack, concatenate</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.row_stack">
<code class="descclassname">numpy.</code><code class="descname">row_stack</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.row_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="docutils">
<dt>tup <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ndarrays</span></dt>
<dd>The arrays must have the same shape along all but the first axis.
1-D arrays must have the same length.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array formed by stacking the given arrays, will be at least 2-D.</dd>
</dl>
<p>stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays along an existing axis.
vsplit : Split array into a list of multiple sub-arrays vertically.
block : Assemble arrays from blocks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.dstack">
<code class="descclassname">numpy.</code><code class="descname">dstack</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence depth wise (along third axis).</p>
<p>This is equivalent to concatenation along the third axis after 2-D arrays
of shape <cite>(M,N)</cite> have been reshaped to <cite>(M,N,1)</cite> and 1-D arrays of shape
<cite>(N,)</cite> have been reshaped to <cite>(1,N,1)</cite>. Rebuilds arrays divided by
<cite>dsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="docutils">
<dt>tup <span class="classifier-delimiter">:</span> <span class="classifier">sequence of arrays</span></dt>
<dd>The arrays must have the same shape along all but the third axis.
1-D or 2-D arrays must have the same shape.</dd>
</dl>
<dl class="docutils">
<dt>stacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The array formed by stacking the given arrays, will be at least 3-D.</dd>
</dl>
<p>stack : Join a sequence of arrays along a new axis.
vstack : Stack along first axis.
hstack : Stack along second axis.
concatenate : Join a sequence of arrays along an existing axis.
dsplit : Split array along third axis.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2],</span>
<span class="go">        [2, 3],</span>
<span class="go">        [3, 4]]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2]],</span>
<span class="go">       [[2, 3]],</span>
<span class="go">       [[3, 4]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.array_split">
<code class="descclassname">numpy.</code><code class="descname">array_split</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.array_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays.</p>
<p>Please refer to the <code class="docutils literal"><span class="pre">split</span></code> documentation.  The only difference
between these functions is that <code class="docutils literal"><span class="pre">array_split</span></code> allows
<cite>indices_or_sections</cite> to be an integer that does <em>not</em> equally
divide the axis. For an array of length l that should be split
into n sections, it returns l % n sub-arrays of size l//n + 1
and the rest of size l//n.</p>
<p>split : Split array into multiple sub-arrays of equal size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">7.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">    [array([ 0.,  1.,  2.]), array([ 3.,  4.]), array([ 5.,  6.])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.split">
<code class="descclassname">numpy.</code><code class="descname">split</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays.</p>
<dl class="docutils">
<dt>ary <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array to be divided into sub-arrays.</dd>
<dt>indices_or_sections <span class="classifier-delimiter">:</span> <span class="classifier">int or 1-D array</span></dt>
<dd><p class="first">If <cite>indices_or_sections</cite> is an integer, N, the array will be divided
into N equal arrays along <cite>axis</cite>.  If such a split is not possible,
an error is raised.</p>
<p>If <cite>indices_or_sections</cite> is a 1-D array of sorted integers, the entries
indicate where along <cite>axis</cite> the array is split.  For example,
<code class="docutils literal"><span class="pre">[2,</span> <span class="pre">3]</span></code> would, for <code class="docutils literal"><span class="pre">axis=0</span></code>, result in</p>
<blockquote>
<div><ul class="simple">
<li>ary[:2]</li>
<li>ary[2:3]</li>
<li>ary[3:]</li>
</ul>
</div></blockquote>
<p class="last">If an index exceeds the dimension of the array along <cite>axis</cite>,
an empty sub-array is returned correspondingly.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to split, default is 0.</dd>
</dl>
<dl class="docutils">
<dt>sub-arrays <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarrays</span></dt>
<dd>A list of sub-arrays.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If <cite>indices_or_sections</cite> is given as an integer, but
a split does not result in equal division.</dd>
</dl>
<dl class="docutils">
<dt>array_split <span class="classifier-delimiter">:</span> <span class="classifier">Split an array into multiple sub-arrays of equal or</span></dt>
<dd>near-equal size.  Does not raise an exception if
an equal division cannot be made.</dd>
</dl>
<p>hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">[array([ 0.,  1.,  2.]),</span>
<span class="go"> array([ 3.,  4.]),</span>
<span class="go"> array([ 5.]),</span>
<span class="go"> array([ 6.,  7.]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.hsplit">
<code class="descclassname">numpy.</code><code class="descname">hsplit</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.hsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays horizontally (column-wise).</p>
<p>Please refer to the <cite>split</cite> documentation.  <cite>hsplit</cite> is equivalent
to <cite>split</cite> with <code class="docutils literal"><span class="pre">axis=1</span></code>, the array is always split along the second
axis regardless of the array dimension.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[  0.,   1.,   2.,   3.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.],</span>
<span class="go">       [ 12.,  13.,  14.,  15.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[  0.,   1.],</span>
<span class="go">       [  4.,   5.],</span>
<span class="go">       [  8.,   9.],</span>
<span class="go">       [ 12.,  13.]]),</span>
<span class="go"> array([[  2.,   3.],</span>
<span class="go">       [  6.,   7.],</span>
<span class="go">       [ 10.,  11.],</span>
<span class="go">       [ 14.,  15.]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[  0.,   1.,   2.],</span>
<span class="go">       [  4.,   5.,   6.],</span>
<span class="go">       [  8.,   9.,  10.],</span>
<span class="go">       [ 12.,  13.,  14.]]),</span>
<span class="go"> array([[  3.],</span>
<span class="go">       [  7.],</span>
<span class="go">       [ 11.],</span>
<span class="go">       [ 15.]]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
<p>With a higher dimensional array the split is still along the second axis.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0.,  1.],</span>
<span class="go">        [ 2.,  3.]],</span>
<span class="go">       [[ 4.,  5.],</span>
<span class="go">        [ 6.,  7.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[ 0.,  1.]],</span>
<span class="go">       [[ 4.,  5.]]]),</span>
<span class="go"> array([[[ 2.,  3.]],</span>
<span class="go">       [[ 6.,  7.]]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.vsplit">
<code class="descclassname">numpy.</code><code class="descname">vsplit</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays vertically (row-wise).</p>
<p>Please refer to the <code class="docutils literal"><span class="pre">split</span></code> documentation.  <code class="docutils literal"><span class="pre">vsplit</span></code> is equivalent
to <code class="docutils literal"><span class="pre">split</span></code> with <cite>axis=0</cite> (default), the array is always split along the
first axis regardless of the array dimension.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[  0.,   1.,   2.,   3.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.],</span>
<span class="go">       [ 12.,  13.,  14.,  15.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[ 0.,  1.,  2.,  3.],</span>
<span class="go">       [ 4.,  5.,  6.,  7.]]),</span>
<span class="go"> array([[  8.,   9.,  10.,  11.],</span>
<span class="go">       [ 12.,  13.,  14.,  15.]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[  0.,   1.,   2.,   3.],</span>
<span class="go">       [  4.,   5.,   6.,   7.],</span>
<span class="go">       [  8.,   9.,  10.,  11.]]),</span>
<span class="go"> array([[ 12.,  13.,  14.,  15.]]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
<p>With a higher dimensional array the split is still along the first axis.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0.,  1.],</span>
<span class="go">        [ 2.,  3.]],</span>
<span class="go">       [[ 4.,  5.],</span>
<span class="go">        [ 6.,  7.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[ 0.,  1.],</span>
<span class="go">        [ 2.,  3.]]]),</span>
<span class="go"> array([[[ 4.,  5.],</span>
<span class="go">        [ 6.,  7.]]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.dsplit">
<code class="descclassname">numpy.</code><code class="descname">dsplit</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.dsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p>
<p>Please refer to the <cite>split</cite> documentation.  <cite>dsplit</cite> is equivalent
to <cite>split</cite> with <code class="docutils literal"><span class="pre">axis=2</span></code>, the array is always split along the third
axis provided the array dimension is greater than or equal to 3.</p>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">16.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[  0.,   1.,   2.,   3.],</span>
<span class="go">        [  4.,   5.,   6.,   7.]],</span>
<span class="go">       [[  8.,   9.,  10.,  11.],</span>
<span class="go">        [ 12.,  13.,  14.,  15.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[array([[[  0.,   1.],</span>
<span class="go">        [  4.,   5.]],</span>
<span class="go">       [[  8.,   9.],</span>
<span class="go">        [ 12.,  13.]]]),</span>
<span class="go"> array([[[  2.,   3.],</span>
<span class="go">        [  6.,   7.]],</span>
<span class="go">       [[ 10.,  11.],</span>
<span class="go">        [ 14.,  15.]]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dsplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[array([[[  0.,   1.,   2.],</span>
<span class="go">        [  4.,   5.,   6.]],</span>
<span class="go">       [[  8.,   9.,  10.],</span>
<span class="go">        [ 12.,  13.,  14.]]]),</span>
<span class="go"> array([[[  3.],</span>
<span class="go">        [  7.]],</span>
<span class="go">       [[ 11.],</span>
<span class="go">        [ 15.]]]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.apply_over_axes">
<code class="descclassname">numpy.</code><code class="descname">apply_over_axes</code><span class="sig-paren">(</span><em>func</em>, <em>a</em>, <em>axes</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.apply_over_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function repeatedly over multiple axes.</p>
<p><cite>func</cite> is called as <cite>res = func(a, axis)</cite>, where <cite>axis</cite> is the first
element of <cite>axes</cite>.  The result <cite>res</cite> of the function call must have
either the same dimensions as <cite>a</cite> or one less dimension.  If <cite>res</cite>
has one less dimension than <cite>a</cite>, a dimension is inserted before
<cite>axis</cite>.  The call to <cite>func</cite> is then repeated for each axis in <cite>axes</cite>,
with <cite>res</cite> as the first argument.</p>
<dl class="docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>This function must take two arguments, <cite>func(a, axis)</cite>.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Axes over which <cite>func</cite> is applied; the elements must be integers.</dd>
</dl>
<dl class="docutils">
<dt>apply_over_axis <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The output array.  The number of dimensions is the same as <cite>a</cite>,
but the shape can be different.  This depends on whether <cite>func</cite>
changes the shape of its output with respect to its input.</dd>
</dl>
<dl class="docutils">
<dt>apply_along_axis :</dt>
<dd>Apply a function to 1-D slices of an array along the given axis.</dd>
</dl>
<p>This function is equivalent to tuple axis arguments to reorderable ufuncs
with keepdims=True. Tuple axis arguments to ufuncs have been available since
version 1.7.0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
</pre></div>
</div>
<p>Sum over axes 0 and 2. The result has same number of dimensions
as the original array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
<p>Tuple axis arguments to ufuncs are equivalent:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[[ 60],</span>
<span class="go">        [ 92],</span>
<span class="go">        [124]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.expand_dims">
<code class="descclassname">numpy.</code><code class="descname">expand_dims</code><span class="sig-paren">(</span><em>a</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the shape of an array.</p>
<p>Insert a new axis that will appear at the <cite>axis</cite> position in the expanded
array shape.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Previous to NumPy 1.13.0, neither <code class="docutils literal"><span class="pre">axis</span> <span class="pre">&lt;</span> <span class="pre">-a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code> nor
<code class="docutils literal"><span class="pre">axis</span> <span class="pre">&gt;</span> <span class="pre">a.ndim</span></code> raised errors or put the new axis where documented.
Those axis values are now deprecated and will raise an AxisError in the
future.</p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Position in the expanded axes where the new axis is placed.</dd>
</dl>
<dl class="docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Output array. The number of dimensions is one greater than that of
the input array.</dd>
</dl>
<p>squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
<p>The following is equivalent to <code class="docutils literal"><span class="pre">x[np.newaxis,:]</span></code> or <code class="docutils literal"><span class="pre">x[np.newaxis]</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Equivalent to x[:,np.newaxis]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1],</span>
<span class="go">       [2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
<p>Note that some examples may use <code class="docutils literal"><span class="pre">None</span></code> instead of <code class="docutils literal"><span class="pre">np.newaxis</span></code>.  These
are the same objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.apply_along_axis">
<code class="descclassname">numpy.</code><code class="descname">apply_along_axis</code><span class="sig-paren">(</span><em>func1d</em>, <em>axis</em>, <em>arr</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.apply_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to 1-D slices along the given axis.</p>
<p>Execute <cite>func1d(a, *args)</cite> where <cite>func1d</cite> operates on 1-D arrays and <cite>a</cite>
is a 1-D slice of <cite>arr</cite> along <cite>axis</cite>.</p>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal"><span class="pre">ii</span></code>, <code class="docutils literal"><span class="pre">jj</span></code>, and <code class="docutils literal"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, this can be expressed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>func1d <span class="classifier-delimiter">:</span> <span class="classifier">function (M,) -&gt; (Nj…)</span></dt>
<dd>This function should accept 1-D arrays. It is applied to 1-D
slices of <cite>arr</cite> along the specified axis.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>Axis along which <cite>arr</cite> is sliced.</dd>
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (Ni…, M, Nk…)</span></dt>
<dd>Input array.</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd>Additional arguments to <cite>func1d</cite>.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">any</span></dt>
<dd><p class="first">Additional named arguments to <cite>func1d</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray  (Ni…, Nj…, Nk…)</span></dt>
<dd>The output array. The shape of <cite>out</cite> is identical to the shape of
<cite>arr</cite>, except along the <cite>axis</cite> dimension. This axis is removed, and
replaced with new dimensions equal to the shape of the return value
of <cite>func1d</cite>. So if <cite>func1d</cite> returns a scalar <cite>out</cite> will have one
fewer dimensions than <cite>arr</cite>.</dd>
</dl>
<p>apply_over_axes : Apply a function repeatedly over multiple axes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Average first and last element of a 1-D array&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 4.,  5.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 2.,  5.,  8.])</span>
</pre></div>
</div>
<p>For a function that returns a 1D array, the number of dimensions in
<cite>outarr</cite> is the same as <cite>arr</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="nb">sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 7, 8],</span>
<span class="go">       [3, 4, 9],</span>
<span class="go">       [2, 5, 6]])</span>
</pre></div>
</div>
<p>For a function that returns a higher dimensional array, those dimensions
are inserted in place of the <cite>axis</cite> dimension.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[[1, 0, 0],</span>
<span class="go">        [0, 2, 0],</span>
<span class="go">        [0, 0, 3]],</span>
<span class="go">       [[4, 0, 0],</span>
<span class="go">        [0, 5, 0],</span>
<span class="go">        [0, 0, 6]],</span>
<span class="go">       [[7, 0, 0],</span>
<span class="go">        [0, 8, 0],</span>
<span class="go">        [0, 0, 9]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.kron">
<code class="descclassname">numpy.</code><code class="descname">kron</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of two arrays.</p>
<p>Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.</p>
<p>a, b : array_like</p>
<p>out : ndarray</p>
<p>outer : The outer product</p>
<p>The function assumes that the number of dimensions of <cite>a</cite> and <cite>b</cite>
are the same, if necessary prepending the smallest with ones.
If <cite>a.shape = (r0,r1,..,rN)</cite> and <cite>b.shape = (s0,s1,…,sN)</cite>,
the Kronecker product has shape <cite>(r0*s0, r1*s1, …, rN*SN)</cite>.
The elements are products of elements from <cite>a</cite> and <cite>b</cite>, organized
explicitly by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)[</span><span class="n">k0</span><span class="p">,</span><span class="n">k1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">kN</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">iN</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">jN</span><span class="p">]</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">kt</span> <span class="o">=</span> <span class="n">it</span> <span class="o">*</span> <span class="n">st</span> <span class="o">+</span> <span class="n">jt</span><span class="p">,</span>  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">N</span>
</pre></div>
</div>
<p>In the common 2-D case (N=1), the block structure can be visualized:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span>  <span class="p">],</span>
 <span class="p">[</span>  <span class="o">...</span>                              <span class="o">...</span>   <span class="p">],</span>
 <span class="p">[</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span> <span class="p">]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="go">array([  5,   6,   7,  50,  60,  70, 500, 600, 700])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="go">array([  5,  50, 500,   6,  60, 600,   7,  70, 700])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">array([[ 1.,  1.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 10, 6, 20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">J</span>             <span class="c1"># extend to ndim=4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">J</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tile">
<code class="descclassname">numpy.</code><code class="descname">tile</code><span class="sig-paren">(</span><em>A</em>, <em>reps</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating A the number of times given by reps.</p>
<p>If <cite>reps</cite> has length <code class="docutils literal"><span class="pre">d</span></code>, the result will have dimension of
<code class="docutils literal"><span class="pre">max(d,</span> <span class="pre">A.ndim)</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">A.ndim</span> <span class="pre">&lt;</span> <span class="pre">d</span></code>, <cite>A</cite> is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote <cite>A</cite> to d-dimensions manually before calling this
function.</p>
<p>If <code class="docutils literal"><span class="pre">A.ndim</span> <span class="pre">&gt;</span> <span class="pre">d</span></code>, <cite>reps</cite> is promoted to <cite>A</cite>.ndim by pre-pending 1’s to it.
Thus for an <cite>A</cite> of shape (2, 3, 4, 5), a <cite>reps</cite> of (2, 2) is treated as
(1, 1, 2, 2).</p>
<p>Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy’s broadcasting operations and functions.</p>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The input array.</dd>
<dt>reps <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The number of repetitions of <cite>A</cite> along each axis.</dd>
</dl>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The tiled output array.</dd>
</dl>
<p>repeat : Repeat elements of an array.
broadcast_to : Broadcast an array to a new shape</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 0, 1, 2],</span>
<span class="go">       [0, 1, 2, 0, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[0, 1, 2, 0, 1, 2]],</span>
<span class="go">       [[0, 1, 2, 0, 1, 2]]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 1, 2],</span>
<span class="go">       [3, 4, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">c</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.get_array_wrap">
<code class="descclassname">numpy.</code><code class="descname">get_array_wrap</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_array_wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the wrapper for the array with the highest priority.</p>
<p>In case of ties, leftmost wins. If no wrapper is found, return None</p>
</dd></dl>

<dl class="function">
<dt id="numpy.take_along_axis">
<code class="descclassname">numpy.</code><code class="descname">take_along_axis</code><span class="sig-paren">(</span><em>arr</em>, <em>indices</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.take_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Take values from the input array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to look up values in the
latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <cite>argsort</cite> and
<cite>argpartition</cite>, produce suitable indices for this function.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
<dl class="docutils">
<dt>arr: ndarray (Ni…, M, Nk…)</dt>
<dd>Source array</dd>
<dt>indices: ndarray (Ni…, J, Nk…)</dt>
<dd>Indices to take along each 1d slice of <cite>arr</cite>. This must match the
dimension of arr, but dimensions Ni and Nj only need to broadcast
against <cite>arr</cite>.</dd>
<dt>axis: int</dt>
<dd>The axis to take 1d slices along. If axis is None, the input array is
treated as if it had first been flattened to 1d, for consistency with
<cite>sort</cite> and <cite>argsort</cite>.</dd>
</dl>
<dl class="docutils">
<dt>out: ndarray (Ni…, J, Nk…)</dt>
<dd>The indexed result.</dd>
</dl>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal"><span class="pre">ii</span></code> and <code class="docutils literal"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>  <span class="c1"># Need not equal M</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Nk</span> <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="p">,)</span> <span class="o">+</span> <span class="n">Nk</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">a_1d</span>       <span class="o">=</span> <span class="n">a</span>      <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">indices_1d</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">out_1d</span>     <span class="o">=</span> <span class="n">out</span>    <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="n">out_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, the last two lines would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out_1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">]</span>
</pre></div>
</div>
<p>take : Take along an axis, using the same indices for every 1d slice
put_along_axis :</p>
<blockquote>
<div>Put values into the destination array by matching 1d index and data slices</div></blockquote>
<p>For this sample array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can sort either by using sort directly, or argsort and this function</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">ai</span>
<span class="go">array([[0, 2, 1],</span>
<span class="go">       [1, 2, 0]], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
</pre></div>
</div>
<p>The same works for max and min, if you expand the dimensions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[1],</span>
<span class="go">       [0], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
</pre></div>
</div>
<p>If we want to get the max and min at the same time, we can stack the
indices first</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ai_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ai_min</span><span class="p">,</span> <span class="n">ai_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
<span class="go">&gt;&gt; ai</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 30],</span>
<span class="go">       [40, 60]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.put_along_axis">
<code class="descclassname">numpy.</code><code class="descname">put_along_axis</code><span class="sig-paren">(</span><em>arr</em>, <em>indices</em>, <em>values</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.put_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Put values into the destination array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to place values into the
latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <cite>argsort</cite> and
<cite>argpartition</cite>, produce suitable indices for this function.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
<dl class="docutils">
<dt>arr: ndarray (Ni…, M, Nk…)</dt>
<dd>Destination array.</dd>
<dt>indices: ndarray (Ni…, J, Nk…)</dt>
<dd>Indices to change along each 1d slice of <cite>arr</cite>. This must match the
dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
against <cite>arr</cite>.</dd>
<dt>values: array_like (Ni…, J, Nk…)</dt>
<dd>values to insert at those indices. Its shape and dimension are
broadcast to match that of <cite>indices</cite>.</dd>
<dt>axis: int</dt>
<dd>The axis to take 1d slices along. If axis is None, the destination
array is treated as if a flattened 1d view had been created of it.</dd>
</dl>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal"><span class="pre">ii</span></code> and <code class="docutils literal"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>  <span class="c1"># Need not equal M</span>

<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">a_1d</span>       <span class="o">=</span> <span class="n">a</span>      <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">indices_1d</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">values_1d</span>  <span class="o">=</span> <span class="n">values</span> <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">values_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, the last two lines would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">]</span> <span class="o">=</span> <span class="n">values_1d</span>
</pre></div>
</div>
<dl class="docutils">
<dt>take_along_axis :</dt>
<dd>Take values from the input array by matching 1d index and data slices</dd>
</dl>
<p>For this sample array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can replace the maximum values with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[1],</span>
<span class="go">       [0]], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">put_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10, 99, 20],</span>
<span class="go">       [99, 40, 50]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.broadcast_to">
<code class="descclassname">numpy.</code><code class="descname">broadcast_to</code><span class="sig-paren">(</span><em>array</em>, <em>shape</em>, <em>subok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast an array to a new shape.</p>
<dl class="docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The array to broadcast.</dd>
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>The shape of the desired array.</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then sub-classes will be passed-through, otherwise
the returned array will be forced to be a base-class array (default).</dd>
</dl>
<dl class="docutils">
<dt>broadcast <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>A readonly view on the original array with the given shape. It is
typically not contiguous. Furthermore, more than one element of a
broadcasted array may refer to a single memory location.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If the array is not compatible with the new shape according to NumPy’s
broadcasting rules.</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [1, 2, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.broadcast_arrays">
<code class="descclassname">numpy.</code><code class="descname">broadcast_arrays</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.broadcast_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast any number of arrays against each other.</p>
<dl class="docutils">
<dt><cite>*args</cite> <span class="classifier-delimiter">:</span> <span class="classifier">array_likes</span></dt>
<dd>The arrays to broadcast.</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then sub-classes will be passed-through, otherwise
the returned arrays will be forced to be a base-class array (default).</dd>
</dl>
<dl class="docutils">
<dt>broadcasted <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>These arrays are views on the original arrays.  They are typically
not contiguous.  Furthermore, more than one element of a
broadcasted array may refer to a single memory location.  If you
need to write to the arrays, make copies first.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[1, 1, 1],</span>
<span class="go">       [2, 2, 2],</span>
<span class="go">       [3, 3, 3]])]</span>
</pre></div>
</div>
<p>Here is a useful idiom for getting contiguous copies instead of
non-contiguous views.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
<span class="go">[array([[1, 2, 3],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [1, 2, 3]]), array([[1, 1, 1],</span>
<span class="go">       [2, 2, 2],</span>
<span class="go">       [3, 3, 3]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.diag">
<code class="descclassname">numpy.</code><code class="descname">diag</code><span class="sig-paren">(</span><em>v</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code class="docutils literal"><span class="pre">numpy.diagonal</span></code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<dl class="docutils">
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>If <cite>v</cite> is a 2-D array, return a copy of its <cite>k</cite>-th diagonal.
If <cite>v</cite> is a 1-D array, return a 2-D array with <cite>v</cite> on the <cite>k</cite>-th
diagonal.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal in question. The default is 0. Use <cite>k&gt;0</cite> for diagonals
above the main diagonal, and <cite>k&lt;0</cite> for diagonals below the main
diagonal.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The extracted diagonal or constructed diagonal array.</dd>
</dl>
<p>diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.diagflat">
<code class="descclassname">numpy.</code><code class="descname">diagflat</code><span class="sig-paren">(</span><em>v</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.diagflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a two-dimensional array with the flattened input as a diagonal.</p>
<dl class="docutils">
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data, which is flattened and set as the <cite>k</cite>-th
diagonal of the output.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal to set; 0, the default, corresponds to the “main” diagonal,
a positive (negative) <cite>k</cite> giving the number of the diagonal above
(below) the main.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The 2-D output array.</dd>
</dl>
<p>diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[1, 0, 0, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 0],</span>
<span class="go">       [0, 0, 0, 4]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 1, 0],</span>
<span class="go">       [0, 0, 2],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.eye">
<code class="descclassname">numpy.</code><code class="descname">eye</code><span class="sig-paren">(</span><em>N</em>, <em>M=None</em>, <em>k=0</em>, <em>dtype=&lt;class 'float'&gt;</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of rows in the output.</dd>
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of columns in the output. If None, defaults to <cite>N</cite>.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal, and a negative value
to a lower diagonal.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Data-type of the returned array.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd><p class="first">Whether the output should be stored in row-major (C-style) or
column-major (Fortran-style) order in memory.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>I <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (N,M)</span></dt>
<dd>An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</dd>
</dl>
<p>identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 0],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fliplr">
<code class="descclassname">numpy.</code><code class="descname">fliplr</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the left/right direction.</p>
<p>Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array, must be at least 2-D.</dd>
</dl>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A view of <cite>m</cite> with the columns reversed.  Since a view
is returned, this operation is <span class="math">\(\mathcal O(1)\)</span>.</dd>
</dl>
<p>flipud : Flip array in the up/down direction.
rot90 : Rotate array counterclockwise.</p>
<p>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 3.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.flipud">
<code class="descclassname">numpy.</code><code class="descname">flipud</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the up/down direction.</p>
<p>Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>A view of <cite>m</cite> with the rows reversed.  Since a view is
returned, this operation is <span class="math">\(\mathcal O(1)\)</span>.</dd>
</dl>
<p>fliplr : Flip array in the left/right direction.
rot90 : Rotate array counterclockwise.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">m[::-1,...]</span></code>.
Does not require the array to be two-dimensional.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  3.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([2, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tri">
<code class="descclassname">numpy.</code><code class="descname">tri</code><span class="sig-paren">(</span><em>N</em>, <em>M=None</em>, <em>k=0</em>, <em>dtype=&lt;class 'float'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tri" title="Permalink to this definition">¶</a></dt>
<dd><p>An array with ones at and below the given diagonal and zeros elsewhere.</p>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of rows in the array.</dd>
<dt>M <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of columns in the array.
By default, <cite>M</cite> is taken equal to <cite>N</cite>.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The sub-diagonal at and below which the array is filled.
<cite>k</cite> = 0 is the main diagonal, while <cite>k</cite> &lt; 0 is below it,
and <cite>k</cite> &gt; 0 is above.  The default is 0.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Data type of the returned array.  The default is float.</dd>
</dl>
<dl class="docutils">
<dt>tri <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of shape (N, M)</span></dt>
<dd>Array with its lower triangle filled with ones and zero elsewhere;
in other words <code class="docutils literal"><span class="pre">T[i,j]</span> <span class="pre">==</span> <span class="pre">1</span></code> for <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">j</span> <span class="pre">+</span> <span class="pre">k</span></code>, 0 otherwise.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 0],</span>
<span class="go">       [1, 1, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.triu">
<code class="descclassname">numpy.</code><code class="descname">triu</code><span class="sig-paren">(</span><em>m</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of an array.</p>
<p>Return a copy of a matrix with the elements below the <cite>k</cite>-th diagonal
zeroed.</p>
<p>Please refer to the documentation for <cite>tril</cite> for further details.</p>
<p>tril : lower triangle of an array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4,  5,  6],</span>
<span class="go">       [ 0,  8,  9],</span>
<span class="go">       [ 0,  0, 12]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tril">
<code class="descclassname">numpy.</code><code class="descname">tril</code><span class="sig-paren">(</span><em>m</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of an array.</p>
<p>Return a copy of an array with elements above the <cite>k</cite>-th diagonal zeroed.</p>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (M, N)</span></dt>
<dd>Input array.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal above which to zero elements.  <cite>k = 0</cite> (the default) is the
main diagonal, <cite>k &lt; 0</cite> is below it and <cite>k &gt; 0</cite> is above.</dd>
</dl>
<dl class="docutils">
<dt>tril <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (M, N)</span></dt>
<dd>Lower triangle of <cite>m</cite>, of same shape and data-type as <cite>m</cite>.</dd>
</dl>
<p>triu : same thing, only for the upper triangle</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  0,  0],</span>
<span class="go">       [ 4,  0,  0],</span>
<span class="go">       [ 7,  8,  0],</span>
<span class="go">       [10, 11, 12]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.vander">
<code class="descclassname">numpy.</code><code class="descname">vander</code><span class="sig-paren">(</span><em>x</em>, <em>N=None</em>, <em>increasing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.vander" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Vandermonde matrix.</p>
<p>The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the <cite>increasing</cite> boolean argument.
Specifically, when <cite>increasing</cite> is False, the <cite>i</cite>-th output column is
the input vector raised element-wise to the power of <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">i</span> <span class="pre">-</span> <span class="pre">1</span></code>. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>1-D input array.</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Number of columns in the output.  If <cite>N</cite> is not specified, a square
array is returned (<code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>).</dd>
<dt>increasing <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">Order of the powers of the columns.  If True, the powers increase
from left to right, if False (the default) they are reversed.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Vandermonde matrix.  If <cite>increasing</cite> is False, the first column is
<code class="docutils literal"><span class="pre">x^(N-1)</span></code>, the second <code class="docutils literal"><span class="pre">x^(N-2)</span></code> and so forth. If <cite>increasing</cite> is
True, the columns are <code class="docutils literal"><span class="pre">x^0,</span> <span class="pre">x^1,</span> <span class="pre">...,</span> <span class="pre">x^(N-1)</span></code>.</dd>
</dl>
<p>polynomial.polynomial.polyvander</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="go">array([[ 1,  1,  1],</span>
<span class="go">       [ 4,  2,  1],</span>
<span class="go">       [ 9,  3,  1],</span>
<span class="go">       [25,  5,  1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
<span class="go">array([[ 1,  1,  1],</span>
<span class="go">       [ 4,  2,  1],</span>
<span class="go">       [ 9,  3,  1],</span>
<span class="go">       [25,  5,  1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[  1,   1,   1,   1],</span>
<span class="go">       [  8,   4,   2,   1],</span>
<span class="go">       [ 27,   9,   3,   1],</span>
<span class="go">       [125,  25,   5,   1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[  1,   1,   1,   1],</span>
<span class="go">       [  1,   2,   4,   8],</span>
<span class="go">       [  1,   3,   9,  27],</span>
<span class="go">       [  1,   5,  25, 125]])</span>
</pre></div>
</div>
<p>The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">48.000000000000043</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">48</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.histogram2d">
<code class="descclassname">numpy.</code><code class="descname">histogram2d</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>bins=10</em>, <em>range=None</em>, <em>normed=None</em>, <em>weights=None</em>, <em>density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bi-dimensional histogram of two data samples.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (N,)</span></dt>
<dd>An array containing the x coordinates of the points to be
histogrammed.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (N,)</span></dt>
<dd>An array containing the y coordinates of the points to be
histogrammed.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">int or array_like or [int, int] or [array, array], optional</span></dt>
<dd><p class="first">The bin specification:</p>
<blockquote class="last">
<div><ul class="simple">
<li>If int, the number of bins for the two dimensions (nx=ny=bins).</li>
<li>If array_like, the bin edges for the two dimensions
(x_edges=y_edges=bins).</li>
<li>If [int, int], the number of bins in each dimension
(nx, ny = bins).</li>
<li>If [array, array], the bin edges in each dimension
(x_edges, y_edges = bins).</li>
<li>A combination [int, array] or [array, int], where int
is the number of bins and array is the bin edges.</li>
</ul>
</div></blockquote>
</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape(2,2), optional</span></dt>
<dd>The leftmost and rightmost edges of the bins along each dimension
(if not specified explicitly in the <cite>bins</cite> parameters):
<code class="docutils literal"><span class="pre">[[xmin,</span> <span class="pre">xmax],</span> <span class="pre">[ymin,</span> <span class="pre">ymax]]</span></code>. All values outside of this range
will be considered outliers and not tallied in the histogram.</dd>
<dt>density <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If False, the default, returns the number of samples in each bin.
If True, returns the probability <em>density</em> function at the bin,
<code class="docutils literal"><span class="pre">bin_count</span> <span class="pre">/</span> <span class="pre">sample_count</span> <span class="pre">/</span> <span class="pre">bin_area</span></code>.</dd>
<dt>normed <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>An alias for the density argument that behaves identically. To avoid
confusion with the broken normed argument to <cite>histogram</cite>, <cite>density</cite>
should be preferred.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape(N,), optional</span></dt>
<dd>An array of values <code class="docutils literal"><span class="pre">w_i</span></code> weighing each sample <code class="docutils literal"><span class="pre">(x_i,</span> <span class="pre">y_i)</span></code>.
Weights are normalized to 1 if <cite>normed</cite> is True. If <cite>normed</cite> is
False, the values of the returned histogram are equal to the sum of
the weights belonging to the samples falling into each bin.</dd>
</dl>
<dl class="docutils">
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(nx, ny)</span></dt>
<dd>The bi-dimensional histogram of samples <cite>x</cite> and <cite>y</cite>. Values in <cite>x</cite>
are histogrammed along the first dimension and values in <cite>y</cite> are
histogrammed along the second dimension.</dd>
<dt>xedges <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(nx+1,)</span></dt>
<dd>The bin edges along the first dimension.</dd>
<dt>yedges <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(ny+1,)</span></dt>
<dd>The bin edges along the second dimension.</dd>
</dl>
<p>histogram : 1D histogram
histogramdd : Multidimensional histogram</p>
<p>When <cite>normed</cite> is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
<code class="docutils literal"><span class="pre">bin_value</span> <span class="pre">*</span> <span class="pre">bin_area</span></code> is 1.</p>
<p>Please note that the histogram does not follow the Cartesian convention
where <cite>x</cite> values are on the abscissa and <cite>y</cite> values on the ordinate
axis.  Rather, <cite>x</cite> is histogrammed along the first dimension of the
array (vertical), and <cite>y</cite> along the second dimension of the array
(horizontal).  This ensures compatibility with <cite>histogramdd</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<p>Construct a 2-D histogram with variable bin width. First define the bin
edges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xedges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yedges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Next we create a histogram H with random bin content:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Let each row list bins with common y range.</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">imshow</span></code> can only display square bins:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;imshow: square bins&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">pcolormesh</span></code> can display actual edges:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;pcolormesh: actual edges&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">NonUniformImage</span></code> can be used to
display actual bin edges with interpolation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;NonUniformImage: interpolated&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xedges</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ylim</span><span class="o">=</span><span class="n">yedges</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">NonUniformImage</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;bilinear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xcenters</span> <span class="o">=</span> <span class="p">(</span><span class="n">xedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ycenters</span> <span class="o">=</span> <span class="p">(</span><span class="n">yedges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">yedges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">xcenters</span><span class="p">,</span> <span class="n">ycenters</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.mask_indices">
<code class="descclassname">numpy.</code><code class="descname">mask_indices</code><span class="sig-paren">(</span><em>n</em>, <em>mask_func</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mask_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access (n, n) arrays, given a masking function.</p>
<p>Assume <cite>mask_func</cite> is a function that, for a square array a of size
<code class="docutils literal"><span class="pre">(n,</span> <span class="pre">n)</span></code> with a possible offset argument <cite>k</cite>, when called as
<code class="docutils literal"><span class="pre">mask_func(a,</span> <span class="pre">k)</span></code> returns a new array with zeros in certain locations
(functions like <cite>triu</cite> or <cite>tril</cite> do precisely this). Then this function
returns the indices where the non-zero values would be located.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The returned indices will be valid to access arrays of shape (n, n).</dd>
<dt>mask_func <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>A function whose call signature is similar to that of <cite>triu</cite>, <cite>tril</cite>.
That is, <code class="docutils literal"><span class="pre">mask_func(x,</span> <span class="pre">k)</span></code> returns a boolean array, shaped like <cite>x</cite>.
<cite>k</cite> is an optional argument to the function.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>An optional argument which is passed through to <cite>mask_func</cite>. Functions
like <cite>triu</cite>, <cite>tril</cite> take a second argument that is interpreted as an
offset.</dd>
</dl>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">tuple of arrays.</span></dt>
<dd>The <cite>n</cite> arrays of indices corresponding to the locations where
<code class="docutils literal"><span class="pre">mask_func(np.ones((n,</span> <span class="pre">n)),</span> <span class="pre">k)</span></code> is True.</dd>
</dl>
<p>triu, tril, triu_indices, tril_indices</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<p>These are the indices that would allow you to access the upper triangular
part of any 3x3 array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, if <cite>a</cite> is a 3x3 array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 4, 5, 8])</span>
</pre></div>
</div>
<p>An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>with which we now extract only three elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span>
<span class="go">array([1, 2, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tril_indices">
<code class="descclassname">numpy.</code><code class="descname">tril_indices</code><span class="sig-paren">(</span><em>n</em>, <em>k=0</em>, <em>m=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the lower-triangle of an (n, m) array.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The row dimension of the arrays for which the returned
indices will be valid.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal offset (see <cite>tril</cite> for details).</dd>
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<p class="last">The column dimension of the arrays for which the returned
arrays will be valid.
By default <cite>m</cite> is taken equal to <cite>n</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>inds <span class="classifier-delimiter">:</span> <span class="classifier">tuple of arrays</span></dt>
<dd>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.</dd>
</dl>
<p>triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">il1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span>
<span class="go">array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1,  1,  2,  3],</span>
<span class="go">       [-1, -1,  6,  7],</span>
<span class="go">       [-1, -1, -1, 11],</span>
<span class="go">       [-1, -1, -1, -1]])</span>
</pre></div>
</div>
<p>These cover almost the whole array (two diagonals right of the main one):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-10, -10, -10,   3],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.tril_indices_from">
<code class="descclassname">numpy.</code><code class="descname">tril_indices_from</code><span class="sig-paren">(</span><em>arr</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.tril_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the lower-triangle of arr.</p>
<p>See <cite>tril_indices</cite> for full details.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The indices will be valid for square arrays whose dimensions are
the same as arr.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal offset (see <cite>tril</cite> for details).</dd>
</dl>
<p>tril_indices, tril</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.triu_indices">
<code class="descclassname">numpy.</code><code class="descname">triu_indices</code><span class="sig-paren">(</span><em>n</em>, <em>k=0</em>, <em>m=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the upper-triangle of an (n, m) array.</p>
<dl class="docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The size of the arrays for which the returned indices will
be valid.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal offset (see <cite>triu</cite> for details).</dd>
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><div class="first versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<p class="last">The column dimension of the arrays for which the returned
arrays will be valid.
By default <cite>m</cite> is taken equal to <cite>n</cite>.</p>
</dd>
</dl>
<dl class="docutils">
<dt>inds <span class="classifier-delimiter">:</span> <span class="classifier">tuple, shape(2) of ndarrays, shape(<cite>n</cite>)</span></dt>
<dd>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.  Can be used
to slice a ndarray of shape(<cite>n</cite>, <cite>n</cite>).</dd>
</dl>
<p>tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span>
<span class="go">array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1, -1, -1, -1],</span>
<span class="go">       [ 4, -1, -1, -1],</span>
<span class="go">       [ 8,  9, -1, -1],</span>
<span class="go">       [12, 13, 14, -1]])</span>
</pre></div>
</div>
<p>These cover only a small part of the whole array (two diagonals right
of the main one):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ -1,  -1, -10, -10],</span>
<span class="go">       [  4,  -1,  -1, -10],</span>
<span class="go">       [  8,   9,  -1,  -1],</span>
<span class="go">       [ 12,  13,  14,  -1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.triu_indices_from">
<code class="descclassname">numpy.</code><code class="descname">triu_indices_from</code><span class="sig-paren">(</span><em>arr</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.triu_indices_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the upper-triangle of arr.</p>
<p>See <cite>triu_indices</cite> for full details.</p>
<dl class="docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape(N, N)</span></dt>
<dd>The indices will be valid for square arrays.</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Diagonal offset (see <cite>triu</cite> for details).</dd>
</dl>
<dl class="docutils">
<dt>triu_indices_from <span class="classifier-delimiter">:</span> <span class="classifier">tuple, shape(2) of ndarray, shape(N)</span></dt>
<dd>Indices for the upper-triangle of <cite>arr</cite>.</dd>
</dl>
<p>triu_indices, triu</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fix">
<code class="descclassname">numpy.</code><code class="descname">fix</code><span class="sig-paren">(</span><em>x</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Round to nearest integer towards zero.</p>
<p>Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An array of floats to be rounded</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Output array</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of floats</span></dt>
<dd>The array of rounded numbers</dd>
</dl>
<p>trunc, floor, ceil
around : Round to given number of decimals</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">([</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.9</span><span class="p">])</span>
<span class="go">array([ 2.,  2., -2., -2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isneginf">
<code class="descclassname">numpy.</code><code class="descname">isneginf</code><span class="sig-paren">(</span><em>x</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isneginf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for negative infinity, return result as bool array.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The input array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>A boolean array with the same shape and type as <cite>x</cite> to store the
result.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">A boolean array with the same dimensions as the input.
If second argument is not supplied then a numpy boolean array is
returned with values True where the corresponding element of the
input is negative infinity and values False where the element of
the input is not negative infinity.</p>
<p class="last">If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as
zeros and ones, if the type is boolean then as False and True. The
return value <cite>out</cite> is then a reference to that array.</p>
</dd>
</dl>
<p>isinf, isposinf, isnan, isfinite</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is also supplied when x is a scalar
input, or if first and second arguments have different shapes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">array(True, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array(False, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">PINF</span><span class="p">)</span>
<span class="go">array(False, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([ True, False, False])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([1, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([1, 0, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isposinf">
<code class="descclassname">numpy.</code><code class="descname">isposinf</code><span class="sig-paren">(</span><em>x</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isposinf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for positive infinity, return result as bool array.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The input array.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>A boolean array with the same shape as <cite>x</cite> to store the result.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">A boolean array with the same dimensions as the input.
If second argument is not supplied then a boolean array is returned
with values True where the corresponding element of the input is
positive infinity and values False where the element of the input is
not positive infinity.</p>
<p class="last">If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as zeros
and ones, if the type is boolean then as False and True.
The return value <cite>out</cite> is then a reference to that array.</p>
</dd>
</dl>
<p>isinf, isneginf, isfinite, isnan</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is also supplied when <cite>x</cite> is a
scalar input, or if first and second arguments have different shapes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">PINF</span><span class="p">)</span>
<span class="go">array(True, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array(True, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">array(False, dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([False, False,  True])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([0, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.pad">
<code class="descclassname">numpy.</code><code class="descname">pad</code><span class="sig-paren">(</span><em>array</em>, <em>pad_width</em>, <em>mode</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an array.</p>
<dl class="docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">array_like of rank N</span></dt>
<dd>Input array</dd>
<dt>pad_width <span class="classifier-delimiter">:</span> <span class="classifier">{sequence, array_like, int}</span></dt>
<dd>Number of values padded to the edges of each axis.
((before_1, after_1), … (before_N, after_N)) unique pad widths
for each axis.
((before, after),) yields same before and after pad for each axis.
(pad,) or int is a shortcut for before = after = pad width for all
axes.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">str or function</span></dt>
<dd><p class="first">One of the following string values or a user supplied function.</p>
<dl class="last docutils">
<dt>‘constant’</dt>
<dd>Pads with a constant value.</dd>
<dt>‘edge’</dt>
<dd>Pads with the edge values of array.</dd>
<dt>‘linear_ramp’</dt>
<dd>Pads with the linear ramp between end_value and the
array edge value.</dd>
<dt>‘maximum’</dt>
<dd>Pads with the maximum value of all or part of the
vector along each axis.</dd>
<dt>‘mean’</dt>
<dd>Pads with the mean value of all or part of the
vector along each axis.</dd>
<dt>‘median’</dt>
<dd>Pads with the median value of all or part of the
vector along each axis.</dd>
<dt>‘minimum’</dt>
<dd>Pads with the minimum value of all or part of the
vector along each axis.</dd>
<dt>‘reflect’</dt>
<dd>Pads with the reflection of the vector mirrored on
the first and last values of the vector along each
axis.</dd>
<dt>‘symmetric’</dt>
<dd>Pads with the reflection of the vector mirrored
along the edge of the array.</dd>
<dt>‘wrap’</dt>
<dd>Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the
end values are used to pad the beginning.</dd>
<dt>&lt;function&gt;</dt>
<dd>Padding function, see Notes.</dd>
</dl>
</dd>
<dt>stat_length <span class="classifier-delimiter">:</span> <span class="classifier">sequence or int, optional</span></dt>
<dd><p class="first">Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’.  Number of
values at edge of each axis used to calculate the statistic value.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique statistic
lengths for each axis.</p>
<p>((before, after),) yields same before and after statistic lengths
for each axis.</p>
<p>(stat_length,) or int is a shortcut for before = after = statistic
length for all axes.</p>
<p class="last">Default is <code class="docutils literal"><span class="pre">None</span></code>, to use the entire axis.</p>
</dd>
<dt>constant_values <span class="classifier-delimiter">:</span> <span class="classifier">sequence or int, optional</span></dt>
<dd><p class="first">Used in ‘constant’.  The values to set the padded values for each
axis.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique pad constants
for each axis.</p>
<p>((before, after),) yields same before and after constants for each
axis.</p>
<p>(constant,) or int is a shortcut for before = after = constant for
all axes.</p>
<p class="last">Default is 0.</p>
</dd>
<dt>end_values <span class="classifier-delimiter">:</span> <span class="classifier">sequence or int, optional</span></dt>
<dd><p class="first">Used in ‘linear_ramp’.  The values used for the ending value of the
linear_ramp and that will form the edge of the padded array.</p>
<p>((before_1, after_1), … (before_N, after_N)) unique end values
for each axis.</p>
<p>((before, after),) yields same before and after end values for each
axis.</p>
<p>(constant,) or int is a shortcut for before = after = end value for
all axes.</p>
<p class="last">Default is 0.</p>
</dd>
<dt>reflect_type <span class="classifier-delimiter">:</span> <span class="classifier">{‘even’, ‘odd’}, optional</span></dt>
<dd>Used in ‘reflect’, and ‘symmetric’.  The ‘even’ style is the
default with an unaltered reflection around the edge value.  For
the ‘odd’ style, the extended part of the array is created by
subtracting the reflected values from two times the edge value.</dd>
</dl>
<dl class="docutils">
<dt>pad <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Padded array of rank equal to <cite>array</cite> with shape increased
according to <cite>pad_width</cite>.</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p>For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should return a rank 1 array equal in
length to the vector argument with padded values replaced. It has the
following signature:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">padding_func</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">iaxis_pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><dl class="docutils">
<dt>vector <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A rank 1 array already padded with zeros.  Padded values are
vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].</dd>
<dt>iaxis_pad_width <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>A 2-tuple of ints, iaxis_pad_width[0] represents the number of
values padded at the beginning of vector where
iaxis_pad_width[1] represents the number of values padded at
the end of vector.</dd>
<dt>iaxis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The axis currently being calculated.</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Any keyword arguments the function requires.</dd>
</dl>
</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">,</span> <span class="n">end_values</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;maximum&#39;</span><span class="p">)</span>
<span class="go">array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;median&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [3, 3, 3, 4, 3, 3, 3],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
<span class="go">array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pad_with</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">pad_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;padder&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[:</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">)</span>
<span class="go">array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10,  0,  1,  2, 10, 10],</span>
<span class="go">       [10, 10,  3,  4,  5, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">,</span> <span class="n">padder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100,   0,   1,   2, 100, 100],</span>
<span class="go">       [100, 100,   3,   4,   5, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.poly">
<code class="descclassname">numpy.</code><code class="descname">poly</code><span class="sig-paren">(</span><em>seq_of_zeros</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the coefficients of a polynomial with the given sequence of roots.</p>
<p>Returns the coefficients of the polynomial whose leading coefficient
is one for the given sequence of zeros (multiple roots must be included
in the sequence as many times as their multiplicity; see Examples).
A square matrix (or array, which will be treated as a matrix) can also
be given, in which case the coefficients of the characteristic polynomial
of the matrix are returned.</p>
<dl class="docutils">
<dt>seq_of_zeros <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (N,) or (N, N)</span></dt>
<dd>A sequence of polynomial roots, or a square array or matrix object.</dd>
</dl>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first">1D array of polynomial coefficients from highest to lowest degree:</p>
<p class="last"><code class="docutils literal"><span class="pre">c[0]</span> <span class="pre">*</span> <span class="pre">x**(N)</span> <span class="pre">+</span> <span class="pre">c[1]</span> <span class="pre">*</span> <span class="pre">x**(N-1)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">c[N-1]</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">c[N]</span></code>
where c[0] always equals 1.</p>
</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>If input is the wrong shape (the input must be a 1-D or square
2-D array).</dd>
</dl>
<p>polyval : Compute polynomial values.
roots : Return the roots of a polynomial.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<p>Specifying the roots of a polynomial still leaves one degree of
freedom, typically represented by an undetermined leading
coefficient. <a href="#id97"><span class="problematic" id="id63">[1]_</span></a> In the case of this function, that coefficient -
the first one in the returned array - is always taken as one. (If
for some reason you have one other point, the only automatic way
presently to leverage that information is to use <code class="docutils literal"><span class="pre">polyfit</span></code>.)</p>
<p>The characteristic polynomial, <span class="math">\(p_a(t)\)</span>, of an <cite>n</cite>-by-<cite>n</cite>
matrix <strong>A</strong> is given by</p>
<blockquote>
<div><span class="math">\(p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})\)</span>,</div></blockquote>
<p>where <strong>I</strong> is the <cite>n</cite>-by-<cite>n</cite> identity matrix. <a href="#id98"><span class="problematic" id="id64">[2]_</span></a></p>
<table class="docutils footnote" frame="void" id="id65" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>M. Sullivan and M. Sullivan, III, “Algebra and Trignometry,
Enhanced With Graphing Utilities,” Prentice-Hall, pg. 318, 1996.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id66" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>G. Strang, “Linear Algebra and Its Applications, 2nd Edition,”
Academic Press, pg. 182, 1980.</td></tr>
</tbody>
</table>
<p>Given a sequence of a polynomial’s zeros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># Multiple root example</span>
<span class="go">array([1, 0, 0, 0])</span>
</pre></div>
</div>
<p>The line above represents z**3 + 0*z**2 + 0*z + 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([ 1.  ,  0.  , -0.25,  0.  ])</span>
</pre></div>
</div>
<p>The line above represents z**3 - z/4</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mf">1.</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mf">1.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random</span>
</pre></div>
</div>
<p>Given a square array object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">array([ 1.        ,  0.        ,  0.16666667])</span>
</pre></div>
</div>
<p>Note how in all cases the leading coefficient is always 1.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.roots">
<code class="descclassname">numpy.</code><code class="descname">roots</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the roots of a polynomial with coefficients given in p.</p>
<p>The values in the rank-1 array <cite>p</cite> are coefficients of a polynomial.
If the length of <cite>p</cite> is n+1 then the polynomial is described by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">n</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Rank-1 array of polynomial coefficients.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array containing the roots of the polynomial.</dd>
</dl>
<dl class="docutils">
<dt>ValueError</dt>
<dd>When <cite>p</cite> cannot be converted to a rank-1 array.</dd>
</dl>
<dl class="docutils">
<dt>poly <span class="classifier-delimiter">:</span> <span class="classifier">Find the coefficients of a polynomial with a given sequence</span></dt>
<dd>of roots.</dd>
</dl>
<p>polyval : Compute polynomial values.
polyfit : Least squares polynomial fit.
poly1d : A one-dimensional polynomial class.</p>
<p>The algorithm relies on computing the eigenvalues of the
companion matrix <a href="#id99"><span class="problematic" id="id67">[1]_</span></a>.</p>
<table class="docutils footnote" frame="void" id="id68" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>.  Cambridge, UK:
Cambridge University Press, 1999, pp. 146-7.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coeff</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
<span class="go">array([-0.3125+0.46351241j, -0.3125-0.46351241j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polyint">
<code class="descclassname">numpy.</code><code class="descname">polyint</code><span class="sig-paren">(</span><em>p</em>, <em>m=1</em>, <em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an antiderivative (indefinite integral) of a polynomial.</p>
<p>The returned order <cite>m</cite> antiderivative <cite>P</cite> of polynomial <cite>p</cite> satisfies
<span class="math">\(\frac{d^m}{dx^m}P(x) = p(x)\)</span> and is defined up to <cite>m - 1</cite>
integration constants <cite>k</cite>. The constants determine the low-order
polynomial part</p>
<div class="math">
\[\frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}\]</div>
<p>of <cite>P</cite> so that <span class="math">\(P^{(j)}(0) = k_{m-j-1}\)</span>.</p>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d</span></dt>
<dd>Polynomial to differentiate.
A sequence is interpreted as polynomial coefficients, see <cite>poly1d</cite>.</dd>
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Order of the antiderivative. (Default: 1)</dd>
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">list of <cite>m</cite> scalars or scalar, optional</span></dt>
<dd><p class="first">Integration constants. They are given in the order of integration:
those corresponding to highest-order terms come first.</p>
<p class="last">If <code class="docutils literal"><span class="pre">None</span></code> (default), all constants are assumed to be zero.
If <cite>m = 1</cite>, a single scalar can be given instead of a list.</p>
</dd>
</dl>
<p>polyder : derivative of a polynomial
poly1d.integ : equivalent method</p>
<p>The defining property of the antiderivative:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span>
<span class="go">poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The integration constants default to zero, but can be specified:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span>
<span class="go">poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])</span>
</pre></div>
</div>
<p>Note that 3 = 6 / 2!, and that the constants are given in the order of
integrations. Constant of the highest-order polynomial term comes first:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polyder">
<code class="descclassname">numpy.</code><code class="descname">polyder</code><span class="sig-paren">(</span><em>p</em>, <em>m=1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the derivative of the specified order of a polynomial.</p>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">poly1d or sequence</span></dt>
<dd>Polynomial to differentiate.
A sequence is interpreted as polynomial coefficients, see <cite>poly1d</cite>.</dd>
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Order of differentiation (default: 1)</dd>
</dl>
<dl class="docutils">
<dt>der <span class="classifier-delimiter">:</span> <span class="classifier">poly1d</span></dt>
<dd>A new polynomial representing the derivative.</dd>
</dl>
<p>polyint : Anti-derivative of a polynomial.
poly1d : Class for one-dimensional polynomials.</p>
<p>The derivative of the polynomial <span class="math">\(x^3 + x^2 + x^1 + 1\)</span> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">poly1d([3, 2, 1])</span>
</pre></div>
</div>
<p>which evaluates to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">17.0</span>
</pre></div>
</div>
<p>We can verify this, approximating the derivative with
<code class="docutils literal"><span class="pre">(f(x</span> <span class="pre">+</span> <span class="pre">h)</span> <span class="pre">-</span> <span class="pre">f(x))/h</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="mf">2.</span> <span class="o">+</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">(</span><span class="mf">2.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">0.001</span>
<span class="go">17.007000999997857</span>
</pre></div>
</div>
<p>The fourth-order derivative of a 3rd-order polynomial is zero:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">poly1d([6, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">poly1d([6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">poly1d([ 0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polyadd">
<code class="descclassname">numpy.</code><code class="descname">polyadd</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyadd" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the sum of two polynomials.</p>
<p>Returns the polynomial resulting from the sum of two input polynomials.
Each input must be either a poly1d object or a 1D sequence of polynomial
coefficients, from highest to lowest degree.</p>
<dl class="docutils">
<dt>a1, a2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d object</span></dt>
<dd>Input polynomials.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or poly1d object</span></dt>
<dd>The sum of the inputs. If either input is a poly1d object, then the
output is also a poly1d object. Otherwise, it is a 1D array of
polynomial coefficients from highest to lowest degree.</dd>
</dl>
<p>poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">array([9, 6, 6])</span>
</pre></div>
</div>
<p>Using poly1d objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">1 x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">9 x + 5 x + 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyadd</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
<span class="go">   2</span>
<span class="go">9 x + 6 x + 6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polysub">
<code class="descclassname">numpy.</code><code class="descname">polysub</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polysub" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference (subtraction) of two polynomials.</p>
<p>Given two polynomials <cite>a1</cite> and <cite>a2</cite>, returns <code class="docutils literal"><span class="pre">a1</span> <span class="pre">-</span> <span class="pre">a2</span></code>.
<cite>a1</cite> and <cite>a2</cite> can be either array_like sequences of the polynomials’
coefficients (including coefficients equal to zero), or <cite>poly1d</cite> objects.</p>
<dl class="docutils">
<dt>a1, a2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d</span></dt>
<dd>Minuend and subtrahend polynomials, respectively.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or poly1d</span></dt>
<dd>Array or <cite>poly1d</cite> object of the difference polynomial’s coefficients.</dd>
</dl>
<p>polyval, polydiv, polymul, polyadd</p>
<div class="math">
\[(2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polysub</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="go">array([-1,  0,  2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polymul">
<code class="descclassname">numpy.</code><code class="descname">polymul</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polymul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the product of two polynomials.</p>
<p>Finds the polynomial resulting from the multiplication of the two input
polynomials. Each input must be either a poly1d object or a 1D sequence
of polynomial coefficients, from highest to lowest degree.</p>
<dl class="docutils">
<dt>a1, a2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d object</span></dt>
<dd>Input polynomials.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or poly1d object</span></dt>
<dd>The polynomial resulting from the multiplication of the inputs. If
either inputs is a poly1d object, then the output is also a poly1d
object. Otherwise, it is a 1D array of polynomial coefficients from
highest to lowest degree.</dd>
</dl>
<p>poly1d : A one-dimensional polynomial class.
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,
polyval
convolve : Array convolution. Same output as polymul, but has parameter</p>
<blockquote>
<div>for overlap mode.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 9, 23, 38, 17,  3])</span>
</pre></div>
</div>
<p>Using poly1d objects:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">1 x + 2 x + 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">9 x + 5 x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polymul</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
<span class="go">   4      3      2</span>
<span class="go">9 x + 23 x + 38 x + 17 x + 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polydiv">
<code class="descclassname">numpy.</code><code class="descname">polydiv</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polydiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quotient and remainder of polynomial division.</p>
<p>The input arrays are the coefficients (including any coefficients
equal to zero) of the “numerator” (dividend) and “denominator”
(divisor) polynomials, respectively.</p>
<dl class="docutils">
<dt>u <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d</span></dt>
<dd>Dividend polynomial’s coefficients.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d</span></dt>
<dd>Divisor polynomial’s coefficients.</dd>
</dl>
<dl class="docutils">
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Coefficients, including those equal to zero, of the quotient.</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Coefficients, including those equal to zero, of the remainder.</dd>
</dl>
<p>poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,
polyval</p>
<p>Both <cite>u</cite> and <cite>v</cite> must be 0-d or 1-d (ndim = 0 or 1), but <cite>u.ndim</cite> need
not equal <cite>v.ndim</cite>. In other words, all four possible combinations -
<code class="docutils literal"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>,
<code class="docutils literal"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">u.ndim</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">v.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code> - work.</p>
<div class="math">
\[\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25\]</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polydiv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(array([ 1.5 ,  1.75]), array([ 0.25]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.polyval">
<code class="descclassname">numpy.</code><code class="descname">polyval</code><span class="sig-paren">(</span><em>p</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a polynomial at specific values.</p>
<p>If <cite>p</cite> is of length N, this function returns the value:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">p[0]*x**(N-1)</span> <span class="pre">+</span> <span class="pre">p[1]*x**(N-2)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">p[N-2]*x</span> <span class="pre">+</span> <span class="pre">p[N-1]</span></code></div></blockquote>
<p>If <cite>x</cite> is a sequence, then <cite>p(x)</cite> is returned for each element of <cite>x</cite>.
If <cite>x</cite> is another polynomial then the composite polynomial <cite>p(x(t))</cite>
is returned.</p>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d object</span></dt>
<dd>1D array of polynomial coefficients (including coefficients equal
to zero) from highest degree to the constant term, or an
instance of poly1d.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like or poly1d object</span></dt>
<dd>A number, an array of numbers, or an instance of poly1d, at
which to evaluate <cite>p</cite>.</dd>
</dl>
<dl class="docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or poly1d</span></dt>
<dd>If <cite>x</cite> is a poly1d instance, the result is the composition of the two
polynomials, i.e., <cite>x</cite> is “substituted” in <cite>p</cite> and the simplified
result is returned. In addition, the type of <cite>x</cite> - array_like or
poly1d - governs the type of the output: <cite>x</cite> array_like =&gt; <cite>values</cite>
array_like, <cite>x</cite> a poly1d object =&gt; <cite>values</cite> is also.</dd>
</dl>
<p>poly1d: A polynomial class.</p>
<p>Horner’s scheme <a href="#id100"><span class="problematic" id="id69">[1]_</span></a> is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.</p>
<table class="docutils footnote" frame="void" id="id70" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand
Reinhold Co., 1985, pg. 720.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 * 5**2 + 0 * 5**1 + 1</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([ 76.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([ 76.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.poly1d">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">poly1d</code><span class="sig-paren">(</span><em>c_or_r</em>, <em>r=False</em>, <em>variable=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A one-dimensional polynomial class.</p>
<p>A convenience class, used to encapsulate “natural” operations on
polynomials so that said operations may take on their customary
form in code (see Examples).</p>
<dl class="docutils">
<dt>c_or_r <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The polynomial’s coefficients, in decreasing powers, or if
the value of the second parameter is True, the polynomial’s
roots (values where the polynomial evaluates to 0).  For example,
<code class="docutils literal"><span class="pre">poly1d([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> returns an object that represents
<span class="math">\(x^2 + 2x + 3\)</span>, whereas <code class="docutils literal"><span class="pre">poly1d([1,</span> <span class="pre">2,</span> <span class="pre">3],</span> <span class="pre">True)</span></code> returns
one that represents <span class="math">\((x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6\)</span>.</dd>
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, <cite>c_or_r</cite> specifies the polynomial’s roots; the default
is False.</dd>
<dt>variable <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Changes the variable used when printing <cite>p</cite> from <cite>x</cite> to <cite>variable</cite>
(see Examples).</dd>
</dl>
<p>Construct the polynomial <span class="math">\(x^2 + 2x + 3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="go">   2</span>
<span class="go">1 x + 2 x + 3</span>
</pre></div>
</div>
<p>Evaluate the polynomial at <span class="math">\(x = 0.5\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">4.25</span>
</pre></div>
</div>
<p>Find the roots:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">r</span>
<span class="go">array([-1.+1.41421356j, -1.-1.41421356j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
<span class="go">array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j])</span>
</pre></div>
</div>
<p>These numbers in the previous line represent (0, 0) to machine precision</p>
<p>Show the coefficients:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">c</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Display the order (the leading zero-coefficients are removed):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">order</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Show the coefficient of the k-th power in the polynomial
(which is equivalent to <code class="docutils literal"><span class="pre">p.c[-(i+1)]</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Polynomials can be added, subtracted, multiplied, and divided
(returns quotient and remainder):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">*</span> <span class="n">p</span>
<span class="go">poly1d([ 1,  4, 10, 12,  9])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span>
<span class="go">(poly1d([  1.,   4.,  10.,  12.,   9.]), poly1d([ 4.]))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">asarray(p)</span></code> gives the coefficient array, so polynomials can be
used in all functions that accept arrays:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># square of polynomial</span>
<span class="go">poly1d([ 1,  4, 10, 12,  9])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1"># square of individual coefficients</span>
<span class="go">array([1, 4, 9])</span>
</pre></div>
</div>
<p>The variable used in the string representation of <cite>p</cite> can be modified,
using the <cite>variable</cite> parameter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">   2</span>
<span class="go">1 z + 2 z + 3</span>
</pre></div>
</div>
<p>Construct a polynomial from its roots:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">poly1d([ 1, -3,  2])</span>
</pre></div>
</div>
<p>This is the same polynomial as obtained by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">poly1d([ 1, -3,  2])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="numpy.poly1d.c">
<code class="descname">c</code><a class="headerlink" href="#numpy.poly1d.c" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the polynomial coefficients</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.coef">
<code class="descname">coef</code><a class="headerlink" href="#numpy.poly1d.coef" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the polynomial coefficients</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.coefficients">
<code class="descname">coefficients</code><a class="headerlink" href="#numpy.poly1d.coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the polynomial coefficients</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.coeffs">
<code class="descname">coeffs</code><a class="headerlink" href="#numpy.poly1d.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of the polynomial coefficients</p>
</dd></dl>

<dl class="method">
<dt id="numpy.poly1d.deriv">
<code class="descname">deriv</code><span class="sig-paren">(</span><em>m=1</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d.deriv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a derivative of this polynomial.</p>
<p>Refer to <cite>polyder</cite> for full documentation.</p>
<p>polyder : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="numpy.poly1d.integ">
<code class="descname">integ</code><span class="sig-paren">(</span><em>m=1</em>, <em>k=0</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.poly1d.integ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an antiderivative (indefinite integral) of this polynomial.</p>
<p>Refer to <cite>polyint</cite> for full documentation.</p>
<p>polyint : equivalent function</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.o">
<code class="descname">o</code><a class="headerlink" href="#numpy.poly1d.o" title="Permalink to this definition">¶</a></dt>
<dd><p>The order or degree of the polynomial</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.order">
<code class="descname">order</code><a class="headerlink" href="#numpy.poly1d.order" title="Permalink to this definition">¶</a></dt>
<dd><p>The order or degree of the polynomial</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.r">
<code class="descname">r</code><a class="headerlink" href="#numpy.poly1d.r" title="Permalink to this definition">¶</a></dt>
<dd><p>The roots of the polynomial, where self(x) == 0</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.roots">
<code class="descname">roots</code><a class="headerlink" href="#numpy.poly1d.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>The roots of the polynomial, where self(x) == 0</p>
</dd></dl>

<dl class="attribute">
<dt id="numpy.poly1d.variable">
<code class="descname">variable</code><a class="headerlink" href="#numpy.poly1d.variable" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the polynomial variable</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.polyfit">
<code class="descclassname">numpy.</code><code class="descname">polyfit</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>deg</em>, <em>rcond=None</em>, <em>full=False</em>, <em>w=None</em>, <em>cov=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Least squares polynomial fit.</p>
<p>Fit a polynomial <code class="docutils literal"><span class="pre">p(x)</span> <span class="pre">=</span> <span class="pre">p[0]</span> <span class="pre">*</span> <span class="pre">x**deg</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">p[deg]</span></code> of degree <cite>deg</cite>
to points <cite>(x, y)</cite>. Returns a vector of coefficients <cite>p</cite> that minimises
the squared error.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (M,)</span></dt>
<dd>x-coordinates of the M sample points <code class="docutils literal"><span class="pre">(x[i],</span> <span class="pre">y[i])</span></code>.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (M,) or (M, K)</span></dt>
<dd>y-coordinates of the sample points. Several data sets of sample
points sharing the same x-coordinates can be fitted at once by
passing in a 2D-array that contains one dataset per column.</dd>
<dt>deg <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Degree of the fitting polynomial</dd>
<dt>rcond <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Relative condition number of the fit. Singular values smaller than
this relative to the largest singular value will be ignored. The
default value is len(x)*eps, where eps is the relative precision of
the float type, about 2e-16 in most cases.</dd>
<dt>full <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Switch determining nature of return value. When it is False (the
default) just the coefficients are returned, when True diagnostic
information from the singular value decomposition is also returned.</dd>
<dt>w <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape (M,), optional</span></dt>
<dd>Weights to apply to the y-coordinates of the sample points. For
gaussian uncertainties, use 1/sigma (not 1/sigma**2).</dd>
<dt>cov <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Return the estimate and the covariance matrix of the estimate
If full is True, then cov is not returned.</dd>
</dl>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (deg + 1,) or (deg + 1, K)</span></dt>
<dd>Polynomial coefficients, highest power first.  If <cite>y</cite> was 2-D, the
coefficients for <cite>k</cite>-th data set are in <code class="docutils literal"><span class="pre">p[:,k]</span></code>.</dd>
<dt>residuals, rank, singular_values, rcond</dt>
<dd>Present only if <cite>full</cite> = True.  Residuals of the least-squares fit,
the effective rank of the scaled Vandermonde coefficient matrix,
its singular values, and the specified value of <cite>rcond</cite>. For more
details, see <cite>linalg.lstsq</cite>.</dd>
<dt>V <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (M,M) or (M,M,K)</span></dt>
<dd>Present only if <cite>full</cite> = False and <cite>cov`=True.  The covariance
matrix of the polynomial coefficient estimates.  The diagonal of
this matrix are the variance estimates for each coefficient.  If y
is a 2-D array, then the covariance matrix for the `k</cite>-th data set
are in <code class="docutils literal"><span class="pre">V[:,:,k]</span></code></dd>
</dl>
<dl class="docutils">
<dt>RankWarning</dt>
<dd><p class="first">The rank of the coefficient matrix in the least-squares fit is
deficient. The warning is only raised if <cite>full</cite> = False.</p>
<p>The warnings can be turned off by</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">RankWarning</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>polyval : Compute polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.</p>
<p>The solution minimizes the squared error</p>
<div class="math">
\[E = \sum_{j=0}^k |p(x_j) - y_j|^2\]</div>
<p>in the equations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<p>The coefficient matrix of the coefficients <cite>p</cite> is a Vandermonde matrix.</p>
<p><cite>polyfit</cite> issues a <cite>RankWarning</cite> when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing <cite>x</cite> by <cite>x</cite> - <cite>x</cite>.mean(). The <cite>rcond</cite> parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.</p>
<p>Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.</p>
<table class="docutils footnote" frame="void" id="id71" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Wikipedia, “Curve fitting”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Curve_fitting">http://en.wikipedia.org/wiki/Curve_fitting</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id72" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Wikipedia, “Polynomial interpolation”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Polynomial_interpolation">http://en.wikipedia.org/wiki/Polynomial_interpolation</a></td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>  <span class="mf">4.0</span><span class="p">,</span>  <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])</span>
</pre></div>
</div>
<p>It is convenient to use <cite>poly1d</cite> objects for dealing with polynomials:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">0.6143849206349179</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mf">3.5</span><span class="p">)</span>
<span class="go">-0.34732142857143039</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">22.579365079365115</span>
</pre></div>
</div>
<p>High-order polynomials may oscillate wildly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="go">/... RankWarning: Polyfit may be poorly conditioned...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">-0.80000000000000204</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">-0.99999999999999445</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p30</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span>
<span class="go">-0.10547061179440398</span>
</pre></div>
</div>
<p>Illustration:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">p30</span><span class="p">(</span><span class="n">xp</span><span class="p">),</span> <span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="numpy.RankWarning">
<em class="property">exception </em><code class="descclassname">numpy.</code><code class="descname">RankWarning</code><a class="headerlink" href="#numpy.RankWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">UserWarning</span></code></p>
<p>Issued by <cite>polyfit</cite> when the Vandermonde matrix is rank deficient.</p>
<p>For more information, a way to suppress the warning, and an example of
<cite>RankWarning</cite> being issued, see <cite>polyfit</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.issubclass_">
<code class="descclassname">numpy.</code><code class="descname">issubclass_</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubclass_" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a class is a subclass of a second class.</p>
<p><cite>issubclass_</cite> is equivalent to the Python built-in <code class="docutils literal"><span class="pre">issubclass</span></code>,
except that it returns False instead of raising a TypeError if one
of the arguments is not a class.</p>
<dl class="docutils">
<dt>arg1 <span class="classifier-delimiter">:</span> <span class="classifier">class</span></dt>
<dd>Input class. True is returned if <cite>arg1</cite> is a subclass of <cite>arg2</cite>.</dd>
<dt>arg2 <span class="classifier-delimiter">:</span> <span class="classifier">class or tuple of classes.</span></dt>
<dd>Input class. If a tuple of classes, True is returned if <cite>arg1</cite> is a
subclass of any of the tuple elements.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether <cite>arg1</cite> is a subclass of <cite>arg2</cite> or not.</dd>
</dl>
<p>issubsctype, issubdtype, issctype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubclass_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubclass_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.issubsctype">
<code class="descclassname">numpy.</code><code class="descname">issubsctype</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.issubsctype" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the first argument is a subclass of the second argument.</p>
<dl class="docutils">
<dt>arg1, arg2 <span class="classifier-delimiter">:</span> <span class="classifier">dtype or dtype specifier</span></dt>
<dd>Data-types.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>The result.</dd>
</dl>
<p>issctype, issubdtype,obj2sctype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="s1">&#39;S8&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">issubdtype</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em><span class="sig-paren">)</span></dt>
<dd><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p>
<dl class="docutils">
<dt>arg1, arg2 <span class="classifier-delimiter">:</span> <span class="classifier">dtype_like</span></dt>
<dd>dtype or string representing a typecode.</dd>
</dl>
<p>out : bool</p>
<p>issubsctype, <a href="#id101"><span class="problematic" id="id102">issubclass_</span></a>
numpy.core.numerictypes : Overview of numpy type hierarchy.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.deprecate">
<code class="descclassname">numpy.</code><code class="descname">deprecate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.deprecate" title="Permalink to this definition">¶</a></dt>
<dd><p>Issues a DeprecationWarning, adds warning to <cite>old_name</cite>’s
docstring, rebinds <code class="docutils literal"><span class="pre">old_name.__name__</span></code> and returns the new
function object.</p>
<p>This function may also be used as a decorator.</p>
<dl class="docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>The function to be deprecated.</dd>
<dt>old_name <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The name of the function to be deprecated. Default is None, in
which case the name of <cite>func</cite> is used.</dd>
<dt>new_name <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The new name for the function. Default is None, in which case the
deprecation message is that <cite>old_name</cite> is deprecated. If given, the
deprecation message is that <cite>old_name</cite> is deprecated and <cite>new_name</cite>
should be used instead.</dd>
<dt>message <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Additional explanation of the deprecation.  Displayed in the
docstring after the warning.</dd>
</dl>
<dl class="docutils">
<dt>old_func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>The deprecated function.</dd>
</dl>
<p>Note that <code class="docutils literal"><span class="pre">olduint</span></code> returns a value after printing Deprecation
Warning:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">olduint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">olduint</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">/usr/lib/python2.5/site-packages/numpy/lib/utils.py:114:</span>
<span class="go">DeprecationWarning: uint32 is deprecated</span>
<span class="go">  warnings.warn(str1, DeprecationWarning, stacklevel=2)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.deprecate_with_doc">
<code class="descclassname">numpy.</code><code class="descname">deprecate_with_doc</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.deprecate_with_doc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="numpy.get_include">
<code class="descclassname">numpy.</code><code class="descname">get_include</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.get_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directory that contains the NumPy *.h header files.</p>
<p>Extension modules that need to compile against NumPy should use this
function to locate the appropriate include directory.</p>
<p>When using <code class="docutils literal"><span class="pre">distutils</span></code>, for example in <code class="docutils literal"><span class="pre">setup.py</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">...</span>
<span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;extension_name&#39;</span><span class="p">,</span> <span class="o">...</span>
        <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">get_include</span><span class="p">()])</span>
<span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.info">
<code class="descclassname">numpy.</code><code class="descname">info</code><span class="sig-paren">(</span><em>object=None</em>, <em>maxwidth=76</em>, <em>output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em>, <em>toplevel='numpy'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get help information for a function, class, or module.</p>
<dl class="docutils">
<dt>object <span class="classifier-delimiter">:</span> <span class="classifier">object or str, optional</span></dt>
<dd>Input object or name to get information about. If <cite>object</cite> is a
numpy object, its docstring is given. If it is a string, available
modules are searched for matching objects.  If None, information
about <cite>info</cite> itself is returned.</dd>
<dt>maxwidth <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Printing width.</dd>
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">file like object, optional</span></dt>
<dd>File like object that the output is written to, default is
<code class="docutils literal"><span class="pre">stdout</span></code>.  The object has to be opened in ‘w’ or ‘a’ mode.</dd>
<dt>toplevel <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>Start search at this level.</dd>
</dl>
<p>source, lookfor</p>
<p>When used interactively with an object, <code class="docutils literal"><span class="pre">np.info(obj)</span></code> is equivalent
to <code class="docutils literal"><span class="pre">help(obj)</span></code> on the Python prompt or <code class="docutils literal"><span class="pre">obj?</span></code> on the IPython
prompt.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">)</span> 
<span class="go">   polyval(p, x)</span>
<span class="go">     Evaluate the polynomial p at x.</span>
<span class="go">     ...</span>
</pre></div>
</div>
<p>When using a string for <cite>object</cite> it is possible to get multiple results.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;fft&#39;</span><span class="p">)</span> 
<span class="go">     *** Found in numpy ***</span>
<span class="go">Core FFT routines</span>
<span class="gp">...</span>
<span class="go">     *** Found in numpy.fft ***</span>
<span class="go"> fft(a, n=None, axis=-1)</span>
<span class="gp">...</span>
<span class="go">     *** Repeat reference found in numpy.fft.fftpack ***</span>
<span class="go">     *** Total of 3 references found. ***</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.source">
<code class="descclassname">numpy.</code><code class="descname">source</code><span class="sig-paren">(</span><em>object</em>, <em>output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Print or write to a file the source code for a NumPy object.</p>
<p>The source code is only returned for objects written in Python. Many
functions and classes are defined in C and will therefore not return
useful information.</p>
<dl class="docutils">
<dt>object <span class="classifier-delimiter">:</span> <span class="classifier">numpy object</span></dt>
<dd>Input object. This can be any object (function, class, module,
…).</dd>
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">file object, optional</span></dt>
<dd>If <cite>output</cite> not supplied then source code is printed to screen
(sys.stdout).  File object must be created with either write ‘w’ or
append ‘a’ modes.</dd>
</dl>
<p>lookfor, info</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">)</span>                        
<span class="go">In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py</span>
<span class="go">def interp(x, xp, fp, left=None, right=None):</span>
<span class="go">    &quot;&quot;&quot;.... (full docstring printed)&quot;&quot;&quot;</span>
<span class="go">    if isinstance(x, (float, int, number)):</span>
<span class="go">        return compiled_interp([x], xp, fp, left, right).item()</span>
<span class="go">    else:</span>
<span class="go">        return compiled_interp(x, xp, fp, left, right)</span>
</pre></div>
</div>
<p>The source code is only returned for objects written in Python.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>                         
<span class="go">Not available for this object.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.who">
<code class="descclassname">numpy.</code><code class="descname">who</code><span class="sig-paren">(</span><em>vardict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.who" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the NumPy arrays in the given dictionary.</p>
<p>If there is no dictionary passed in or <cite>vardict</cite> is None then returns
NumPy arrays in the globals() dictionary (all NumPy arrays in the
namespace).</p>
<dl class="docutils">
<dt>vardict <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>A dictionary possibly containing ndarrays.  Default is globals().</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd>Returns ‘None’.</dd>
</dl>
<p>Prints out the name, shape, bytes and type of all of the ndarrays
present in <cite>vardict</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">who</span><span class="p">()</span>
<span class="go">Name            Shape            Bytes            Type</span>
<span class="go">===========================================================</span>
<span class="go">a               10               40               int32</span>
<span class="go">b               20               160              float64</span>
<span class="go">Upper bound on total bytes  =       200</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">),</span> <span class="s1">&#39;txt&#39;</span><span class="p">:</span> <span class="s1">&#39;Some str&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;idx&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">who</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">Name            Shape            Bytes            Type</span>
<span class="go">===========================================================</span>
<span class="go">y               3                24               float64</span>
<span class="go">x               2                16               float64</span>
<span class="go">Upper bound on total bytes  =       40</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.lookfor">
<code class="descclassname">numpy.</code><code class="descname">lookfor</code><span class="sig-paren">(</span><em>what</em>, <em>module=None</em>, <em>import_modules=True</em>, <em>regenerate=False</em>, <em>output=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.lookfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a keyword search on docstrings.</p>
<p>A list of objects that matched the search is displayed,
sorted by relevance. All given keywords need to be found in the
docstring for it to be returned as a result, but the order does
not matter.</p>
<dl class="docutils">
<dt>what <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>String containing words to look for.</dd>
<dt>module <span class="classifier-delimiter">:</span> <span class="classifier">str or list, optional</span></dt>
<dd>Name of module(s) whose docstrings to go through.</dd>
<dt>import_modules <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Whether to import sub-modules in packages. Default is True.</dd>
<dt>regenerate <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Whether to re-generate the docstring cache. Default is False.</dd>
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">file-like, optional</span></dt>
<dd>File-like object to write the output to. If omitted, use a pager.</dd>
</dl>
<p>source, info</p>
<p>Relevance is determined only roughly, by checking if the keywords occur
in the function name, at the start of a docstring, etc.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lookfor</span><span class="p">(</span><span class="s1">&#39;binary representation&#39;</span><span class="p">)</span>
<span class="go">Search results for &#39;binary representation&#39;</span>
<span class="go">------------------------------------------</span>
<span class="go">numpy.binary_repr</span>
<span class="go">    Return the binary representation of the input number as a string.</span>
<span class="go">numpy.core.setup_common.long_double_representation</span>
<span class="go">    Given a binary dump as given by GNU od -b, look for long double</span>
<span class="go">numpy.base_repr</span>
<span class="go">    Return a string representation of a number in the given base system.</span>
<span class="gp">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.byte_bounds">
<code class="descclassname">numpy.</code><code class="descname">byte_bounds</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.byte_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns pointers to the end-points of an array.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Input array. It must conform to the Python-side of the array
interface.</dd>
</dl>
<dl class="docutils">
<dt>(low, high) <span class="classifier-delimiter">:</span> <span class="classifier">tuple of 2 integers</span></dt>
<dd>The first integer is the first byte of the array, the second
integer is just past the last byte of the array.  If <cite>a</cite> is not
contiguous it will not use every byte between the (<cite>low</cite>, <cite>high</cite>)
values.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">);</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte_bounds</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">I</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;G&#39;</span><span class="p">);</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;complex192&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte_bounds</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">I</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.safe_eval">
<code class="descclassname">numpy.</code><code class="descname">safe_eval</code><span class="sig-paren">(</span><em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.safe_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Protected string evaluation.</p>
<p>Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.</p>
<dl class="docutils">
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>The string to evaluate.</dd>
</dl>
<dl class="docutils">
<dt>obj <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>The result of evaluating <cite>source</cite>.</dd>
</dl>
<dl class="docutils">
<dt>SyntaxError</dt>
<dd>If the code has invalid Python syntax, or if it contains
non-literal code.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;[1, 2, 3]&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;{&quot;foo&quot;: (&quot;bar&quot;, 10.0)}&#39;</span><span class="p">)</span>
<span class="go">{&#39;foo&#39;: (&#39;bar&#39;, 10.0)}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;import os&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">safe_eval</span><span class="p">(</span><span class="s1">&#39;open(&quot;/home/user/.ssh/id_dsa&quot;).read()&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">SyntaxError</span>: <span class="n">Unsupported source construct: compiler.ast.CallFunc</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ediff1d">
<code class="descclassname">numpy.</code><code class="descname">ediff1d</code><span class="sig-paren">(</span><em>ary</em>, <em>to_end=None</em>, <em>to_begin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ediff1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The differences between consecutive elements of an array.</p>
<dl class="docutils">
<dt>ary <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>If necessary, will be flattened before the differences are taken.</dd>
<dt>to_end <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Number(s) to append at the end of the returned differences.</dd>
<dt>to_begin <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Number(s) to prepend at the beginning of the returned differences.</dd>
</dl>
<dl class="docutils">
<dt>ediff1d <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The differences. Loosely, this is <code class="docutils literal"><span class="pre">ary.flat[1:]</span> <span class="pre">-</span> <span class="pre">ary.flat[:-1]</span></code>.</dd>
</dl>
<p>diff, gradient</p>
<p>When applied to masked arrays, this function drops the mask information
if the <cite>to_begin</cite> and/or <cite>to_end</cite> parameters are used.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1,  2,  3, -7])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=-</span><span class="mi">99</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">]))</span>
<span class="go">array([-99,   1,   2,   3,  -7,  88,  99])</span>
</pre></div>
</div>
<p>The returned array is always 1D.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 1,  2, -3,  5, 18])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.intersect1d">
<code class="descclassname">numpy.</code><code class="descname">intersect1d</code><span class="sig-paren">(</span><em>ar1</em>, <em>ar2</em>, <em>assume_unique=False</em>, <em>return_indices=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.intersect1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the intersection of two arrays.</p>
<p>Return the sorted, unique values that are in both of the input arrays.</p>
<dl class="docutils">
<dt>ar1, ar2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays. Will be flattened if not already 1D.</dd>
<dt>assume_unique <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</dd>
<dt>return_indices <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, the indices which correspond to the intersection of the two
arrays are returned. The first instance of a value is used if there are
multiple. Default is False.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.15.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>intersect1d <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sorted 1D array of common and unique elements.</dd>
<dt>comm1 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The indices of the first occurrences of the common values in <cite>ar1</cite>.
Only provided if <cite>return_indices</cite> is True.</dd>
<dt>comm2 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The indices of the first occurrences of the common values in <cite>ar2</cite>.
Only provided if <cite>return_indices</cite> is True.</dd>
</dl>
<dl class="docutils">
<dt>numpy.lib.arraysetops <span class="classifier-delimiter">:</span> <span class="classifier">Module with a number of other functions for</span></dt>
<dd>performing set operations on arrays.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<p>To intersect more than two arrays, use functools.reduce:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">,</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">array([3])</span>
</pre></div>
</div>
<p>To return the indices of the values common to the input arrays
along with the intersected values:
&gt;&gt;&gt; x = np.array([1, 1, 2, 3, 4])
&gt;&gt;&gt; y = np.array([2, 1, 4, 6])
&gt;&gt;&gt; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
&gt;&gt;&gt; x_ind, y_ind
(array([0, 2, 4]), array([1, 0, 2]))
&gt;&gt;&gt; xy, x[x_ind], y[y_ind]
(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))</p>
</dd></dl>

<dl class="function">
<dt id="numpy.setxor1d">
<code class="descclassname">numpy.</code><code class="descname">setxor1d</code><span class="sig-paren">(</span><em>ar1</em>, <em>ar2</em>, <em>assume_unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setxor1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the set exclusive-or of two arrays.</p>
<p>Return the sorted, unique values that are in only one (not both) of the
input arrays.</p>
<dl class="docutils">
<dt>ar1, ar2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays.</dd>
<dt>assume_unique <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</dd>
</dl>
<dl class="docutils">
<dt>setxor1d <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sorted 1D array of unique values that are in only one of the input
arrays.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">setxor1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 4, 5, 7])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.union1d">
<code class="descclassname">numpy.</code><code class="descname">union1d</code><span class="sig-paren">(</span><em>ar1</em>, <em>ar2</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.union1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the union of two arrays.</p>
<p>Return the unique, sorted array of values that are in either of the two
input arrays.</p>
<dl class="docutils">
<dt>ar1, ar2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input arrays. They are flattened if they are not already 1D.</dd>
</dl>
<dl class="docutils">
<dt>union1d <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Unique, sorted union of the input arrays.</dd>
</dl>
<dl class="docutils">
<dt>numpy.lib.arraysetops <span class="classifier-delimiter">:</span> <span class="classifier">Module with a number of other functions for</span></dt>
<dd>performing set operations on arrays.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([-2, -1,  0,  1,  2])</span>
</pre></div>
</div>
<p>To find the union of more than two arrays, use functools.reduce:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">,</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.setdiff1d">
<code class="descclassname">numpy.</code><code class="descname">setdiff1d</code><span class="sig-paren">(</span><em>ar1</em>, <em>ar2</em>, <em>assume_unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.setdiff1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the set difference of two arrays.</p>
<p>Return the sorted, unique values in <cite>ar1</cite> that are not in <cite>ar2</cite>.</p>
<dl class="docutils">
<dt>ar1 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>ar2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input comparison array.</dd>
<dt>assume_unique <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</dd>
</dl>
<dl class="docutils">
<dt>setdiff1d <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Sorted 1D array of values in <cite>ar1</cite> that are not in <cite>ar2</cite>.</dd>
</dl>
<dl class="docutils">
<dt>numpy.lib.arraysetops <span class="classifier-delimiter">:</span> <span class="classifier">Module with a number of other functions for</span></dt>
<dd>performing set operations on arrays.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.unique">
<code class="descclassname">numpy.</code><code class="descname">unique</code><span class="sig-paren">(</span><em>ar</em>, <em>return_index=False</em>, <em>return_inverse=False</em>, <em>return_counts=False</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the unique elements of an array.</p>
<p>Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:</p>
<ul class="simple">
<li>the indices of the input array that give the unique values</li>
<li>the indices of the unique array that reconstruct the input array</li>
<li>the number of times each unique value comes up in the input array</li>
</ul>
<dl class="docutils">
<dt>ar <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array. Unless <cite>axis</cite> is specified, this will be flattened if it
is not already 1-D.</dd>
<dt>return_index <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, also return the indices of <cite>ar</cite> (along the specified axis,
if provided, or in the flattened array) that result in the unique array.</dd>
<dt>return_inverse <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, also return the indices of the unique array (for the specified
axis, if provided) that can be used to reconstruct <cite>ar</cite>.</dd>
<dt>return_counts <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True, also return the number of times each unique item appears
in <cite>ar</cite>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd><p class="first">The axis to operate on. If None, <cite>ar</cite> will be flattened. If an integer,
the subarrays indexed by the given axis will be flattened and treated
as the elements of a 1-D array with the dimension of the given axis,
see the notes for more details.  Object arrays or structured arrays
that contain objects are not supported if the <cite>axis</cite> kwarg is used. The
default is None.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.13.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>unique <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The sorted unique values.</dd>
<dt>unique_indices <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>The indices of the first occurrences of the unique values in the
original array. Only provided if <cite>return_index</cite> is True.</dd>
<dt>unique_inverse <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>The indices to reconstruct the original array from the
unique array. Only provided if <cite>return_inverse</cite> is True.</dd>
<dt>unique_counts <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first">The number of times each of the unique values comes up in the
original array. Only provided if <cite>return_counts</cite> is True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>numpy.lib.arraysetops <span class="classifier-delimiter">:</span> <span class="classifier">Module with a number of other functions for</span></dt>
<dd>performing set operations on arrays.</dd>
</dl>
<p>When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>Return the unique rows of a 2D array</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 0, 0], [2, 3, 4]])</span>
</pre></div>
</div>
<p>Return the indices of the original array that give the unique values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="go">       dtype=&#39;|S1&#39;)</span>
</pre></div>
</div>
<p>Reconstruct the input array from the unique values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">array([1, 2, 3, 4, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([0, 1, 4, 3, 1, 2, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([1, 2, 6, 4, 2, 3, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.in1d">
<code class="descclassname">numpy.</code><code class="descname">in1d</code><span class="sig-paren">(</span><em>ar1</em>, <em>ar2</em>, <em>assume_unique=False</em>, <em>invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.in1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether each element of a 1-D array is also present in a second array.</p>
<p>Returns a boolean array the same length as <cite>ar1</cite> that is True
where an element of <cite>ar1</cite> is in <cite>ar2</cite> and False otherwise.</p>
<p>We recommend using <a class="reference internal" href="#numpy.isin" title="numpy.isin"><code class="xref py py-func docutils literal"><span class="pre">isin()</span></code></a> instead of <cite>in1d</cite> for new code.</p>
<dl class="docutils">
<dt>ar1 <span class="classifier-delimiter">:</span> <span class="classifier">(M,) array_like</span></dt>
<dd>Input array.</dd>
<dt>ar2 <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The values against which to test each value of <cite>ar1</cite>.</dd>
<dt>assume_unique <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</dd>
<dt>invert <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If True, the values in the returned array are inverted (that is,
False where an element of <cite>ar1</cite> is in <cite>ar2</cite> and True otherwise).
Default is False. <code class="docutils literal"><span class="pre">np.in1d(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent
to (but is faster than) <code class="docutils literal"><span class="pre">np.invert(in1d(a,</span> <span class="pre">b))</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>in1d <span class="classifier-delimiter">:</span> <span class="classifier">(M,) ndarray, bool</span></dt>
<dd>The values <cite>ar1[in1d]</cite> are in <cite>ar2</cite>.</dd>
</dl>
<dl class="docutils">
<dt>isin <span class="classifier-delimiter">:</span> <span class="classifier">Version of this function that preserves the</span></dt>
<dd>shape of ar1.</dd>
<dt>numpy.lib.arraysetops <span class="classifier-delimiter">:</span> <span class="classifier">Module with a number of other functions for</span></dt>
<dd>performing set operations on arrays.</dd>
</dl>
<p><cite>in1d</cite> can be considered as an element-wise function version of the
python keyword <cite>in</cite>, for 1-D sequences. <code class="docutils literal"><span class="pre">in1d(a,</span> <span class="pre">b)</span></code> is roughly
equivalent to <code class="docutils literal"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code>.
However, this idea fails if <cite>ar2</cite> is a set, or similar (non-sequence)
container:  As <code class="docutils literal"><span class="pre">ar2</span></code> is converted to an array, in those cases
<code class="docutils literal"><span class="pre">asarray(ar2)</span></code> is an object array rather than the expected array of
contained values.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.4.0.</span></p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([ True, False,  True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 2, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([False,  True, False,  True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.isin">
<code class="descclassname">numpy.</code><code class="descname">isin</code><span class="sig-paren">(</span><em>element</em>, <em>test_elements</em>, <em>assume_unique=False</em>, <em>invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>element in test_elements</cite>, broadcasting over <cite>element</cite> only.
Returns a boolean array of the same shape as <cite>element</cite> that is True
where an element of <cite>element</cite> is in <cite>test_elements</cite> and False otherwise.</p>
<dl class="docutils">
<dt>element <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>test_elements <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>The values against which to test each value of <cite>element</cite>.
This argument is flattened if it is an array or array_like.
See notes for behavior with non-array-like parameters.</dd>
<dt>assume_unique <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the input arrays are both assumed to be unique, which
can speed up the calculation.  Default is False.</dd>
<dt>invert <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the values in the returned array are inverted, as if
calculating <cite>element not in test_elements</cite>. Default is False.
<code class="docutils literal"><span class="pre">np.isin(a,</span> <span class="pre">b,</span> <span class="pre">invert=True)</span></code> is equivalent to (but faster
than) <code class="docutils literal"><span class="pre">np.invert(np.isin(a,</span> <span class="pre">b))</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>isin <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, bool</span></dt>
<dd>Has the same shape as <cite>element</cite>. The values <cite>element[isin]</cite>
are in <cite>test_elements</cite>.</dd>
</dl>
<p>in1d                  : Flattened version of this function.
numpy.lib.arraysetops : Module with a number of other functions for</p>
<blockquote>
<div>performing set operations on arrays.</div></blockquote>
<p><cite>isin</cite> is an element-wise function version of the python keyword <cite>in</cite>.
<code class="docutils literal"><span class="pre">isin(a,</span> <span class="pre">b)</span></code> is roughly equivalent to
<code class="docutils literal"><span class="pre">np.array([item</span> <span class="pre">in</span> <span class="pre">b</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">a])</span></code> if <cite>a</cite> and <cite>b</cite> are 1-D sequences.</p>
<p><cite>element</cite> and <cite>test_elements</cite> are converted to arrays if they are not
already. If <cite>test_elements</cite> is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in <cite>test_elements</cite>. This is a consequence
of the <cite>array</cite> constructor’s way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.13.0.</span></p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[ False,  True],</span>
<span class="go">       [ True,  False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([2, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_elements</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span>
<span class="go">array([[ True, False],</span>
<span class="go">       [ False, True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([0, 6])</span>
</pre></div>
</div>
<p>Because of how <cite>array</cite> handles sets, the following does not
work as expected:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">test_set</span><span class="p">)</span>
<span class="go">array([[ False, False],</span>
<span class="go">       [ False, False]])</span>
</pre></div>
</div>
<p>Casting the set to a list gives the expected result:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">test_set</span><span class="p">))</span>
<span class="go">array([[ False,  True],</span>
<span class="go">       [ True,  False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.savetxt">
<code class="descclassname">numpy.</code><code class="descname">savetxt</code><span class="sig-paren">(</span><em>fname</em>, <em>X</em>, <em>fmt='%.18e'</em>, <em>delimiter=' '</em>, <em>newline='\n'</em>, <em>header=''</em>, <em>footer=''</em>, <em>comments='# '</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savetxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an array to a text file.</p>
<dl class="docutils">
<dt>fname <span class="classifier-delimiter">:</span> <span class="classifier">filename or file handle</span></dt>
<dd>If the filename ends in <code class="docutils literal"><span class="pre">.gz</span></code>, the file is automatically saved in
compressed gzip format.  <cite>loadtxt</cite> understands gzipped files
transparently.</dd>
<dt>X <span class="classifier-delimiter">:</span> <span class="classifier">1D or 2D array_like</span></dt>
<dd>Data to be saved to a text file.</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">str or sequence of strs, optional</span></dt>
<dd><p class="first">A single format (%10.5f), a sequence of formats, or a
multi-format string, e.g. ‘Iteration %d – %10.5f’, in which
case <cite>delimiter</cite> is ignored. For complex <cite>X</cite>, the legal options
for <cite>fmt</cite> are:</p>
<ul class="last simple">
<li>a single specifier, <cite>fmt=’%.4e’</cite>, resulting in numbers formatted
like <cite>‘ (%s+%sj)’ % (fmt, fmt)</cite></li>
<li>a full string specifying every real and imaginary part, e.g.
<cite>‘ %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej’</cite> for 3 columns</li>
<li>a list of specifiers, one per column - in this case, the real
and imaginary part must have separate specifiers,
e.g. <cite>[‘%.3e + %.3ej’, ‘(%.15e%+.15ej)’]</cite> for 2 columns</li>
</ul>
</dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>String or character separating columns.</dd>
<dt>newline <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">String or character separating lines.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.5.0.</span></p>
</div>
</dd>
<dt>header <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">String that will be written at the beginning of the file.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>footer <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">String that will be written at the end of the file.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>comments <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">String that will be prepended to the <code class="docutils literal"><span class="pre">header</span></code> and <code class="docutils literal"><span class="pre">footer</span></code> strings,
to mark them as comments. Default: ‘# ‘,  as expected by e.g.
<code class="docutils literal"><span class="pre">numpy.loadtxt</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">{None, str}, optional</span></dt>
<dd><p class="first">Encoding used to encode the outputfile. Does not apply to output
streams. If the encoding is something other than ‘bytes’ or ‘latin1’
you will not be able to load the file in NumPy versions &lt; 1.14. Default
is ‘latin1’.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<p>save : Save an array to a binary file in NumPy <code class="docutils literal"><span class="pre">.npy</span></code> format
savez : Save several arrays into an uncompressed <code class="docutils literal"><span class="pre">.npz</span></code> archive
savez_compressed : Save several arrays into a compressed <code class="docutils literal"><span class="pre">.npz</span></code> archive</p>
<p>Further explanation of the <cite>fmt</cite> parameter
(<code class="docutils literal"><span class="pre">%[flag]width[.precision]specifier</span></code>):</p>
<dl class="docutils">
<dt>flags:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">-</span></code> : left justify</p>
<p><code class="docutils literal"><span class="pre">+</span></code> : Forces to precede result with + or -.</p>
<p class="last"><code class="docutils literal"><span class="pre">0</span></code> : Left pad the number with zeros instead of space (see width).</p>
</dd>
<dt>width:</dt>
<dd>Minimum number of characters to be printed. The value is not truncated
if it has more characters.</dd>
<dt>precision:</dt>
<dd><ul class="first last simple">
<li>For integer specifiers (eg. <code class="docutils literal"><span class="pre">d,i,o,x</span></code>), the minimum number of
digits.</li>
<li>For <code class="docutils literal"><span class="pre">e,</span> <span class="pre">E</span></code> and <code class="docutils literal"><span class="pre">f</span></code> specifiers, the number of digits to print
after the decimal point.</li>
<li>For <code class="docutils literal"><span class="pre">g</span></code> and <code class="docutils literal"><span class="pre">G</span></code>, the maximum number of significant digits.</li>
<li>For <code class="docutils literal"><span class="pre">s</span></code>, the maximum number of characters.</li>
</ul>
</dd>
<dt>specifiers:</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">c</span></code> : character</p>
<p><code class="docutils literal"><span class="pre">d</span></code> or <code class="docutils literal"><span class="pre">i</span></code> : signed decimal integer</p>
<p><code class="docutils literal"><span class="pre">e</span></code> or <code class="docutils literal"><span class="pre">E</span></code> : scientific notation with <code class="docutils literal"><span class="pre">e</span></code> or <code class="docutils literal"><span class="pre">E</span></code>.</p>
<p><code class="docutils literal"><span class="pre">f</span></code> : decimal floating point</p>
<p><code class="docutils literal"><span class="pre">g,G</span></code> : use the shorter of <code class="docutils literal"><span class="pre">e,E</span></code> or <code class="docutils literal"><span class="pre">f</span></code></p>
<p><code class="docutils literal"><span class="pre">o</span></code> : signed octal</p>
<p><code class="docutils literal"><span class="pre">s</span></code> : string of characters</p>
<p><code class="docutils literal"><span class="pre">u</span></code> : unsigned decimal integer</p>
<p class="last"><code class="docutils literal"><span class="pre">x,X</span></code> : unsigned hexadecimal integer</p>
</dd>
</dl>
<p>This explanation of <code class="docutils literal"><span class="pre">fmt</span></code> is not complete, for an exhaustive
specification see <a href="#id103"><span class="problematic" id="id73">[1]_</span></a>.</p>
<table class="docutils footnote" frame="void" id="id74" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="http://docs.python.org/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a>, Python Documentation.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>   <span class="c1"># X is an array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>   <span class="c1"># x,y,z equal sized 1D arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;test.out&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.4e</span><span class="s1">&#39;</span><span class="p">)</span>   <span class="c1"># use exponential notation</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.loadtxt">
<code class="descclassname">numpy.</code><code class="descname">loadtxt</code><span class="sig-paren">(</span><em>fname</em>, <em>dtype=&lt;class 'float'&gt;</em>, <em>comments='#'</em>, <em>delimiter=None</em>, <em>converters=None</em>, <em>skiprows=0</em>, <em>usecols=None</em>, <em>unpack=False</em>, <em>ndmin=0</em>, <em>encoding='bytes'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.loadtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from a text file.</p>
<p>Each row in the text file must have the same number of values.</p>
<dl class="docutils">
<dt>fname <span class="classifier-delimiter">:</span> <span class="classifier">file, str, or pathlib.Path</span></dt>
<dd>File, filename, or generator to read.  If the filename extension is
<code class="docutils literal"><span class="pre">.gz</span></code> or <code class="docutils literal"><span class="pre">.bz2</span></code>, the file is first decompressed. Note that
generators should return byte strings for Python 3k.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Data-type of the resulting array; default: float.  If this is a
structured data-type, the resulting array will be 1-dimensional, and
each row will be interpreted as an element of the array.  In this
case, the number of columns used must match the number of fields in
the data-type.</dd>
<dt>comments <span class="classifier-delimiter">:</span> <span class="classifier">str or sequence of str, optional</span></dt>
<dd>The characters or list of characters used to indicate the start of a
comment. None implies no comments. For backwards compatibility, byte
strings will be decoded as ‘latin1’. The default is ‘#’.</dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The string used to separate values. For backwards compatibility, byte
strings will be decoded as ‘latin1’. The default is whitespace.</dd>
<dt>converters <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>A dictionary mapping column number to a function that will parse the
column string into the desired value.  E.g., if column 0 is a date
string: <code class="docutils literal"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{0:</span> <span class="pre">datestr2num}</span></code>.  Converters can also be
used to provide a default value for missing data (but see also
<cite>genfromtxt</cite>): <code class="docutils literal"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{3:</span> <span class="pre">lambda</span> <span class="pre">s:</span> <span class="pre">float(s.strip()</span> <span class="pre">or</span> <span class="pre">0)}</span></code>.
Default: None.</dd>
<dt>skiprows <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Skip the first <cite>skiprows</cite> lines; default: 0.</dd>
<dt>usecols <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence, optional</span></dt>
<dd><p class="first">Which columns to read, with 0 being the first. For example,
<code class="docutils literal"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(1,4,5)</span></code> will extract the 2nd, 5th and 6th columns.
The default, None, results in all columns being read.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.11.0: </span>When a single column has to be read it is possible to use
an integer instead of a tuple. E.g <code class="docutils literal"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">3</span></code> reads the
fourth column the same way as <code class="docutils literal"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(3,)</span></code> would.</p>
</div>
</dd>
<dt>unpack <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the returned array is transposed, so that arguments may be
unpacked using <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">loadtxt(...)</span></code>.  When used with a structured
data-type, arrays are returned for each field.  Default is False.</dd>
<dt>ndmin <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">The returned array will have at least <cite>ndmin</cite> dimensions.
Otherwise mono-dimensional axes will be squeezed.
Legal values: 0 (default), 1 or 2.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.6.0.</span></p>
</div>
</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Encoding used to decode the inputfile. Does not apply to input streams.
The special value ‘bytes’ enables backward compatibility workarounds
that ensures you receive byte arrays as results if possible and passes
‘latin1’ encoded strings to converters. Override this value to receive
unicode arrays and pass strings as input to converters.  If set to None
the system default is used. The default value is ‘bytes’.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Data read from the text file.</dd>
</dl>
<p>load, fromstring, fromregex
genfromtxt : Load data with missing values handled as specified.
scipy.io.loadmat : reads MATLAB data files</p>
<p>This function aims to be a fast reader for simply formatted files.  The
<cite>genfromtxt</cite> function provides more sophisticated handling of, e.g.,
lines with missing values.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<p>The strings produced by the Python float.hex method can be used as
input for floats.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>   <span class="c1"># StringIO behaves like a file object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;0 1</span><span class="se">\n</span><span class="s2">2 3&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 2.,  3.]])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;M 21 72</span><span class="se">\n</span><span class="s2">F 35 58&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="s1">&#39;formats&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;S1&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">,</span> <span class="s1">&#39;f4&#39;</span><span class="p">)})</span>
<span class="go">array([(&#39;M&#39;, 21, 72.0), (&#39;F&#39;, 35, 58.0)],</span>
<span class="go">      dtype=[(&#39;gender&#39;, &#39;|S1&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f4&#39;)])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;1,0,2</span><span class="se">\n</span><span class="s2">3,0,4&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 2.,  4.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.genfromtxt">
<code class="descclassname">numpy.</code><code class="descname">genfromtxt</code><span class="sig-paren">(</span><em>fname</em>, <em>dtype=&lt;class 'float'&gt;</em>, <em>comments='#'</em>, <em>delimiter=None</em>, <em>skip_header=0</em>, <em>skip_footer=0</em>, <em>converters=None</em>, <em>missing_values=None</em>, <em>filling_values=None</em>, <em>usecols=None</em>, <em>names=None</em>, <em>excludelist=None</em>, <em>deletechars=None</em>, <em>replace_space='_'</em>, <em>autostrip=False</em>, <em>case_sensitive=True</em>, <em>defaultfmt='f%i'</em>, <em>unpack=None</em>, <em>usemask=False</em>, <em>loose=True</em>, <em>invalid_raise=True</em>, <em>max_rows=None</em>, <em>encoding='bytes'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.genfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data from a text file, with missing values handled as specified.</p>
<p>Each line past the first <cite>skip_header</cite> lines is split at the <cite>delimiter</cite>
character, and characters following the <cite>comments</cite> character are discarded.</p>
<dl class="docutils">
<dt>fname <span class="classifier-delimiter">:</span> <span class="classifier">file, str, pathlib.Path, list of str, generator</span></dt>
<dd>File, filename, list, or generator to read.  If the filename
extension is <cite>.gz</cite> or <cite>.bz2</cite>, the file is first decompressed. Note
that generators must return byte strings in Python 3k.  The strings
in a list or produced by a generator are treated as lines.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Data type of the resulting array.
If None, the dtypes will be determined by the contents of each
column, individually.</dd>
<dt>comments <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>The character used to indicate the start of a comment.
All the characters occurring on a line after a comment are discarded</dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str, int, or sequence, optional</span></dt>
<dd>The string used to separate values.  By default, any consecutive
whitespaces act as delimiter.  An integer or sequence of integers
can also be provided as width(s) of each field.</dd>
<dt>skiprows <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><cite>skiprows</cite> was removed in numpy 1.10. Please use <cite>skip_header</cite> instead.</dd>
<dt>skip_header <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of lines to skip at the beginning of the file.</dd>
<dt>skip_footer <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of lines to skip at the end of the file.</dd>
<dt>converters <span class="classifier-delimiter">:</span> <span class="classifier">variable, optional</span></dt>
<dd>The set of functions that convert the data of a column to a value.
The converters can also be used to provide a default value
for missing data: <code class="docutils literal"><span class="pre">converters</span> <span class="pre">=</span> <span class="pre">{3:</span> <span class="pre">lambda</span> <span class="pre">s:</span> <span class="pre">float(s</span> <span class="pre">or</span> <span class="pre">0)}</span></code>.</dd>
<dt>missing <span class="classifier-delimiter">:</span> <span class="classifier">variable, optional</span></dt>
<dd><cite>missing</cite> was removed in numpy 1.10. Please use <cite>missing_values</cite>
instead.</dd>
<dt>missing_values <span class="classifier-delimiter">:</span> <span class="classifier">variable, optional</span></dt>
<dd>The set of strings corresponding to missing data.</dd>
<dt>filling_values <span class="classifier-delimiter">:</span> <span class="classifier">variable, optional</span></dt>
<dd>The set of values to be used as default when the data are missing.</dd>
<dt>usecols <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd>Which columns to read, with 0 being the first.  For example,
<code class="docutils literal"><span class="pre">usecols</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">5)</span></code> will extract the 2nd, 5th and 6th columns.</dd>
<dt>names <span class="classifier-delimiter">:</span> <span class="classifier">{None, True, str, sequence}, optional</span></dt>
<dd>If <cite>names</cite> is True, the field names are read from the first line after
the first <cite>skip_header</cite> lines.  This line can optionally be proceeded
by a comment delimiter. If <cite>names</cite> is a sequence or a single-string of
comma-separated names, the names will be used to define the field names
in a structured dtype. If <cite>names</cite> is None, the names of the dtype
fields will be used, if any.</dd>
<dt>excludelist <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd>A list of names to exclude. This list is appended to the default list
[‘return’,’file’,’print’]. Excluded names are appended an underscore:
for example, <cite>file</cite> would become <cite>file_</cite>.</dd>
<dt>deletechars <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>A string combining invalid characters that must be deleted from the
names.</dd>
<dt>defaultfmt <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>A format used to define default field names, such as “f%i” or “f_%02i”.</dd>
<dt>autostrip <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Whether to automatically strip white spaces from the variables.</dd>
<dt>replace_space <span class="classifier-delimiter">:</span> <span class="classifier">char, optional</span></dt>
<dd>Character(s) used in replacement of white spaces in the variables
names. By default, use a ‘_’.</dd>
<dt>case_sensitive <span class="classifier-delimiter">:</span> <span class="classifier">{True, False, ‘upper’, ‘lower’}, optional</span></dt>
<dd>If True, field names are case sensitive.
If False or ‘upper’, field names are converted to upper case.
If ‘lower’, field names are converted to lower case.</dd>
<dt>unpack <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the returned array is transposed, so that arguments may be
unpacked using <code class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">loadtxt(...)</span></code></dd>
<dt>usemask <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, return a masked array.
If False, return a regular array.</dd>
<dt>loose <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, do not raise errors for invalid values.</dd>
<dt>invalid_raise <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, an exception is raised if an inconsistency is detected in the
number of columns.
If False, a warning is emitted and the offending lines are skipped.</dd>
<dt>max_rows <span class="classifier-delimiter">:</span> <span class="classifier">int,  optional</span></dt>
<dd><p class="first">The maximum number of rows to read. Must not be used with skip_footer
at the same time.  If given, the value must be at least 1. Default is
to read the entire file.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Encoding used to decode the inputfile. Does not apply when <cite>fname</cite> is
a file object.  The special value ‘bytes’ enables backward compatibility
workarounds that ensure that you receive byte arrays when possible
and passes latin1 encoded strings to converters. Override this value to
receive unicode arrays and pass strings as input to converters.  If set
to None the system default is used. The default value is ‘bytes’.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Data read from the text file. If <cite>usemask</cite> is True, this is a
masked array.</dd>
</dl>
<p>numpy.loadtxt : equivalent function when no data is missing.</p>
<ul class="simple">
<li>When spaces are used as delimiters, or when no delimiter has been given
as input, there should not be any missing data between two fields.</li>
<li>When the variables are named (either by a flexible dtype or with <cite>names</cite>,
there must not be any header in the file (else a ValueError
exception is raised).</li>
<li>Individual values are not stripped of spaces by default.
When using a custom converter, make sure the function does remove spaces.</li>
</ul>
<table class="docutils footnote" frame="void" id="id75" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>NumPy User Guide, section <a class="reference external" href="http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html">I/O with NumPy</a>.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Comma delimited file with mixed dtype</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;1,1.3,abcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;i8&#39;</span><span class="p">),(</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;f8&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">&#39;mystring&#39;</span><span class="p">,</span><span class="s1">&#39;S5&#39;</span><span class="p">)],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, &#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>
</pre></div>
</div>
<p>Using dtype = None</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># needed for StringIO example only</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;mystring&#39;</span><span class="p">],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, &#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>
</pre></div>
</div>
<p>Specifying dtype and names</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i8,f8,S5&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;myint&#39;</span><span class="p">,</span><span class="s1">&#39;myfloat&#39;</span><span class="p">,</span><span class="s1">&#39;mystring&#39;</span><span class="p">],</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, &#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>
</pre></div>
</div>
<p>An example with fixed-width columns</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;11.3abcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intvar&#39;</span><span class="p">,</span><span class="s1">&#39;fltvar&#39;</span><span class="p">,</span><span class="s1">&#39;strvar&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">delimiter</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">array((1, 1.3, &#39;abcde&#39;),</span>
<span class="go">      dtype=[(&#39;intvar&#39;, &#39;&lt;i8&#39;), (&#39;fltvar&#39;, &#39;&lt;f8&#39;), (&#39;strvar&#39;, &#39;|S5&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ndfromtxt">
<code class="descclassname">numpy.</code><code class="descname">ndfromtxt</code><span class="sig-paren">(</span><em>fname</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ndfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a file and return it as a single array.</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.mafromtxt">
<code class="descclassname">numpy.</code><code class="descname">mafromtxt</code><span class="sig-paren">(</span><em>fname</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mafromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a text file and return a masked array.</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function to load ASCII data.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.recfromtxt">
<code class="descclassname">numpy.</code><code class="descname">recfromtxt</code><span class="sig-paren">(</span><em>fname</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recfromtxt" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data from a file and return it in a record array.</p>
<p>If <code class="docutils literal"><span class="pre">usemask=False</span></code> a standard <cite>recarray</cite> is returned,
if <code class="docutils literal"><span class="pre">usemask=True</span></code> a MaskedRecords array is returned.</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function</p>
<p>By default, <cite>dtype</cite> is None, which means that the data-type of the output
array will be determined from the data.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.recfromcsv">
<code class="descclassname">numpy.</code><code class="descname">recfromcsv</code><span class="sig-paren">(</span><em>fname</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.recfromcsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load ASCII data stored in a comma-separated file.</p>
<p>The returned array is a record array (if <code class="docutils literal"><span class="pre">usemask=False</span></code>, see
<cite>recarray</cite>) or a masked record array (if <code class="docutils literal"><span class="pre">usemask=True</span></code>,
see <cite>ma.mrecords.MaskedRecords</cite>).</p>
<p>fname, kwargs : For a description of input parameters, see <cite>genfromtxt</cite>.</p>
<p>numpy.genfromtxt : generic function to load ASCII data.</p>
<p>By default, <cite>dtype</cite> is None, which means that the data-type of the output
array will be determined from the data.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">load</code><span class="sig-paren">(</span><em>file</em>, <em>mmap_mode=None</em>, <em>allow_pickle=True</em>, <em>fix_imports=True</em>, <em>encoding='ASCII'</em><span class="sig-paren">)</span></dt>
<dd><p>Load arrays or pickled objects from <code class="docutils literal"><span class="pre">.npy</span></code>, <code class="docutils literal"><span class="pre">.npz</span></code> or pickled files.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">file-like object, string, or pathlib.Path</span></dt>
<dd>The file to read. File-like objects must support the
<code class="docutils literal"><span class="pre">seek()</span></code> and <code class="docutils literal"><span class="pre">read()</span></code> methods. Pickled files require that the
file-like object support the <code class="docutils literal"><span class="pre">readline()</span></code> method as well.</dd>
<dt>mmap_mode <span class="classifier-delimiter">:</span> <span class="classifier">{None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional</span></dt>
<dd>If not None, then memory-map the file, using the given mode (see
<cite>numpy.memmap</cite> for a detailed description of the modes).  A
memory-mapped array is kept on disk. However, it can be accessed
and sliced like any ndarray.  Memory mapping is especially useful
for accessing small fragments of large files without reading the
entire file into memory.</dd>
<dt>allow_pickle <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Allow loading pickled object arrays stored in npy files. Reasons for
disallowing pickles include security, as loading pickled data can
execute arbitrary code. If pickles are disallowed, loading object
arrays will fail.
Default: True</dd>
<dt>fix_imports <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Only useful when loading Python 2 generated pickled files on Python 3,
which includes npy/npz files containing object arrays. If <cite>fix_imports</cite>
is True, pickle will try to map the old Python 2 names to the new names
used in Python 3.</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd>What encoding to use when reading Python 2 strings. Only useful when
loading Python 2 generated pickled files in Python 3, which includes
npy/npz files containing object arrays. Values other than ‘latin1’,
‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical
data. Default: ‘ASCII’</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">array, tuple, dict, etc.</span></dt>
<dd>Data stored in the file. For <code class="docutils literal"><span class="pre">.npz</span></code> files, the returned instance
of NpzFile class must be closed to avoid leaking file descriptors.</dd>
</dl>
<dl class="docutils">
<dt>IOError</dt>
<dd>If the input file does not exist or cannot be read.</dd>
<dt>ValueError</dt>
<dd>The file contains an object array, but allow_pickle=False given.</dd>
</dl>
<p>save, savez, savez_compressed, loadtxt
memmap : Create a memory-map to an array stored in a file on disk.
lib.format.open_memmap : Create or load a memory-mapped <code class="docutils literal"><span class="pre">.npy</span></code> file.</p>
<ul>
<li><p class="first">If the file contains pickle data, then whatever object is stored
in the pickle is returned.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npy</span></code> file, then a single array is returned.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npz</span></code> file, then a dictionary-like object is
returned, containing <code class="docutils literal"><span class="pre">{filename:</span> <span class="pre">array}</span></code> key-value pairs, one for
each file in the archive.</p>
</li>
<li><p class="first">If the file is a <code class="docutils literal"><span class="pre">.npz</span></code> file, the returned value supports the
context manager protocol in a similar fashion to the open function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">load</span><span class="p">(</span><span class="s1">&#39;foo.npz&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The underlying file descriptor is closed when exiting the ‘with’
block.</p>
</li>
</ul>
<p>Store data to disk, and load it again:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/tmp/123&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<p>Store compressed data to disk, and load it again:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Mem-map the stored array, and then access the second row
directly from disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npy&#39;</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">memmap([4, 5, 6])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">numpy.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="numpy.save">
<code class="descclassname">numpy.</code><code class="descname">save</code><span class="sig-paren">(</span><em>file</em>, <em>arr</em>, <em>allow_pickle=True</em>, <em>fix_imports=True</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an array to a binary file in NumPy <code class="docutils literal"><span class="pre">.npy</span></code> format.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">file, str, or pathlib.Path</span></dt>
<dd>File or filename to which the data is saved.  If file is a file-object,
then the filename is unchanged.  If file is a string or Path, a <code class="docutils literal"><span class="pre">.npy</span></code>
extension will be appended to the file name if it does not already
have one.</dd>
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array data to be saved.</dd>
<dt>allow_pickle <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Allow saving object arrays using Python pickles. Reasons for disallowing
pickles include security (loading pickled data can execute arbitrary
code) and portability (pickled objects may not be loadable on different
Python installations, for example if the stored objects require libraries
that are not available, and not all pickled data is compatible between
Python 2 and Python 3).
Default: True</dd>
<dt>fix_imports <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Only useful in forcing objects in object arrays on Python 3 to be
pickled in a Python 2 compatible way. If <cite>fix_imports</cite> is True, pickle
will try to map the new Python 3 names to the old module names used in
Python 2, so that the pickle data stream is readable with Python 2.</dd>
</dl>
<p>savez : Save several arrays into a <code class="docutils literal"><span class="pre">.npz</span></code> archive
savetxt, load</p>
<p>For a description of the <code class="docutils literal"><span class="pre">.npy</span></code> format, see <code class="xref py py-mod docutils literal"><span class="pre">numpy.lib.format</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="k">import</span> <span class="n">TemporaryFile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Only needed here to simulate closing &amp; reopening file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.savez">
<code class="descclassname">numpy.</code><code class="descname">savez</code><span class="sig-paren">(</span><em>file</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savez" title="Permalink to this definition">¶</a></dt>
<dd><p>Save several arrays into a single file in uncompressed <code class="docutils literal"><span class="pre">.npz</span></code> format.</p>
<p>If arguments are passed in with no keywords, the corresponding variable
names, in the <code class="docutils literal"><span class="pre">.npz</span></code> file, are ‘arr_0’, ‘arr_1’, etc. If keyword
arguments are given, the corresponding variable names, in the <code class="docutils literal"><span class="pre">.npz</span></code>
file will match the keyword names.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">str or file</span></dt>
<dd>Either the file name (string) or an open file (file-like object)
where the data will be saved. If file is a string or a Path, the
<code class="docutils literal"><span class="pre">.npz</span></code> extension will be appended to the file name if it is not
already there.</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">Arguments, optional</span></dt>
<dd>Arrays to save to the file. Since it is not possible for Python to
know the names of the arrays outside <cite>savez</cite>, the arrays will be saved
with names “arr_0”, “arr_1”, and so on. These arguments can be any
expression.</dd>
<dt>kwds <span class="classifier-delimiter">:</span> <span class="classifier">Keyword arguments, optional</span></dt>
<dd>Arrays to save to the file. Arrays will be saved in the file with the
keyword names.</dd>
</dl>
<p>None</p>
<p>save : Save a single array to a binary file in NumPy format.
savetxt : Save an array to a file as plain text.
savez_compressed : Save several arrays into a compressed <code class="docutils literal"><span class="pre">.npz</span></code> archive</p>
<p>The <code class="docutils literal"><span class="pre">.npz</span></code> file format is a zipped archive of files named after the
variables they contain.  The archive is not compressed and each file
in the archive contains one variable in <code class="docutils literal"><span class="pre">.npy</span></code> format. For a
description of the <code class="docutils literal"><span class="pre">.npy</span></code> format, see <code class="xref py py-mod docutils literal"><span class="pre">numpy.lib.format</span></code>.</p>
<p>When opening the saved <code class="docutils literal"><span class="pre">.npz</span></code> file with <cite>load</cite> a <cite>NpzFile</cite> object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the <code class="docutils literal"><span class="pre">.files</span></code> attribute), and for the arrays
themselves.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="k">import</span> <span class="n">TemporaryFile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <cite>savez</cite> with *args, the arrays are saved with default names.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Only needed here to simulate closing &amp; reopening file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="o">.</span><span class="n">files</span>
<span class="go">[&#39;arr_1&#39;, &#39;arr_0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p>Using <cite>savez</cite> with **kwds, the arrays are saved with the keyword names.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outfile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">outfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="o">.</span><span class="n">files</span>
<span class="go">[&#39;y&#39;, &#39;x&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npzfile</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.savez_compressed">
<code class="descclassname">numpy.</code><code class="descname">savez_compressed</code><span class="sig-paren">(</span><em>file</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.savez_compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Save several arrays into a single file in compressed <code class="docutils literal"><span class="pre">.npz</span></code> format.</p>
<p>If keyword arguments are given, then filenames are taken from the keywords.
If arguments are passed in with no keywords, then stored file names are
arr_0, arr_1, etc.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">str or file</span></dt>
<dd>Either the file name (string) or an open file (file-like object)
where the data will be saved. If file is a string or a Path, the
<code class="docutils literal"><span class="pre">.npz</span></code> extension will be appended to the file name if it is not
already there.</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">Arguments, optional</span></dt>
<dd>Arrays to save to the file. Since it is not possible for Python to
know the names of the arrays outside <cite>savez</cite>, the arrays will be saved
with names “arr_0”, “arr_1”, and so on. These arguments can be any
expression.</dd>
<dt>kwds <span class="classifier-delimiter">:</span> <span class="classifier">Keyword arguments, optional</span></dt>
<dd>Arrays to save to the file. Arrays will be saved in the file with the
keyword names.</dd>
</dl>
<p>None</p>
<p>numpy.save : Save a single array to a binary file in NumPy format.
numpy.savetxt : Save an array to a file as plain text.
numpy.savez : Save several arrays into an uncompressed <code class="docutils literal"><span class="pre">.npz</span></code> file format
numpy.load : Load the files created by savez_compressed.</p>
<p>The <code class="docutils literal"><span class="pre">.npz</span></code> file format is a zipped archive of files named after the
variables they contain.  The archive is compressed with
<code class="docutils literal"><span class="pre">zipfile.ZIP_DEFLATED</span></code> and each file in the archive contains one variable
in <code class="docutils literal"><span class="pre">.npy</span></code> format. For a description of the <code class="docutils literal"><span class="pre">.npy</span></code> format, see 
<code class="xref py py-mod docutils literal"><span class="pre">numpy.lib.format</span></code>.</p>
<p>When opening the saved <code class="docutils literal"><span class="pre">.npz</span></code> file with <cite>load</cite> a <cite>NpzFile</cite> object is
returned. This is a dictionary-like object which can be queried for
its list of arrays (with the <code class="docutils literal"><span class="pre">.files</span></code> attribute), and for the arrays
themselves.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">test_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="s1">&#39;/tmp/123&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">test_array</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">test_vector</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loaded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;/tmp/123.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="n">loaded</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">test_vector</span><span class="p">,</span> <span class="n">loaded</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.packbits">
<code class="descclassname">numpy.</code><code class="descname">packbits</code><span class="sig-paren">(</span><em>myarray</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.packbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Packs the elements of a binary-valued array into bits in a uint8 array.</p>
<p>The result is padded to full bytes by inserting zero bits at the end.</p>
<dl class="docutils">
<dt>myarray <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>An array of integers or booleans whose elements should be packed to
bits.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimension over which bit-packing is done.
<code class="docutils literal"><span class="pre">None</span></code> implies packing the flattened array.</dd>
</dl>
<dl class="docutils">
<dt>packed <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of type uint8 whose elements represent bits corresponding to the
logical (0 or nonzero) value of the input elements. The shape of
<cite>packed</cite> has the same number of dimensions as the input (unless <cite>axis</cite>
is None, in which case the output is 1-D).</dd>
</dl>
<dl class="docutils">
<dt>unpackbits: Unpacks elements of a uint8 array into a binary-valued output</dt>
<dd>array.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
<span class="gp">... </span>              <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[160],[64]],[[192],[32]]], dtype=uint8)</span>
</pre></div>
</div>
<p>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.unpackbits">
<code class="descclassname">numpy.</code><code class="descname">unpackbits</code><span class="sig-paren">(</span><em>myarray</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.unpackbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks elements of a uint8 array into a binary-valued output array.</p>
<p>Each element of <cite>myarray</cite> represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is either
1-D (if <cite>axis</cite> is None) or the same shape as the input array with unpacking
done along the axis specified.</p>
<dl class="docutils">
<dt>myarray <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, uint8 type</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimension over which bit-unpacking is done.
<code class="docutils literal"><span class="pre">None</span></code> implies unpacking the flattened array.</dd>
</dl>
<dl class="docutils">
<dt>unpacked <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, uint8 type</span></dt>
<dd>The elements are binary-valued (0 or 1).</dd>
</dl>
<dl class="docutils">
<dt>packbits <span class="classifier-delimiter">:</span> <span class="classifier">Packs the elements of a binary-valued array into bits in a uint8</span></dt>
<dd>array.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">23</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 2],</span>
<span class="go">       [ 7],</span>
<span class="go">       [23]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.fromregex">
<code class="descclassname">numpy.</code><code class="descname">fromregex</code><span class="sig-paren">(</span><em>file</em>, <em>regexp</em>, <em>dtype</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fromregex" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array from a text file, using regular expression parsing.</p>
<p>The returned array is always a structured array, and is constructed from
all matches of the regular expression in the file. Groups in the regular
expression are converted to fields of the structured array.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">str or file</span></dt>
<dd>File name or file object to read.</dd>
<dt>regexp <span class="classifier-delimiter">:</span> <span class="classifier">str or regexp</span></dt>
<dd>Regular expression used to parse the file.
Groups in the regular expression correspond to fields in the dtype.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype or list of dtypes</span></dt>
<dd>Dtype for the structured array.</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Encoding used to decode the inputfile. Does not apply to input streams.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.14.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The output array, containing the part of the content of <cite>file</cite> that
was matched by <cite>regexp</cite>. <cite>output</cite> is always a structured array.</dd>
</dl>
<dl class="docutils">
<dt>TypeError</dt>
<dd>When <cite>dtype</cite> is not a valid dtype for a structured array.</dd>
</dl>
<p>fromstring, loadtxt</p>
<p>Dtypes for structured arrays can be specified in several forms, but all
forms specify at least the data type and field name. For details see
<cite>doc.structured_arrays</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1312 foo</span><span class="se">\n</span><span class="s2">1534  bar</span><span class="se">\n</span><span class="s2">444   qux&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regexp</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\d+)\s+(...)&quot;</span>  <span class="c1"># match [digits, whitespace, anything]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromregex</span><span class="p">(</span><span class="s1">&#39;test.dat&#39;</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="p">[(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;S3&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span>
<span class="go">array([(1312L, &#39;foo&#39;), (1534L, &#39;bar&#39;), (444L, &#39;qux&#39;)],</span>
<span class="go">      dtype=[(&#39;num&#39;, &#39;&lt;i8&#39;), (&#39;key&#39;, &#39;|S3&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output</span><span class="p">[</span><span class="s1">&#39;num&#39;</span><span class="p">]</span>
<span class="go">array([1312, 1534,  444], dtype=int64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="numpy.DataSource">
<em class="property">class </em><code class="descclassname">numpy.</code><code class="descname">DataSource</code><span class="sig-paren">(</span><em>destpath='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A generic data source file (file, http, ftp, …).</p>
<p>DataSources can be local files or remote files/URLs.  The files may
also be compressed or uncompressed. DataSource hides some of the
low-level details of downloading the file, allowing you to simply pass
in a valid file path (or URL) and obtain a file object.</p>
<dl class="docutils">
<dt>destpath <span class="classifier-delimiter">:</span> <span class="classifier">str or None, optional</span></dt>
<dd>Path to the directory where the source file gets downloaded to for
use.  If <cite>destpath</cite> is None, a temporary directory will be created.
The default path is the current directory.</dd>
</dl>
<p>URLs require a scheme string (<code class="docutils literal"><span class="pre">http://</span></code>) to be used, without it they
will fail:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span> <span class="o">=</span> <span class="n">DataSource</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;www.google.com/index.html&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repos</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/index.html&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Temporary directories are deleted when the DataSource is deleted.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">DataSource</span><span class="p">(</span><span class="s1">&#39;/home/guido&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlname</span> <span class="o">=</span> <span class="s1">&#39;http://www.google.com/index.html&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gfile</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/index.html&#39;</span><span class="p">)</span>  <span class="c1"># remote file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">urlname</span><span class="p">)</span>
<span class="go">&#39;/home/guido/www.google.com/site/index.html&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span> <span class="o">=</span> <span class="n">DataSource</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># use with temporary file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;/home/guido/foobar.txt&#39;</span><span class="p">)</span>
<span class="go">&lt;open file &#39;/home/guido.foobar.txt&#39;, mode &#39;r&#39; at 0x91d4430&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;/home/guido/foobar.txt&#39;</span><span class="p">)</span>
<span class="go">&#39;/tmp/tmpy4pgsP/home/guido/foobar.txt&#39;</span>
</pre></div>
</div>
<dl class="method">
<dt id="numpy.DataSource.abspath">
<code class="descname">abspath</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.abspath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return absolute path of file in the DataSource directory.</p>
<p>If <cite>path</cite> is an URL, then <cite>abspath</cite> will return either the location
the file exists locally or the location it would exist when opened
using the <cite>open</cite> method.</p>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Can be a local file or a remote URL.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Complete path, including the <cite>DataSource</cite> destination directory.</dd>
</dl>
<p>The functionality is based on <cite>os.path.abspath</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.DataSource.exists">
<code class="descname">exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if path exists.</p>
<p>Test if <cite>path</cite> exists as (and in this order):</p>
<ul class="simple">
<li>a local file.</li>
<li>a remote URL that has been downloaded and stored locally in the
<cite>DataSource</cite> directory.</li>
<li>a remote URL that has not been downloaded, but is valid and
accessible.</li>
</ul>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Can be a local file or a remote URL.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if <cite>path</cite> exists.</dd>
</dl>
<p>When <cite>path</cite> is an URL, <cite>exists</cite> will return True if it’s either
stored locally in the <cite>DataSource</cite> directory, or is a valid remote
URL.  <cite>DataSource</cite> does not discriminate between the two, the file
is accessible if it exists in either location.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.DataSource.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>path</em>, <em>mode='r'</em>, <em>encoding=None</em>, <em>newline=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.DataSource.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open and return file-like object.</p>
<p>If <cite>path</cite> is an URL, it will be downloaded, stored in the
<cite>DataSource</cite> directory and opened from there.</p>
<dl class="docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Local file path or URL to open.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘r’, ‘w’, ‘a’}, optional</span></dt>
<dd>Mode to open <cite>path</cite>.  Mode ‘r’ for reading, ‘w’ for writing,
‘a’ to append. Available modes depend on the type of object
specified by <cite>path</cite>. Default is ‘r’.</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">{None, str}, optional</span></dt>
<dd>Open text file with given encoding. The default encoding will be
what <cite>io.open</cite> uses.</dd>
<dt>newline <span class="classifier-delimiter">:</span> <span class="classifier">{None, str}, optional</span></dt>
<dd>Newline to use when reading text file.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">file object</span></dt>
<dd>File object.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="numpy.fv">
<code class="descclassname">numpy.</code><code class="descname">fv</code><span class="sig-paren">(</span><em>rate</em>, <em>nper</em>, <em>pmt</em>, <em>pv</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.fv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the future value.</p>
<dl class="docutils">
<dt>Given:</dt>
<dd><ul class="first last simple">
<li>a present value, <cite>pv</cite></li>
<li>an interest <cite>rate</cite> compounded once per period, of which
there are</li>
<li><cite>nper</cite> total</li>
<li>a (fixed) payment, <cite>pmt</cite>, paid either</li>
<li>at the beginning (<cite>when</cite> = {‘begin’, 1}) or the end
(<cite>when</cite> = {‘end’, 0}) of each period</li>
</ul>
</dd>
<dt>Return:</dt>
<dd>the value at the end of the <cite>nper</cite> periods</dd>
</dl>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Rate of interest as decimal (not per cent) per period</dd>
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Number of compounding periods</dd>
<dt>pmt <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Payment</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Present value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0)).
Defaults to {‘end’, 0}.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Future values.  If all input is scalar, returns a scalar float.  If
any input is array_like, returns future values for each input element.
If multiple inputs are array_like, they all must have the same shape.</dd>
</dl>
<p>The future value is computed by solving the equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span>
<span class="n">pv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">+</span>
<span class="n">pmt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="o">*</span><span class="n">when</span><span class="p">)</span><span class="o">/</span><span class="n">rate</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>or, when <code class="docutils literal"><span class="pre">rate</span> <span class="pre">==</span> <span class="pre">0</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span> <span class="o">+</span> <span class="n">pmt</span> <span class="o">*</span> <span class="n">nper</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<table class="docutils citation" frame="void" id="wrw" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[WRW]</td><td>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
Open Document Format for Office Applications (OpenDocument)v1.2,
Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
Pre-Draft 12. Organization for the Advancement of Structured Information
Standards (OASIS). Billerica, MA, USA. [ODT Document].
Available:
<a class="reference external" href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>
OpenDocument-formula-20090508.odt</td></tr>
</tbody>
</table>
<p>What is the future value after 10 years of saving $100 now, with
an additional monthly savings of $100.  Assume the interest rate is
5% (annually) compounded monthly?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fv</span><span class="p">(</span><span class="mf">0.05</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>
<span class="go">15692.928894335748</span>
</pre></div>
</div>
<p>By convention, the negative sign represents cash flow out (i.e. money not
available today).  Thus, saving $100 a month at 5% annual interest leads
to $15,692.93 available to spend in 10 years.</p>
<p>If any input is array_like, returns an array of equal shape.  Let’s
compare different interest rates from the example above.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.06</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">))</span><span class="o">/</span><span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array([ 15692.92889434,  16569.87435405,  17509.44688102])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.pmt">
<code class="descclassname">numpy.</code><code class="descname">pmt</code><span class="sig-paren">(</span><em>rate</em>, <em>nper</em>, <em>pv</em>, <em>fv=0</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.pmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the payment against loan principal plus interest.</p>
<dl class="docutils">
<dt>Given:</dt>
<dd><ul class="first last simple">
<li>a present value, <cite>pv</cite> (e.g., an amount borrowed)</li>
<li>a future value, <cite>fv</cite> (e.g., 0)</li>
<li>an interest <cite>rate</cite> compounded once per period, of which
there are</li>
<li><cite>nper</cite> total</li>
<li>and (optional) specification of whether payment is made
at the beginning (<cite>when</cite> = {‘begin’, 1}) or the end
(<cite>when</cite> = {‘end’, 0}) of each period</li>
</ul>
</dd>
<dt>Return:</dt>
<dd>the (fixed) periodic payment.</dd>
</dl>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Rate of interest (per period)</dd>
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Number of compounding periods</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Present value</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">array_like,  optional</span></dt>
<dd>Future value (default = 0)</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0))</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Payment against loan plus interest.  If all input is scalar, returns a
scalar float.  If any input is array_like, returns payment for each
input element. If multiple inputs are array_like, they all must have
the same shape.</dd>
</dl>
<p>The payment is computed by solving the equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span>
<span class="n">pv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">+</span>
<span class="n">pmt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="o">*</span><span class="n">when</span><span class="p">)</span><span class="o">/</span><span class="n">rate</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>or, when <code class="docutils literal"><span class="pre">rate</span> <span class="pre">==</span> <span class="pre">0</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span> <span class="o">+</span> <span class="n">pmt</span> <span class="o">*</span> <span class="n">nper</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>for <code class="docutils literal"><span class="pre">pmt</span></code>.</p>
<p>Note that computing a monthly mortgage payment is only
one use for this function.  For example, pmt returns the
periodic deposit one must make to achieve a specified
future balance given an initial deposit, a fixed,
periodically compounded interest rate, and the total
number of periods.</p>
<table class="docutils citation" frame="void" id="id76" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[WRW]</td><td>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
Open Document Format for Office Applications (OpenDocument)v1.2,
Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
Pre-Draft 12. Organization for the Advancement of Structured Information
Standards (OASIS). Billerica, MA, USA. [ODT Document].
Available:
<a class="reference external" href="http://www.oasis-open.org/committees/documents.php">http://www.oasis-open.org/committees/documents.php</a>
?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</td></tr>
</tbody>
</table>
<p>What is the monthly payment needed to pay off a $200,000 loan in 15
years at an annual interest rate of 7.5%?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pmt</span><span class="p">(</span><span class="mf">0.075</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="mi">15</span><span class="p">,</span> <span class="mi">200000</span><span class="p">)</span>
<span class="go">-1854.0247200054619</span>
</pre></div>
</div>
<p>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained
today, a monthly payment of $1,854.02 would be required.  Note that this
example illustrates usage of <cite>fv</cite> having a default value of 0.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.nper">
<code class="descclassname">numpy.</code><code class="descname">nper</code><span class="sig-paren">(</span><em>rate</em>, <em>pmt</em>, <em>pv</em>, <em>fv=0</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nper" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of periodic payments.</p>
<p><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code> type is not supported.</p>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Rate of interest (per period)</dd>
<dt>pmt <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Payment</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Present value</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Future value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0))</dd>
</dl>
<p>The number of periods <code class="docutils literal"><span class="pre">nper</span></code> is computed by solving the equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">+</span> <span class="n">pmt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="o">*</span><span class="n">when</span><span class="p">)</span><span class="o">/</span><span class="n">rate</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>but if <code class="docutils literal"><span class="pre">rate</span> <span class="pre">=</span> <span class="pre">0</span></code> then:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span> <span class="o">+</span> <span class="n">pmt</span><span class="o">*</span><span class="n">nper</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>If you only had $150/month to pay towards the loan, how long would it take
to pay-off a loan of $8,000 at 7% annual interest?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nper</span><span class="p">(</span><span class="mf">0.07</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">150</span><span class="p">,</span> <span class="mi">8000</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">64.07335</span>
</pre></div>
</div>
<p>So, over 64 months would be required to pay off the loan.</p>
<p>The same analysis could be done with several different interest rates
and/or payments and/or total amounts to produce an entire table.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nper</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mf">0.07</span><span class="o">/</span><span class="mi">12</span><span class="p">:</span> <span class="mf">0.08</span><span class="o">/</span><span class="mi">12</span><span class="p">:</span> <span class="mf">0.01</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span>
<span class="gp">... </span>                   <span class="o">-</span><span class="mi">150</span>   <span class="p">:</span> <span class="o">-</span><span class="mi">99</span>     <span class="p">:</span> <span class="mi">50</span>    <span class="p">,</span>
<span class="gp">... </span>                   <span class="mi">8000</span>   <span class="p">:</span> <span class="mi">9001</span>    <span class="p">:</span> <span class="mi">1000</span><span class="p">]))</span>
<span class="go">array([[[  64.07334877,   74.06368256],</span>
<span class="go">        [ 108.07548412,  127.99022654]],</span>
<span class="go">       [[  66.12443902,   76.87897353],</span>
<span class="go">        [ 114.70165583,  137.90124779]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ipmt">
<code class="descclassname">numpy.</code><code class="descname">ipmt</code><span class="sig-paren">(</span><em>rate</em>, <em>per</em>, <em>nper</em>, <em>pv</em>, <em>fv=0</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ipmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the interest portion of a payment.</p>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Rate of interest as decimal (not per cent) per period</dd>
<dt>per <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Interest paid against the loan changes during the life or the loan.
The <cite>per</cite> is the payment period to calculate the interest amount.</dd>
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Number of compounding periods</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, )</span></dt>
<dd>Present value</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">scalar or array_like of shape(M, ), optional</span></dt>
<dd>Future value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0)).
Defaults to {‘end’, 0}.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Interest portion of payment.  If all input is scalar, returns a scalar
float.  If any input is array_like, returns interest payment for each
input element. If multiple inputs are array_like, they all must have
the same shape.</dd>
</dl>
<p>ppmt, pmt, pv</p>
<p>The total payment is made up of payment against principal plus interest.</p>
<p><code class="docutils literal"><span class="pre">pmt</span> <span class="pre">=</span> <span class="pre">ppmt</span> <span class="pre">+</span> <span class="pre">ipmt</span></code></p>
<p>What is the amortization schedule for a 1 year loan of $2500 at
8.24% interest per year compounded monthly?</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">principal</span> <span class="o">=</span> <span class="mf">2500.00</span>
</pre></div>
</div>
<p>The ‘per’ variable represents the periods of the loan.  Remember that
financial equations start the period count at 1!</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ipmt</span><span class="p">(</span><span class="mf">0.0824</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="n">principal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ppmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ppmt</span><span class="p">(</span><span class="mf">0.0824</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="n">principal</span><span class="p">)</span>
</pre></div>
</div>
<p>Each element of the sum of the ‘ipmt’ and ‘ppmt’ arrays should equal
‘pmt’.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pmt</span><span class="p">(</span><span class="mf">0.0824</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="n">principal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ipmt</span> <span class="o">+</span> <span class="n">ppmt</span><span class="p">,</span> <span class="n">pmt</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:2d}</span><span class="s1"> </span><span class="si">{1:8.2f}</span><span class="s1"> </span><span class="si">{2:8.2f}</span><span class="s1"> </span><span class="si">{3:8.2f}</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">payment</span> <span class="ow">in</span> <span class="n">per</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">index</span> <span class="o">=</span> <span class="n">payment</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">principal</span> <span class="o">=</span> <span class="n">principal</span> <span class="o">+</span> <span class="n">ppmt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">payment</span><span class="p">,</span> <span class="n">ppmt</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ipmt</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">principal</span><span class="p">))</span>
<span class="go"> 1  -200.58   -17.17  2299.42</span>
<span class="go"> 2  -201.96   -15.79  2097.46</span>
<span class="go"> 3  -203.35   -14.40  1894.11</span>
<span class="go"> 4  -204.74   -13.01  1689.37</span>
<span class="go"> 5  -206.15   -11.60  1483.22</span>
<span class="go"> 6  -207.56   -10.18  1275.66</span>
<span class="go"> 7  -208.99    -8.76  1066.67</span>
<span class="go"> 8  -210.42    -7.32   856.25</span>
<span class="go"> 9  -211.87    -5.88   644.38</span>
<span class="go">10  -213.32    -4.42   431.05</span>
<span class="go">11  -214.79    -2.96   216.26</span>
<span class="go">12  -216.26    -1.49    -0.00</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interestpd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ipmt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">interestpd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-112.98</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.ppmt">
<code class="descclassname">numpy.</code><code class="descname">ppmt</code><span class="sig-paren">(</span><em>rate</em>, <em>per</em>, <em>nper</em>, <em>pv</em>, <em>fv=0</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.ppmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the payment against loan principal.</p>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Rate of interest (per period)</dd>
<dt>per <span class="classifier-delimiter">:</span> <span class="classifier">array_like, int</span></dt>
<dd>Amount paid against the loan changes.  The <cite>per</cite> is the period of
interest.</dd>
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Number of compounding periods</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Present value</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Future value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0))</dd>
</dl>
<p>pmt, pv, ipmt</p>
</dd></dl>

<dl class="function">
<dt id="numpy.pv">
<code class="descclassname">numpy.</code><code class="descname">pv</code><span class="sig-paren">(</span><em>rate</em>, <em>nper</em>, <em>pmt</em>, <em>fv=0</em>, <em>when='end'</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.pv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the present value.</p>
<dl class="docutils">
<dt>Given:</dt>
<dd><ul class="first last simple">
<li>a future value, <cite>fv</cite></li>
<li>an interest <cite>rate</cite> compounded once per period, of which
there are</li>
<li><cite>nper</cite> total</li>
<li>a (fixed) payment, <cite>pmt</cite>, paid either</li>
<li>at the beginning (<cite>when</cite> = {‘begin’, 1}) or the end
(<cite>when</cite> = {‘end’, 0}) of each period</li>
</ul>
</dd>
<dt>Return:</dt>
<dd>the value now</dd>
</dl>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Rate of interest (per period)</dd>
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Number of compounding periods</dd>
<dt>pmt <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Payment</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Future value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0))</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, float</span></dt>
<dd>Present value of a series of payments or investments.</dd>
</dl>
<p>The present value is computed by solving the equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span>
<span class="n">pv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">+</span>
<span class="n">pmt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="o">*</span><span class="n">when</span><span class="p">)</span><span class="o">/</span><span class="n">rate</span><span class="o">*</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>or, when <code class="docutils literal"><span class="pre">rate</span> <span class="pre">=</span> <span class="pre">0</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span> <span class="o">+</span> <span class="n">pmt</span> <span class="o">*</span> <span class="n">nper</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>for <cite>pv</cite>, which is then returned.</p>
<table class="docutils citation" frame="void" id="id77" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[WRW]</td><td>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).
Open Document Format for Office Applications (OpenDocument)v1.2,
Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,
Pre-Draft 12. Organization for the Advancement of Structured Information
Standards (OASIS). Billerica, MA, USA. [ODT Document].
Available:
<a class="reference external" href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>
OpenDocument-formula-20090508.odt</td></tr>
</tbody>
</table>
<p>What is the present value (e.g., the initial investment)
of an investment that needs to total $15692.93
after 10 years of saving $100 every month?  Assume the
interest rate is 5% (annually) compounded monthly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pv</span><span class="p">(</span><span class="mf">0.05</span><span class="o">/</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mf">15692.93</span><span class="p">)</span>
<span class="go">-100.00067131625819</span>
</pre></div>
</div>
<p>By convention, the negative sign represents cash flow out
(i.e., money not available today).  Thus, to end up with
$15,692.93 in 10 years saving $100 a month at 5% annual
interest, one’s initial deposit should also be $100.</p>
<p>If any input is array_like, <code class="docutils literal"><span class="pre">pv</span></code> returns an array of equal shape.
Let’s compare different interest rates in the example above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">))</span><span class="o">/</span><span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mf">15692.93</span><span class="p">)</span>
<span class="go">array([ -100.00067132,  -649.26771385, -1273.78633713])</span>
</pre></div>
</div>
<p>So, to end up with the same $15692.93 under the same $100 per month
“savings plan,” for annual interest rates of 4% and 3%, one would
need initial investments of $649.27 and $1273.79, respectively.</p>
</dd></dl>

<dl class="function">
<dt id="numpy.rate">
<code class="descclassname">numpy.</code><code class="descname">rate</code><span class="sig-paren">(</span><em>nper</em>, <em>pmt</em>, <em>pv</em>, <em>fv</em>, <em>when='end'</em>, <em>guess=None</em>, <em>tol=None</em>, <em>maxiter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the rate of interest per period.</p>
<dl class="docutils">
<dt>nper <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Number of compounding periods</dd>
<dt>pmt <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Payment</dd>
<dt>pv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Present value</dd>
<dt>fv <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Future value</dd>
<dt>when <span class="classifier-delimiter">:</span> <span class="classifier">{{‘begin’, 1}, {‘end’, 0}}, {string, int}, optional</span></dt>
<dd>When payments are due (‘begin’ (1) or ‘end’ (0))</dd>
<dt>guess <span class="classifier-delimiter">:</span> <span class="classifier">Number, optional</span></dt>
<dd>Starting guess for solving the rate of interest, default 0.1</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">Number, optional</span></dt>
<dd>Required tolerance for the solution, default 1e-6</dd>
<dt>maxiter <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Maximum iterations in finding the solution</dd>
</dl>
<p>The rate of interest is computed by iteratively solving the
(non-linear) equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">+</span> <span class="n">pv</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">+</span> <span class="n">pmt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="o">*</span><span class="n">when</span><span class="p">)</span><span class="o">/</span><span class="n">rate</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">rate</span><span class="p">)</span><span class="o">**</span><span class="n">nper</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>for <code class="docutils literal"><span class="pre">rate</span></code>.</p>
<p>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document
Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated
Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12.
Organization for the Advancement of Structured Information Standards
(OASIS). Billerica, MA, USA. [ODT Document]. Available:
<a class="reference external" href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>
OpenDocument-formula-20090508.odt</p>
</dd></dl>

<dl class="function">
<dt id="numpy.irr">
<code class="descclassname">numpy.</code><code class="descname">irr</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.irr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Internal Rate of Return (IRR).</p>
<p>This is the “average” periodically compounded rate of return
that gives a net present value of 0.0; for a more complete explanation,
see Notes below.</p>
<p><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code> type is not supported.</p>
<dl class="docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape(N,)</span></dt>
<dd>Input cash flows per time period.  By convention, net “deposits”
are negative and net “withdrawals” are positive.  Thus, for
example, at least the first element of <cite>values</cite>, which represents
the initial investment, will typically be negative.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Internal Rate of Return for periodic input values.</dd>
</dl>
<p>The IRR is perhaps best understood through an example (illustrated
using np.irr in the Examples section below).  Suppose one invests 100
units and then makes the following withdrawals at regular (fixed)
intervals: 39, 59, 55, 20.  Assuming the ending value is 0, one’s 100
unit investment yields 173 units; however, due to the combination of
compounding and the periodic withdrawals, the “average” rate of return
is neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution
(for <span class="math">\(r\)</span>) of the equation:</p>
<div class="math">
\[-100 + \frac{39}{1+r} + \frac{59}{(1+r)^2}
+ \frac{55}{(1+r)^3} + \frac{20}{(1+r)^4} = 0\]</div>
<p>In general, for <cite>values</cite> <span class="math">\(= [v_0, v_1, ... v_M]\)</span>,
irr is the solution of the equation: <a class="reference internal" href="#id80" id="id78">[G]</a></p>
<div class="math">
\[\sum_{t=0}^M{\frac{v_t}{(1+irr)^{t}}} = 0\]</div>
<table class="docutils citation" frame="void" id="g" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[G]</td><td>L. J. Gitman, “Principles of Managerial Finance, Brief,” 3rd ed.,
Addison-Wesley, 2003, pg. 348.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">irr</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">0.28095</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">irr</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">74</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">-0.0955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">irr</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">-0.0833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">irr</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">0.06206</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">irr</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">0.0886</span>
</pre></div>
</div>
<p>(Compare with the Example given for numpy.lib.financial.npv)</p>
</dd></dl>

<dl class="function">
<dt id="numpy.npv">
<code class="descclassname">numpy.</code><code class="descname">npv</code><span class="sig-paren">(</span><em>rate</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.npv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the NPV (Net Present Value) of a cash flow series.</p>
<dl class="docutils">
<dt>rate <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The discount rate.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape(M, )</span></dt>
<dd>The values of the time series of cash flows.  The (fixed) time
interval between cash flow “events” must be the same as that for
which <cite>rate</cite> is given (i.e., if <cite>rate</cite> is per year, then precisely
a year is understood to elapse between each cash flow event).  By
convention, investments or “deposits” are negative, income or
“withdrawals” are positive; <cite>values</cite> must begin with the initial
investment, thus <cite>values[0]</cite> will typically be negative.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The NPV of the input cash flow series <cite>values</cite> at the discount
<cite>rate</cite>.</dd>
</dl>
<p>Returns the result of: <a class="reference internal" href="#id80" id="id79">[G]</a></p>
<div class="math">
\[\sum_{t=0}^{M-1}{\frac{values_t}{(1+rate)^{t}}}\]</div>
<table class="docutils citation" frame="void" id="id80" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[G]</td><td>L. J. Gitman, “Principles of Managerial Finance, Brief,” 3rd ed.,
Addison-Wesley, 2003, pg. 346.</td></tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">npv</span><span class="p">(</span><span class="mf">0.281</span><span class="p">,[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="go">-0.0084785916384548798</span>
</pre></div>
</div>
<p>(Compare with the Example given for numpy.lib.financial.irr)</p>
</dd></dl>

<dl class="function">
<dt id="numpy.mirr">
<code class="descclassname">numpy.</code><code class="descname">mirr</code><span class="sig-paren">(</span><em>values</em>, <em>finance_rate</em>, <em>reinvest_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.mirr" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified internal rate of return.</p>
<dl class="docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Cash flows (must contain at least one positive and one negative
value) or nan is returned.  The first value is considered a sunk
cost at time zero.</dd>
<dt>finance_rate <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Interest rate paid on the cash flows</dd>
<dt>reinvest_rate <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>Interest rate received on the cash flows upon reinvestment</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Modified internal rate of return</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numpy.nansum">
<code class="descclassname">numpy.</code><code class="descname">nansum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.</p>
<p>In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose sum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the sum is computed. The default is to compute the
sum of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd><p class="first">The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first">Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details. The casting of NaN to integer can yield
unexpected results.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>nansum <span class="classifier-delimiter">:</span> <span class="classifier">ndarray.</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</dd>
</dl>
<p>numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite: Show which elements are not NaN or +/-inf.</p>
<p>If both positive and negative infinity are present, the sum will be Not
A Number (NaN).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="c1"># both +/- infinity present</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanmax">
<code class="descclassname">numpy.</code><code class="descname">nanmax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a <code class="docutils literal"><span class="pre">RuntimeWarning</span></code> is
raised and NaN is returned for that slice.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose maximum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the maximum is computed. The default is to compute
the maximum of the flattened array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first">Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>max</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>nanmax <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the same shape as <cite>a</cite>, with the specified axis removed.
If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as <cite>a</cite> is returned.</dd>
</dl>
<dl class="docutils">
<dt>nanmin :</dt>
<dd>The minimum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>amax :</dt>
<dd>The maximum value of an array along a given axis, propagating any NaNs.</dd>
<dt>fmax :</dt>
<dd>Element-wise maximum of two arrays, ignoring any NaNs.</dd>
<dt>maximum :</dt>
<dd>Element-wise maximum of two arrays, propagating any NaNs.</dd>
<dt>isnan :</dt>
<dd>Shows which elements are Not a Number (NaN).</dd>
<dt>isfinite:</dt>
<dd>Shows which elements are neither NaN nor infinity.</dd>
</dl>
<p>amin, fmin, minimum</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 3.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanmin">
<code class="descclassname">numpy.</code><code class="descname">nanmin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a <code class="docutils literal"><span class="pre">RuntimeWarning</span></code> is raised and
Nan is returned for that slice.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose minimum is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the minimum is computed. The default is to compute
the minimum of the flattened array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first">Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p>If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>min</cite> method
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
</dd>
</dl>
<dl class="docutils">
<dt>nanmin <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array with the same shape as <cite>a</cite>, with the specified axis
removed.  If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as <cite>a</cite> is returned.</dd>
</dl>
<dl class="docutils">
<dt>nanmax :</dt>
<dd>The maximum value of an array along a given axis, ignoring any NaNs.</dd>
<dt>amin :</dt>
<dd>The minimum value of an array along a given axis, propagating any NaNs.</dd>
<dt>fmin :</dt>
<dd>Element-wise minimum of two arrays, ignoring any NaNs.</dd>
<dt>minimum :</dt>
<dd>Element-wise minimum of two arrays, propagating any NaNs.</dd>
<dt>isnan :</dt>
<dd>Shows which elements are Not a Number (NaN).</dd>
<dt>isfinite:</dt>
<dd>Shows which elements are neither NaN nor infinity.</dd>
</dl>
<p>amax, fmax, maximum</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanargmax">
<code class="descclassname">numpy.</code><code class="descname">nanargmax</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanargmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices <code class="docutils literal"><span class="pre">ValueError</span></code> is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to operate.  By default flattened input is used.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array of indices or a single index value.</dd>
</dl>
<p>argmax, nanargmin</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanargmin">
<code class="descclassname">numpy.</code><code class="descname">nanargmin</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanargmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices <code class="docutils literal"><span class="pre">ValueError</span></code> is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to operate.  By default flattened input is used.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>An array of indices or a single index value.</dd>
</dl>
<p>argmin, nanargmax</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanmean">
<code class="descclassname">numpy.</code><code class="descname">nanmean</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose mean is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the means are computed. The default is to compute
the mean of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for inexact inputs, it is the same as the input
dtype.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>; if provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p class="last">If the value is anything but the default, then
<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods
of sub-classes of <cite>ndarray</cite>.  If the sub-classes methods
does not implement <cite>keepdims</cite> any exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>m <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned. Nan is
returned for slices that contain only NaNs.</dd>
</dl>
<p>average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar</p>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite>.  Specifying a
higher-precision accumulator using the <cite>dtype</cite> keyword can alleviate
this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.6666666666666665</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  3.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanmedian">
<code class="descclassname">numpy.</code><code class="descname">nanmedian</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanmedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis, while ignoring NaNs.</p>
<p>Returns the median of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, sequence of int, None}, optional</span></dt>
<dd>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p class="last">If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="docutils">
<dt>median <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>mean, median, percentile</p>
<p>Given a vector <code class="docutils literal"><span class="pre">V</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the median of <code class="docutils literal"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal"><span class="pre">V</span></code>, <code class="docutils literal"><span class="pre">V_sorted</span></code> - i.e.,
<code class="docutils literal"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal"><span class="pre">N</span></code> is odd and the average of the two
middle values of <code class="docutils literal"><span class="pre">V_sorted</span></code> when <code class="docutils literal"><span class="pre">N</span></code> is even.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 10.,  nan,   4.],</span>
<span class="go">   [  3.,   2.,   1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 6.5,  2.,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanpercentile">
<code class="descclassname">numpy.</code><code class="descname">nanpercentile</code><span class="sig-paren">(</span><em>a</em>, <em>q</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>interpolation='linear'</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanpercentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth percentile of the data along the specified axis,
while ignoring nan values.</p>
<p>Returns the qth percentile(s) of the array elements.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array, containing
nan values to be ignored.</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">array_like of float</span></dt>
<dd>Percentile or sequence of percentiles to compute, which must be between
0 and 100 inclusive.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the percentiles are computed. The
default is to compute the percentile(s) along a flattened
version of the array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</dd>
<dt>interpolation <span class="classifier-delimiter">:</span> <span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first">This optional parameter specifies the interpolation method to
use when the desired percentile lies between two data points
<code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<ul class="last simple">
<li>‘linear’: <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal"><span class="pre">i</span></code>
and <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>‘lower’: <code class="docutils literal"><span class="pre">i</span></code>.</li>
<li>‘higher’: <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>‘nearest’: <code class="docutils literal"><span class="pre">i</span></code> or <code class="docutils literal"><span class="pre">j</span></code>, whichever is nearest.</li>
<li>‘midpoint’: <code class="docutils literal"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</li>
</ul>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<p class="last">If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="docutils">
<dt>percentile <span class="classifier-delimiter">:</span> <span class="classifier">scalar or ndarray</span></dt>
<dd>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple percentiles are given, first axis of
the result corresponds to the percentiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>nanmean
nanmedian : equivalent to <code class="docutils literal"><span class="pre">nanpercentile(...,</span> <span class="pre">50)</span></code>
percentile, median, mean
nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].</p>
<p>Given a vector <code class="docutils literal"><span class="pre">V</span></code> of length <code class="docutils literal"><span class="pre">N</span></code>, the <code class="docutils literal"><span class="pre">q</span></code>-th percentile of
<code class="docutils literal"><span class="pre">V</span></code> is the value <code class="docutils literal"><span class="pre">q/100</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the percentile if the normalized ranking does not
match the location of <code class="docutils literal"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal"><span class="pre">q=50</span></code>, the same as the minimum if <code class="docutils literal"><span class="pre">q=0</span></code> and the
same as the maximum if <code class="docutils literal"><span class="pre">q=100</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 10.,  nan,   4.],</span>
<span class="go">      [  3.,   2.,   1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 6.5,  2.,   2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([ 6.5,  2.,   2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([ 6.5,  2. ,  2.5])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanvar">
<code class="descclassname">numpy.</code><code class="descname">nanvar</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis, while ignoring NaNs.</p>
<p>Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the variance is computed.  The default is to compute
the variance of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float32</cite>; for arrays of float types it is the same as
the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of non-NaN
elements. By default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</dd>
</dl>
<dl class="docutils">
<dt>variance <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <cite>out</cite> is None, return a new array containing the variance,
otherwise return a reference to the output array. If ddof is &gt;= the
number of non-NaN elements in a slice or the slice contains only
NaNs, then the result for that slice is NaN.</dd>
</dl>
<p>std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite
population.  <code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the
variance for normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<p>For this function to work on sub-classes of ndarray, they must define
<cite>sum</cite> with the kwarg <cite>keepdims</cite></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.5555555555555554</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.,  0.25])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanstd">
<code class="descclassname">numpy.</code><code class="descname">nanstd</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanstd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis, while
ignoring NaNs.</p>
<p>Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a <cite>RuntimeWarning</cite> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Calculate the standard deviation of the non-NaN values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the standard deviation is computed. The default is
to compute the standard deviation of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it
is the same as the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the
calculated values) will be cast if necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Means Delta Degrees of Freedom.  The divisor used in calculations
is <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal"><span class="pre">N</span></code> represents the number of non-NaN
elements.  By default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>a</cite>.</p>
<p class="last">If this value is anything but the default it is passed through
as-is to the relevant functions of the sub-classes.  If these
functions do not have a <cite>keepdims</cite> kwarg, a RuntimeError will
be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>standard_deviation <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above.</span></dt>
<dd>If <cite>out</cite> is None, return a new array containing the standard
deviation, otherwise return a reference to the output array. If
ddof is &gt;= the number of non-NaN elements in a slice or the slice
contains only NaNs, then the result for that slice is NaN.</dd>
</dl>
<p>var, mean, std
nanvar, nanmean
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean: <code class="docutils literal"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is
specified, the divisor <code class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard
statistical practice, <code class="docutils literal"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the
variance of the infinite population. <code class="docutils literal"><span class="pre">ddof=0</span></code> provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute value before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the <cite>dtype</cite>
keyword can alleviate this issue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.247219128924647</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.,  0.5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanprod">
<code class="descclassname">numpy.</code><code class="descname">nanprod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.</p>
<p>One is returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose product is desired. If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the product is computed. The default is to compute
the product of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>The type of the returned array and of the accumulator in which the
elements are summed.  By default, the dtype of <cite>a</cite> is used.  An
exception is when <cite>a</cite> has an integer type with less precision than
the platform (u)intp. In that case, the default will be either
(u)int32 or (u)int64 depending on whether the platform is 32 or 64
bits. For inexact inputs, dtype must be inexact.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  The default
is <code class="docutils literal"><span class="pre">None</span></code>. If provided, it must have the same shape as the
expected output, but the type will be cast if necessary.  See
<cite>doc.ufuncs</cite> for details. The casting of NaN to integer can yield
unexpected results.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, the axes which are reduced are left in the result as
dimensions with size one. With this option, the result will
broadcast correctly against the original <cite>arr</cite>.</dd>
</dl>
<dl class="docutils">
<dt>nanprod <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</dd>
</dl>
<p>numpy.prod : Product across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 3.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nancumsum">
<code class="descclassname">numpy.</code><code class="descname">nancumsum</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nancumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.</p>
<p>Zeros are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative sum is computed. The default
(None) is to compute the cumsum over the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary. See <cite>doc.ufuncs</cite>
(Section “Output arguments”) for more details.</dd>
</dl>
<dl class="docutils">
<dt>nancumsum <span class="classifier-delimiter">:</span> <span class="classifier">ndarray.</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</dd>
</dl>
<p>numpy.cumsum : Cumulative sum across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1.,  3.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 4.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1.,  3.],</span>
<span class="go">       [ 3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nancumprod">
<code class="descclassname">numpy.</code><code class="descname">nancumprod</code><span class="sig-paren">(</span><em>a</em>, <em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nancumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.</p>
<p>Ones are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.12.0.</span></p>
</div>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which the cumulative product is computed.  By default
the input is flattened.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</dd>
</dl>
<dl class="docutils">
<dt>nancumprod <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</dd>
</dl>
<p>numpy.cumprod : Cumulative product across array propagating NaNs.
isnan : Show which elements are NaN.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1.,  2.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.nanquantile">
<code class="descclassname">numpy.</code><code class="descname">nanquantile</code><span class="sig-paren">(</span><em>a</em>, <em>q</em>, <em>axis=None</em>, <em>out=None</em>, <em>overwrite_input=False</em>, <em>interpolation='linear'</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.nanquantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.
.. versionadded:: 1.15.0</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array, containing
nan values to be ignored</dd>
<dt>q <span class="classifier-delimiter">:</span> <span class="classifier">array_like of float</span></dt>
<dd>Quantile or sequence of quantiles to compute, which must be between
0 and 1 inclusive.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{int, tuple of int, None}, optional</span></dt>
<dd>Axis or axes along which the quantiles are computed. The
default is to compute the quantile(s) along a flattened
version of the array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then allow the input array <cite>a</cite> to be modified by intermediate
calculations, to save memory. In this case, the contents of the input
<cite>a</cite> after this function completes is undefined.</dd>
<dt>interpolation <span class="classifier-delimiter">:</span> <span class="classifier">{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first">This optional parameter specifies the interpolation method to
use when the desired quantile lies between two data points
<code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>:</p>
<blockquote class="last">
<div><ul class="simple">
<li>linear: <code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">(j</span> <span class="pre">-</span> <span class="pre">i)</span> <span class="pre">*</span> <span class="pre">fraction</span></code>, where <code class="docutils literal"><span class="pre">fraction</span></code>
is the fractional part of the index surrounded by <code class="docutils literal"><span class="pre">i</span></code>
and <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>lower: <code class="docutils literal"><span class="pre">i</span></code>.</li>
<li>higher: <code class="docutils literal"><span class="pre">j</span></code>.</li>
<li>nearest: <code class="docutils literal"><span class="pre">i</span></code> or <code class="docutils literal"><span class="pre">j</span></code>, whichever is nearest.</li>
<li>midpoint: <code class="docutils literal"><span class="pre">(i</span> <span class="pre">+</span> <span class="pre">j)</span> <span class="pre">/</span> <span class="pre">2</span></code>.</li>
</ul>
</div></blockquote>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left in
the result as dimensions with size one. With this option, the
result will broadcast correctly against the original array <cite>a</cite>.</p>
<p class="last">If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
<cite>mean</cite> function of the underlying array.  If the array is
a sub-class and <cite>mean</cite> does not have the kwarg <cite>keepdims</cite> this
will raise a RuntimeError.</p>
</dd>
</dl>
<dl class="docutils">
<dt>quantile <span class="classifier-delimiter">:</span> <span class="classifier">scalar or ndarray</span></dt>
<dd>If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</dd>
</dl>
<p>quantile
nanmean, nanmedian
nanmedian : equivalent to <code class="docutils literal"><span class="pre">nanquantile(...,</span> <span class="pre">0.5)</span></code>
nanpercentile : same as nanquantile, but with q in the range [0, 100].</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 10.,  nan,   4.],</span>
<span class="go">      [  3.,   2.,   1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 6.5,  2.,   2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([ 6.5,  2.,   2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([ 6.5,  2. ,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.histogram">
<code class="descclassname">numpy.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>a</em>, <em>bins=10</em>, <em>range=None</em>, <em>normed=None</em>, <em>weights=None</em>, <em>density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the histogram of a set of data.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data. The histogram is computed over the flattened array.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of scalars or str, optional</span></dt>
<dd><p class="first">If <cite>bins</cite> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <cite>bins</cite> is a
sequence, it defines the bin edges, including the rightmost
edge, allowing for non-uniform bin widths.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<p class="last">If <cite>bins</cite> is a string, it defines the method used to calculate the
optimal bin width, as defined by <cite>histogram_bin_edges</cite>.</p>
</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="classifier">(float, float), optional</span></dt>
<dd>The lower and upper range of the bins.  If not provided, range
is simply <code class="docutils literal"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></code>.  Values outside the range are
ignored. The first element of the range must be less than or
equal to the second. <cite>range</cite> affects the automatic bin
computation as well. While bin width is computed to be optimal
based on the actual data within <cite>range</cite>, the bin count will fill
the entire range including portions containing no data.</dd>
</dl>
<p>normed : bool, optional</p>
<blockquote>
<div><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.6.0.</span></p>
</div>
<p>This is equivalent to the <cite>density</cite> argument, but produces incorrect
results for unequal bin widths. It should not be used.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.15.0: </span>DeprecationWarnings are actually emitted.</p>
</div>
</div></blockquote>
<dl class="docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>An array of weights, of the same shape as <cite>a</cite>.  Each value in
<cite>a</cite> only contributes its associated weight towards the bin count
(instead of 1). If <cite>density</cite> is True, the weights are
normalized, so that the integral of the density over the range
remains 1.</dd>
<dt>density <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If <code class="docutils literal"><span class="pre">False</span></code>, the result will contain the number of samples in
each bin. If <code class="docutils literal"><span class="pre">True</span></code>, the result is the value of the
probability <em>density</em> function at the bin, normalized such that
the <em>integral</em> over the range is 1. Note that the sum of the
histogram values will not be equal to 1 unless bins of unity
width are chosen; it is not a probability <em>mass</em> function.</p>
<p class="last">Overrides the <code class="docutils literal"><span class="pre">normed</span></code> keyword if given.</p>
</dd>
</dl>
<dl class="docutils">
<dt>hist <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>The values of the histogram. See <cite>density</cite> and <cite>weights</cite> for a
description of the possible semantics.</dd>
<dt>bin_edges <span class="classifier-delimiter">:</span> <span class="classifier">array of dtype float</span></dt>
<dd>Return the bin edges <code class="docutils literal"><span class="pre">(length(hist)+1)</span></code>.</dd>
</dl>
<p>histogramdd, bincount, searchsorted, digitize, histogram_bin_edges</p>
<p>All but the last (righthand-most) bin is half-open.  In other words,
if <cite>bins</cite> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>then the first bin is <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2)</span></code> (including 1, but excluding 2) and
the second <code class="docutils literal"><span class="pre">[2,</span> <span class="pre">3)</span></code>.  The last bin, however, is <code class="docutils literal"><span class="pre">[3,</span> <span class="pre">4]</span></code>, which
<em>includes</em> 4.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">(array([0, 2, 1]), array([0, 1, 2, 3]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">bins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(array([1, 4, 1]), array([0, 1, 2, 3]))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span>
<span class="go">array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">2.4999999999999996</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.11.0.</span></p>
</div>
<p>Automated Bin Selection Methods example, using 2 peak random data
with 2000 points:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># deterministic random data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
<span class="gp">... </span>               <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>  <span class="c1"># arguments are passed to np.histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Histogram with &#39;auto&#39; bins&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.histogramdd">
<code class="descclassname">numpy.</code><code class="descname">histogramdd</code><span class="sig-paren">(</span><em>sample</em>, <em>bins=10</em>, <em>range=None</em>, <em>normed=None</em>, <em>weights=None</em>, <em>density=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogramdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the multidimensional histogram of some data.</p>
<dl class="docutils">
<dt>sample <span class="classifier-delimiter">:</span> <span class="classifier">(N, D) array, or (D, N) array_like</span></dt>
<dd><p class="first">The data to be histogrammed.</p>
<p>Note the unusual interpretation of sample when an array_like:</p>
<ul class="simple">
<li>When an array, each row is a coordinate in a D-dimensional space -
such as <code class="docutils literal"><span class="pre">histogramgramdd(np.array([p1,</span> <span class="pre">p2,</span> <span class="pre">p3]))</span></code>.</li>
<li>When an array_like, each element is the list of values for single
coordinate - such as <code class="docutils literal"><span class="pre">histogramgramdd((X,</span> <span class="pre">Y,</span> <span class="pre">Z))</span></code>.</li>
</ul>
<p class="last">The first form should be preferred.</p>
</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">sequence or int, optional</span></dt>
<dd><p class="first">The bin specification:</p>
<ul class="last simple">
<li>A sequence of arrays describing the bin edges along each dimension.</li>
<li>The number of bins for each dimension (nx, ny, … =bins)</li>
<li>The number of bins for all dimensions (nx=ny=…=bins).</li>
</ul>
</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="classifier">sequence, optional</span></dt>
<dd>A sequence of length D, each an optional (lower, upper) tuple giving
the outer bin edges to be used if the edges are not given explicitly in
<cite>bins</cite>.
An entry of None in the sequence results in the minimum and maximum
values being used for the corresponding dimension.
The default, None, is equivalent to passing a tuple of D None values.</dd>
<dt>density <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If False, the default, returns the number of samples in each bin.
If True, returns the probability <em>density</em> function at the bin,
<code class="docutils literal"><span class="pre">bin_count</span> <span class="pre">/</span> <span class="pre">sample_count</span> <span class="pre">/</span> <span class="pre">bin_volume</span></code>.</dd>
<dt>normed <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>An alias for the density argument that behaves identically. To avoid
confusion with the broken normed argument to <cite>histogram</cite>, <cite>density</cite>
should be preferred.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">(N,) array_like, optional</span></dt>
<dd>An array of values <cite>w_i</cite> weighing each sample <cite>(x_i, y_i, z_i, …)</cite>.
Weights are normalized to 1 if normed is True. If normed is False,
the values of the returned histogram are equal to the sum of the
weights belonging to the samples falling into each bin.</dd>
</dl>
<dl class="docutils">
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The multidimensional histogram of sample x. See normed and weights
for the different possible semantics.</dd>
<dt>edges <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>A list of D arrays describing the bin edges for each dimension.</dd>
</dl>
<p>histogram: 1-D histogram
histogram2d: 2-D histogram</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
<span class="go">((5, 8, 4), 6, 9, 5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="numpy.histogram_bin_edges">
<code class="descclassname">numpy.</code><code class="descname">histogram_bin_edges</code><span class="sig-paren">(</span><em>a</em>, <em>bins=10</em>, <em>range=None</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.histogram_bin_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate only the edges of the bins used by the <cite>histogram</cite> function.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Input data. The histogram is computed over the flattened array.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of scalars or str, optional</span></dt>
<dd><p class="first">If <cite>bins</cite> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <cite>bins</cite> is a
sequence, it defines the bin edges, including the rightmost
edge, allowing for non-uniform bin widths.</p>
<p>If <cite>bins</cite> is a string from the list below, <cite>histogram_bin_edges</cite> will use
the method chosen to calculate the optimal bin width and
consequently the number of bins (see <cite>Notes</cite> for more detail on
the estimators) from the data that falls within the requested
range. While the bin width will be optimal for the actual data
in the range, the number of bins will be computed to fill the
entire range, including the empty portions. For visualisation,
using the ‘auto’ option is suggested. Weighted data is not
supported for automated bin size selection.</p>
<dl class="last docutils">
<dt>‘auto’</dt>
<dd>Maximum of the ‘sturges’ and ‘fd’ estimators. Provides good
all around performance.</dd>
<dt>‘fd’ (Freedman Diaconis Estimator)</dt>
<dd>Robust (resilient to outliers) estimator that takes into
account data variability and data size.</dd>
<dt>‘doane’</dt>
<dd>An improved version of Sturges’ estimator that works better
with non-normal datasets.</dd>
<dt>‘scott’</dt>
<dd>Less robust estimator that that takes into account data
variability and data size.</dd>
<dt>‘rice’</dt>
<dd>Estimator does not take variability into account, only data
size. Commonly overestimates number of bins required.</dd>
<dt>‘sturges’</dt>
<dd>R’s default method, only accounts for data size. Only
optimal for gaussian data and underestimates number of bins
for large non-gaussian datasets.</dd>
<dt>‘sqrt’</dt>
<dd>Square root (of data size) estimator, used by Excel and
other programs for its speed and simplicity.</dd>
</dl>
</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="classifier">(float, float), optional</span></dt>
<dd>The lower and upper range of the bins.  If not provided, range
is simply <code class="docutils literal"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></code>.  Values outside the range are
ignored. The first element of the range must be less than or
equal to the second. <cite>range</cite> affects the automatic bin
computation as well. While bin width is computed to be optimal
based on the actual data within <cite>range</cite>, the bin count will fill
the entire range including portions containing no data.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>An array of weights, of the same shape as <cite>a</cite>.  Each value in
<cite>a</cite> only contributes its associated weight towards the bin count
(instead of 1). This is currently not used by any of the bin estimators,
but may be in the future.</dd>
</dl>
<dl class="docutils">
<dt>bin_edges <span class="classifier-delimiter">:</span> <span class="classifier">array of dtype float</span></dt>
<dd>The edges to pass into <cite>histogram</cite></dd>
</dl>
<p>histogram</p>
<p>The methods to estimate the optimal number of bins are well founded
in literature, and are inspired by the choices R provides for
histogram visualisation. Note that having the number of bins
proportional to <span class="math">\(n^{1/3}\)</span> is asymptotically optimal, which is
why it appears in most estimators. These are simply plug-in methods
that give good starting points for number of bins. In the equations
below, <span class="math">\(h\)</span> is the binwidth and <span class="math">\(n_h\)</span> is the number of
bins. All estimators that compute bin counts are recast to bin width
using the <cite>ptp</cite> of the data. The final bin count is obtained from
<code class="docutils literal"><span class="pre">np.round(np.ceil(range</span> <span class="pre">/</span> <span class="pre">h))</span></code>.</p>
<dl class="docutils">
<dt>‘Auto’ (maximum of the ‘Sturges’ and ‘FD’ estimators)</dt>
<dd>A compromise to get a good value. For small datasets the Sturges
value will usually be chosen, while larger datasets will usually
default to FD.  Avoids the overly conservative behaviour of FD
and Sturges for small and large datasets respectively.
Switchover point is usually <span class="math">\(a.size \approx 1000\)</span>.</dd>
<dt>‘FD’ (Freedman Diaconis Estimator)</dt>
<dd><div class="first math">
\[h = 2 \frac{IQR}{n^{1/3}}\]</div>
<p class="last">The binwidth is proportional to the interquartile range (IQR)
and inversely proportional to cube root of a.size. Can be too
conservative for small datasets, but is quite good for large
datasets. The IQR is very robust to outliers.</p>
</dd>
<dt>‘Scott’</dt>
<dd><div class="first math">
\[h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}\]</div>
<p class="last">The binwidth is proportional to the standard deviation of the
data and inversely proportional to cube root of <code class="docutils literal"><span class="pre">x.size</span></code>. Can
be too conservative for small datasets, but is quite good for
large datasets. The standard deviation is not very robust to
outliers. Values are very similar to the Freedman-Diaconis
estimator in the absence of outliers.</p>
</dd>
<dt>‘Rice’</dt>
<dd><div class="first math">
\[n_h = 2n^{1/3}\]</div>
<p class="last">The number of bins is only proportional to cube root of
<code class="docutils literal"><span class="pre">a.size</span></code>. It tends to overestimate the number of bins and it
does not take into account data variability.</p>
</dd>
<dt>‘Sturges’</dt>
<dd><div class="first math">
\[n_h = \log _{2}n+1\]</div>
<p class="last">The number of bins is the base 2 log of <code class="docutils literal"><span class="pre">a.size</span></code>.  This
estimator assumes normality of data and is too conservative for
larger, non-normal datasets. This is the default method in R’s
<code class="docutils literal"><span class="pre">hist</span></code> method.</p>
</dd>
<dt>‘Doane’</dt>
<dd><div class="first math">
\[ \begin{align}\begin{aligned}n_h = 1 + \log_{2}(n) +
            \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})\\g_1 = mean[(\frac{x - \mu}{\sigma})^3]\\\sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}\end{aligned}\end{align} \]</div>
<p class="last">An improved version of Sturges’ formula that produces better
estimates for non-normal datasets. This estimator attempts to
account for the skew of the data.</p>
</dd>
<dt>‘Sqrt’</dt>
<dd><div class="first math">
\[n_h = \sqrt n\]</div>
<p class="last">The simplest and fastest estimator. Only takes into account the
data size.</p>
</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([0.  , 0.25, 0.5 , 0.75, 1.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0. , 2.5, 5. ])</span>
</pre></div>
</div>
<p>For consistency with histogram, an array of pre-computed bins is
passed through unmodified:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>This function allows one set of bins to be computed, and reused across
multiple histograms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shared_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shared_bins</span>
<span class="go">array([0., 1., 2., 3., 4., 5.])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">shared_bins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">shared_bins</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">;</span> <span class="n">hist_1</span>
<span class="go">array([1, 1, 0, 1, 0])</span>
<span class="go">array([2, 0, 1, 1, 2])</span>
</pre></div>
</div>
<p>Which gives more easily comparable results than using separate bins for
each histogram:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">,</span> <span class="n">bins_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_1</span><span class="p">,</span> <span class="n">bins_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">group_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_0</span><span class="p">;</span> <span class="n">hist1</span>
<span class="go">array([1, 1, 1])</span>
<span class="go">array([2, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bins_0</span><span class="p">;</span> <span class="n">bins_1</span>
<span class="go">array([0., 1., 2., 3.])</span>
<span class="go">array([0.  , 1.25, 2.5 , 3.75, 5.  ])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">GillesPy2 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Sean Matthew, Dalton Nickerson, George Hall, Kevin Sanft, Brian Drawert.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>